<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - test_bitcoin_coverage.info - src/wallet/coinselection.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../index.html" title="Click to go to top-level">top level</a> - <a href="index.html" title="Click to go to directory src/wallet">src/wallet</a> - coinselection.cpp<span style="font-size: 80%;"> (source / <a href="coinselection.cpp.func-c.html" title="Click to go to function table">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">test_bitcoin_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryHi">95.8&nbsp;%</td>
            <td class="headerCovTableEntry">380</td>
            <td class="headerCovTableEntry">364</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2024-10-28 13:38:31</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">94.1&nbsp;%</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntry">32</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntryLo">70.2&nbsp;%</td>
            <td class="headerCovTableEntry">436</td>
            <td class="headerCovTableEntry">306</td>
          </tr>
                  <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">             Branch data     Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>                 :             : // Copyright (c) 2017-2022 The Bitcoin Core developers</span>
<span id="L2"><span class="lineNum">       2</span>                 :             : // Distributed under the MIT software license, see the accompanying</span>
<span id="L3"><span class="lineNum">       3</span>                 :             : // file COPYING or http://www.opensource.org/licenses/mit-license.php.</span>
<span id="L4"><span class="lineNum">       4</span>                 :             : </span>
<span id="L5"><span class="lineNum">       5</span>                 :             : #include &lt;wallet/coinselection.h&gt;</span>
<span id="L6"><span class="lineNum">       6</span>                 :             : </span>
<span id="L7"><span class="lineNum">       7</span>                 :             : #include &lt;common/system.h&gt;</span>
<span id="L8"><span class="lineNum">       8</span>                 :             : #include &lt;consensus/amount.h&gt;</span>
<span id="L9"><span class="lineNum">       9</span>                 :             : #include &lt;consensus/consensus.h&gt;</span>
<span id="L10"><span class="lineNum">      10</span>                 :             : #include &lt;interfaces/chain.h&gt;</span>
<span id="L11"><span class="lineNum">      11</span>                 :             : #include &lt;logging.h&gt;</span>
<span id="L12"><span class="lineNum">      12</span>                 :             : #include &lt;policy/feerate.h&gt;</span>
<span id="L13"><span class="lineNum">      13</span>                 :             : #include &lt;util/check.h&gt;</span>
<span id="L14"><span class="lineNum">      14</span>                 :             : #include &lt;util/moneystr.h&gt;</span>
<span id="L15"><span class="lineNum">      15</span>                 :             : </span>
<span id="L16"><span class="lineNum">      16</span>                 :             : #include &lt;numeric&gt;</span>
<span id="L17"><span class="lineNum">      17</span>                 :             : #include &lt;optional&gt;</span>
<span id="L18"><span class="lineNum">      18</span>                 :             : #include &lt;queue&gt;</span>
<span id="L19"><span class="lineNum">      19</span>                 :             : </span>
<span id="L20"><span class="lineNum">      20</span>                 :             : namespace wallet {</span>
<span id="L21"><span class="lineNum">      21</span>                 :             : // Common selection error across the algorithms</span>
<span id="L22"><span class="lineNum">      22</span>                 :<span class="tlaGNC tlaBgGNC">          22 : static util::Result&lt;SelectionResult&gt; ErrorMaxWeightExceeded()</span></span>
<span id="L23"><span class="lineNum">      23</span>                 :             : {</span>
<span id="L24"><span class="lineNum">      24</span>                 :<span class="tlaGNC">          22 :     return util::Error{_(&quot;The inputs size exceeds the maximum weight. &quot;</span></span>
<span id="L25"><span class="lineNum">      25</span>                 :<span class="tlaGNC">          22 :                          &quot;Please try sending a smaller amount or manually consolidating your wallet's UTXOs&quot;)};</span></span>
<span id="L26"><span class="lineNum">      26</span>                 :             : }</span>
<span id="L27"><span class="lineNum">      27</span>                 :             : </span>
<span id="L28"><span class="lineNum">      28</span>                 :             : // Sort by descending (effective) value prefer lower waste on tie</span>
<span id="L29"><span class="lineNum">      29</span>                 :             : struct {</span>
<span id="L30"><span class="lineNum">      30</span>                 :<span class="tlaGNC">     4870385 :     bool operator()(const OutputGroup&amp; a, const OutputGroup&amp; b) const</span></span>
<span id="L31"><span class="lineNum">      31</span>                 :             :     {</span>
<span id="L32"><span class="lineNum">      32</span>         [<span class="tlaGBC" title="Branch 0 was taken 2474358 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2396027 times"> + </span>]:<span class="tlaGNC">     4870385 :         if (a.GetSelectionAmount() == b.GetSelectionAmount()) {</span></span>
<span id="L33"><span class="lineNum">      33</span>                 :             :             // Lower waste is better when effective_values are tied</span>
<span id="L34"><span class="lineNum">      34</span>                 :<span class="tlaGNC">     2474358 :             return (a.fee - a.long_term_fee) &lt; (b.fee - b.long_term_fee);</span></span>
<span id="L35"><span class="lineNum">      35</span>                 :             :         }</span>
<span id="L36"><span class="lineNum">      36</span>                 :<span class="tlaGNC">     2396027 :         return a.GetSelectionAmount() &gt; b.GetSelectionAmount();</span></span>
<span id="L37"><span class="lineNum">      37</span>                 :             :     }</span>
<span id="L38"><span class="lineNum">      38</span>                 :             : } descending;</span>
<span id="L39"><span class="lineNum">      39</span>                 :             : </span>
<span id="L40"><span class="lineNum">      40</span>                 :             : // Sort by descending (effective) value prefer lower weight on tie</span>
<span id="L41"><span class="lineNum">      41</span>                 :             : struct {</span>
<span id="L42"><span class="lineNum">      42</span>                 :<span class="tlaGNC">        7475 :     bool operator()(const OutputGroup&amp; a, const OutputGroup&amp; b) const</span></span>
<span id="L43"><span class="lineNum">      43</span>                 :             :     {</span>
<span id="L44"><span class="lineNum">      44</span>         [<span class="tlaGBC" title="Branch 0 was taken 2395 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 5080 times"> + </span>]:<span class="tlaGNC">        7475 :         if (a.GetSelectionAmount() == b.GetSelectionAmount()) {</span></span>
<span id="L45"><span class="lineNum">      45</span>                 :             :             // Sort lower weight to front on tied effective_value</span>
<span id="L46"><span class="lineNum">      46</span>                 :<span class="tlaGNC">        2395 :             return a.m_weight &lt; b.m_weight;</span></span>
<span id="L47"><span class="lineNum">      47</span>                 :             :         }</span>
<span id="L48"><span class="lineNum">      48</span>                 :<span class="tlaGNC">        5080 :         return a.GetSelectionAmount() &gt; b.GetSelectionAmount();</span></span>
<span id="L49"><span class="lineNum">      49</span>                 :             :     }</span>
<span id="L50"><span class="lineNum">      50</span>                 :             : } descending_effval_weight;</span>
<span id="L51"><span class="lineNum">      51</span>                 :             : </span>
<span id="L52"><span class="lineNum">      52</span>                 :             : /*</span>
<span id="L53"><span class="lineNum">      53</span>                 :             :  * This is the Branch and Bound Coin Selection algorithm designed by Murch. It searches for an input</span>
<span id="L54"><span class="lineNum">      54</span>                 :             :  * set that can pay for the spending target and does not exceed the spending target by more than the</span>
<span id="L55"><span class="lineNum">      55</span>                 :             :  * cost of creating and spending a change output. The algorithm uses a depth-first search on a binary</span>
<span id="L56"><span class="lineNum">      56</span>                 :             :  * tree. In the binary tree, each node corresponds to the inclusion or the omission of a UTXO. UTXOs</span>
<span id="L57"><span class="lineNum">      57</span>                 :             :  * are sorted by their effective values and the tree is explored deterministically per the inclusion</span>
<span id="L58"><span class="lineNum">      58</span>                 :             :  * branch first. At each node, the algorithm checks whether the selection is within the target range.</span>
<span id="L59"><span class="lineNum">      59</span>                 :             :  * While the selection has not reached the target range, more UTXOs are included. When a selection's</span>
<span id="L60"><span class="lineNum">      60</span>                 :             :  * value exceeds the target range, the complete subtree deriving from this selection can be omitted.</span>
<span id="L61"><span class="lineNum">      61</span>                 :             :  * At that point, the last included UTXO is deselected and the corresponding omission branch explored</span>
<span id="L62"><span class="lineNum">      62</span>                 :             :  * instead. The search ends after the complete tree has been searched or after a limited number of tries.</span>
<span id="L63"><span class="lineNum">      63</span>                 :             :  *</span>
<span id="L64"><span class="lineNum">      64</span>                 :             :  * The search continues to search for better solutions after one solution has been found. The best</span>
<span id="L65"><span class="lineNum">      65</span>                 :             :  * solution is chosen by minimizing the waste metric. The waste metric is defined as the cost to</span>
<span id="L66"><span class="lineNum">      66</span>                 :             :  * spend the current inputs at the given fee rate minus the long term expected cost to spend the</span>
<span id="L67"><span class="lineNum">      67</span>                 :             :  * inputs, plus the amount by which the selection exceeds the spending target:</span>
<span id="L68"><span class="lineNum">      68</span>                 :             :  *</span>
<span id="L69"><span class="lineNum">      69</span>                 :             :  * waste = selectionTotal - target + inputs × (currentFeeRate - longTermFeeRate)</span>
<span id="L70"><span class="lineNum">      70</span>                 :             :  *</span>
<span id="L71"><span class="lineNum">      71</span>                 :             :  * The algorithm uses two additional optimizations. A lookahead keeps track of the total value of</span>
<span id="L72"><span class="lineNum">      72</span>                 :             :  * the unexplored UTXOs. A subtree is not explored if the lookahead indicates that the target range</span>
<span id="L73"><span class="lineNum">      73</span>                 :             :  * cannot be reached. Further, it is unnecessary to test equivalent combinations. This allows us</span>
<span id="L74"><span class="lineNum">      74</span>                 :             :  * to skip testing the inclusion of UTXOs that match the effective value and waste of an omitted</span>
<span id="L75"><span class="lineNum">      75</span>                 :             :  * predecessor.</span>
<span id="L76"><span class="lineNum">      76</span>                 :             :  *</span>
<span id="L77"><span class="lineNum">      77</span>                 :             :  * The Branch and Bound algorithm is described in detail in Murch's Master Thesis:</span>
<span id="L78"><span class="lineNum">      78</span>                 :             :  * https://murch.one/wp-content/uploads/2016/11/erhardt2016coinselection.pdf</span>
<span id="L79"><span class="lineNum">      79</span>                 :             :  *</span>
<span id="L80"><span class="lineNum">      80</span>                 :             :  * @param const std::vector&lt;OutputGroup&gt;&amp; utxo_pool The set of UTXO groups that we are choosing from.</span>
<span id="L81"><span class="lineNum">      81</span>                 :             :  *        These UTXO groups will be sorted in descending order by effective value and the OutputGroups'</span>
<span id="L82"><span class="lineNum">      82</span>                 :             :  *        values are their effective values.</span>
<span id="L83"><span class="lineNum">      83</span>                 :             :  * @param const CAmount&amp; selection_target This is the value that we want to select. It is the lower</span>
<span id="L84"><span class="lineNum">      84</span>                 :             :  *        bound of the range.</span>
<span id="L85"><span class="lineNum">      85</span>                 :             :  * @param const CAmount&amp; cost_of_change This is the cost of creating and spending a change output.</span>
<span id="L86"><span class="lineNum">      86</span>                 :             :  *        This plus selection_target is the upper bound of the range.</span>
<span id="L87"><span class="lineNum">      87</span>                 :             :  * @param int max_selection_weight The maximum allowed weight for a selection result to be valid.</span>
<span id="L88"><span class="lineNum">      88</span>                 :             :  * @returns The result of this coin selection algorithm, or std::nullopt</span>
<span id="L89"><span class="lineNum">      89</span>                 :             :  */</span>
<span id="L90"><span class="lineNum">      90</span>                 :             : </span>
<span id="L91"><span class="lineNum">      91</span>                 :             : static const size_t TOTAL_TRIES = 100000;</span>
<span id="L92"><span class="lineNum">      92</span>                 :             : </span>
<span id="L93"><span class="lineNum">      93</span>                 :<span class="tlaGNC">         229 : util::Result&lt;SelectionResult&gt; SelectCoinsBnB(std::vector&lt;OutputGroup&gt;&amp; utxo_pool, const CAmount&amp; selection_target, const CAmount&amp; cost_of_change,</span></span>
<span id="L94"><span class="lineNum">      94</span>                 :             :                                              int max_selection_weight)</span>
<span id="L95"><span class="lineNum">      95</span>                 :             : {</span>
<span id="L96"><span class="lineNum">      96</span>                 :<span class="tlaGNC">         229 :     SelectionResult result(selection_target, SelectionAlgorithm::BNB);</span></span>
<span id="L97"><span class="lineNum">      97</span>                 :<span class="tlaGNC">         229 :     CAmount curr_value = 0;</span></span>
<span id="L98"><span class="lineNum">      98</span>                 :<span class="tlaGNC">         229 :     std::vector&lt;size_t&gt; curr_selection; // selected utxo indexes</span></span>
<span id="L99"><span class="lineNum">      99</span>                 :<span class="tlaGNC">         229 :     int curr_selection_weight = 0; // sum of selected utxo weight</span></span>
<span id="L100"><span class="lineNum">     100</span>                 :             : </span>
<span id="L101"><span class="lineNum">     101</span>                 :             :     // Calculate curr_available_value</span>
<span id="L102"><span class="lineNum">     102</span>                 :<span class="tlaGNC">         229 :     CAmount curr_available_value = 0;</span></span>
<span id="L103"><span class="lineNum">     103</span>         [<span class="tlaGBC" title="Branch 0 was taken 164731 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 229 times"> + </span>]:<span class="tlaGNC">      164960 :     for (const OutputGroup&amp; utxo : utxo_pool) {</span></span>
<span id="L104"><span class="lineNum">     104</span>                 :             :         // Assert that this utxo is not negative. It should never be negative,</span>
<span id="L105"><span class="lineNum">     105</span>                 :             :         // effective value calculation should have removed it</span>
<span id="L106"><span class="lineNum">     106</span>   [<span class="tlaGBC" title="Branch 0 was taken 164731 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 164731 times"> + </span>]:<span class="tlaGNC">      164731 :         assert(utxo.GetSelectionAmount() &gt; 0);</span></span>
<span id="L107"><span class="lineNum">     107</span>         [<span class="tlaGBC" title="Branch 0 was taken 164731 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      164731 :         curr_available_value += utxo.GetSelectionAmount();</span></span>
<span id="L108"><span class="lineNum">     108</span>                 :             :     }</span>
<span id="L109"><span class="lineNum">     109</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 226 times"> + </span>]:<span class="tlaGNC">         229 :     if (curr_available_value &lt; selection_target) {</span></span>
<span id="L110"><span class="lineNum">     110</span>                 :<span class="tlaGNC">           6 :         return util::Error();</span></span>
<span id="L111"><span class="lineNum">     111</span>                 :             :     }</span>
<span id="L112"><span class="lineNum">     112</span>                 :             : </span>
<span id="L113"><span class="lineNum">     113</span>                 :             :     // Sort the utxo_pool</span>
<span id="L114"><span class="lineNum">     114</span>         [<span class="tlaGBC" title="Branch 0 was taken 226 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         226 :     std::sort(utxo_pool.begin(), utxo_pool.end(), descending);</span></span>
<span id="L115"><span class="lineNum">     115</span>                 :             : </span>
<span id="L116"><span class="lineNum">     116</span>                 :<span class="tlaGNC">         226 :     CAmount curr_waste = 0;</span></span>
<span id="L117"><span class="lineNum">     117</span>                 :<span class="tlaGNC">         226 :     std::vector&lt;size_t&gt; best_selection;</span></span>
<span id="L118"><span class="lineNum">     118</span>                 :<span class="tlaGNC">         226 :     CAmount best_waste = MAX_MONEY;</span></span>
<span id="L119"><span class="lineNum">     119</span>                 :             : </span>
<span id="L120"><span class="lineNum">     120</span>   [<span class="tlaGBC" title="Branch 0 was taken 226 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 226 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         226 :     bool is_feerate_high = utxo_pool.at(0).fee &gt; utxo_pool.at(0).long_term_fee;</span></span>
<span id="L121"><span class="lineNum">     121</span>                 :<span class="tlaGNC">         226 :     bool max_tx_weight_exceeded = false;</span></span>
<span id="L122"><span class="lineNum">     122</span>                 :             : </span>
<span id="L123"><span class="lineNum">     123</span>                 :             :     // Depth First search loop for choosing the UTXOs</span>
<span id="L124"><span class="lineNum">     124</span>         [<span class="tlaGBC" title="Branch 0 was taken 11085384 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 110 times"> + </span>]:<span class="tlaGNC">    11085494 :     for (size_t curr_try = 0, utxo_pool_index = 0; curr_try &lt; TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {</span></span>
<span id="L125"><span class="lineNum">     125</span>                 :             :         // Conditions for starting a backtrack</span>
<span id="L126"><span class="lineNum">     126</span>                 :<span class="tlaGNC">    11085384 :         bool backtrack = false;</span></span>
<span id="L127"><span class="lineNum">     127</span>         [<span class="tlaGBC" title="Branch 0 was taken 9689136 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1396248 times"> + </span>]:<span class="tlaGNC">    11085384 :         if (curr_value + curr_available_value &lt; selection_target || // Cannot possibly reach target with the amount remaining in the curr_available_value.</span></span>
<span id="L128"><span class="lineNum">     128</span>         [<span class="tlaGBC" title="Branch 0 was taken 5993412 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3695724 times"> + </span>]:<span class="tlaGNC">     9689136 :             curr_value &gt; selection_target + cost_of_change || // Selected value is out of range, go back and try other branch</span></span>
<span id="L129"><span class="lineNum">     129</span>         [<span class="tlaGBC" title="Branch 0 was taken 5993408 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 4 times"> + </span>]:<span class="tlaGNC">     5993412 :             (curr_waste &gt; best_waste &amp;&amp; is_feerate_high)) { // Don't select things which we know will be more wasteful if the waste is increasing</span></span>
<span id="L130"><span class="lineNum">     130</span>                 :             :             backtrack = true;</span>
<span id="L131"><span class="lineNum">     131</span>         [<span class="tlaGBC" title="Branch 0 was taken 5993370 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 38 times"> + </span>]:<span class="tlaGNC">     5993408 :         } else if (curr_selection_weight &gt; max_selection_weight) { // Selected UTXOs weight exceeds the maximum weight allowed, cannot find more solutions by adding more inputs</span></span>
<span id="L132"><span class="lineNum">     132</span>                 :             :             max_tx_weight_exceeded = true; // at least one selection attempt exceeded the max weight</span>
<span id="L133"><span class="lineNum">     133</span>                 :             :             backtrack = true;</span>
<span id="L134"><span class="lineNum">     134</span>         [<span class="tlaGBC" title="Branch 0 was taken 24709 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 5968661 times"> + </span>]:<span class="tlaGNC">     5993370 :         } else if (curr_value &gt;= selection_target) {       // Selected value is within range</span></span>
<span id="L135"><span class="lineNum">     135</span>                 :<span class="tlaGNC">       24709 :             curr_waste += (curr_value - selection_target); // This is the excess value which is added to the waste for the below comparison</span></span>
<span id="L136"><span class="lineNum">     136</span>                 :             :             // Adding another UTXO after this check could bring the waste down if the long term fee is higher than the current fee.</span>
<span id="L137"><span class="lineNum">     137</span>                 :             :             // However we are not going to explore that because this optimization for the waste is only done when we have hit our target</span>
<span id="L138"><span class="lineNum">     138</span>                 :             :             // value. Adding any more UTXOs will be just burning the UTXO; it will go entirely to fees. Thus we aren't going to</span>
<span id="L139"><span class="lineNum">     139</span>                 :             :             // explore any more UTXOs to avoid burning money like that.</span>
<span id="L140"><span class="lineNum">     140</span>         [<span class="tlaGBC" title="Branch 0 was taken 12399 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 12310 times"> + </span>]:<span class="tlaGNC">       24709 :             if (curr_waste &lt;= best_waste) {</span></span>
<span id="L141"><span class="lineNum">     141</span>         [<span class="tlaGBC" title="Branch 0 was taken 12399 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       12399 :                 best_selection = curr_selection;</span></span>
<span id="L142"><span class="lineNum">     142</span>                 :             :                 best_waste = curr_waste;</span>
<span id="L143"><span class="lineNum">     143</span>                 :             :             }</span>
<span id="L144"><span class="lineNum">     144</span>                 :<span class="tlaGNC">       24709 :             curr_waste -= (curr_value - selection_target); // Remove the excess value as we will be selecting different coins now</span></span>
<span id="L145"><span class="lineNum">     145</span>                 :<span class="tlaGNC">       24709 :             backtrack = true;</span></span>
<span id="L146"><span class="lineNum">     146</span>                 :             :         }</span>
<span id="L147"><span class="lineNum">     147</span>                 :             : </span>
<span id="L148"><span class="lineNum">     148</span>                 :<span class="tlaGNC">       24709 :         if (backtrack) { // Backtracking, moving backwards</span></span>
<span id="L149"><span class="lineNum">     149</span>         [<span class="tlaGBC" title="Branch 0 was taken 5116607 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 116 times"> + </span>]:<span class="tlaGNC">     5116723 :             if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched</span></span>
<span id="L150"><span class="lineNum">     150</span>                 :             :                 break;</span>
<span id="L151"><span class="lineNum">     151</span>                 :             :             }</span>
<span id="L152"><span class="lineNum">     152</span>                 :             : </span>
<span id="L153"><span class="lineNum">     153</span>                 :             :             // Add omitted UTXOs back to lookahead before traversing the omission branch of last included UTXO.</span>
<span id="L154"><span class="lineNum">     154</span>         [<span class="tlaGBC" title="Branch 0 was taken 5810132 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 5116607 times"> + </span>]:<span class="tlaGNC">    10926739 :             for (--utxo_pool_index; utxo_pool_index &gt; curr_selection.back(); --utxo_pool_index) {</span></span>
<span id="L155"><span class="lineNum">     155</span>   [<span class="tlaGBC" title="Branch 0 was taken 5810132 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 5810132 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">     5810132 :                 curr_available_value += utxo_pool.at(utxo_pool_index).GetSelectionAmount();</span></span>
<span id="L156"><span class="lineNum">     156</span>                 :             :             }</span>
<span id="L157"><span class="lineNum">     157</span>                 :             : </span>
<span id="L158"><span class="lineNum">     158</span>                 :             :             // Output was included on previous iterations, try excluding now.</span>
<span id="L159"><span class="lineNum">     159</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 5116607 times"> + </span>]:<span class="tlaGNC">     5116607 :             assert(utxo_pool_index == curr_selection.back());</span></span>
<span id="L160"><span class="lineNum">     160</span>         [<span class="tlaGBC" title="Branch 0 was taken 5116607 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     5116607 :             OutputGroup&amp; utxo = utxo_pool.at(utxo_pool_index);</span></span>
<span id="L161"><span class="lineNum">     161</span>         [<span class="tlaGBC" title="Branch 0 was taken 5116607 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     5116607 :             curr_value -= utxo.GetSelectionAmount();</span></span>
<span id="L162"><span class="lineNum">     162</span>                 :<span class="tlaGNC">     5116607 :             curr_waste -= utxo.fee - utxo.long_term_fee;</span></span>
<span id="L163"><span class="lineNum">     163</span>                 :<span class="tlaGNC">     5116607 :             curr_selection_weight -= utxo.m_weight;</span></span>
<span id="L164"><span class="lineNum">     164</span>                 :<span class="tlaGNC">     5116607 :             curr_selection.pop_back();</span></span>
<span id="L165"><span class="lineNum">     165</span>                 :             :         } else { // Moving forwards, continuing down this branch</span>
<span id="L166"><span class="lineNum">     166</span>         [<span class="tlaGBC" title="Branch 0 was taken 5968661 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     5968661 :             OutputGroup&amp; utxo = utxo_pool.at(utxo_pool_index);</span></span>
<span id="L167"><span class="lineNum">     167</span>                 :             : </span>
<span id="L168"><span class="lineNum">     168</span>                 :             :             // Remove this utxo from the curr_available_value utxo amount</span>
<span id="L169"><span class="lineNum">     169</span>         [<span class="tlaGBC" title="Branch 0 was taken 5968661 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     5968661 :             curr_available_value -= utxo.GetSelectionAmount();</span></span>
<span id="L170"><span class="lineNum">     170</span>                 :             : </span>
<span id="L171"><span class="lineNum">     171</span>                 :<span class="tlaGNC">    11935537 :             if (curr_selection.empty() ||</span></span>
<span id="L172"><span class="lineNum">     172</span>                 :             :                 // The previous index is included and therefore not relevant for exclusion shortcut</span>
<span id="L173"><span class="lineNum">     173</span>   [<span class="tlaGBC" title="Branch 0 was taken 4542856 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1424020 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 824118 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 3718738 times"> + </span>]:<span class="tlaGNC">    10509732 :                 (utxo_pool_index - 1) == curr_selection.back() ||</span></span>
<span id="L174"><span class="lineNum">     174</span>                 :             :                 // Avoid searching a branch if the previous UTXO has the same value and same waste and was excluded.</span>
<span id="L175"><span class="lineNum">     175</span>                 :             :                 // Since the ratio of fee to long term fee is the same, we only need to check if one of those values match in order to know that the waste is the same.</span>
<span id="L176"><span class="lineNum">     176</span>   [<span class="tlaGBC" title="Branch 0 was taken 5966876 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1785 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 4542856 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">    10511517 :                 utxo.GetSelectionAmount() != utxo_pool.at(utxo_pool_index - 1).GetSelectionAmount() ||</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 4542856 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 4542856 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L177"><span class="lineNum">     177</span>   [<span class="tlaGBC" title="Branch 0 was taken 824118 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 824115 times"> + </span>]:<span class="tlaGNC">      824118 :                 utxo.fee != utxo_pool.at(utxo_pool_index - 1).fee)</span></span>
<span id="L178"><span class="lineNum">     178</span>                 :             :             {</span>
<span id="L179"><span class="lineNum">     179</span>                 :             :                 // Inclusion branch first (Largest First Exploration)</span>
<span id="L180"><span class="lineNum">     180</span>         [<span class="tlaGBC" title="Branch 0 was taken 5144546 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     5144546 :                 curr_selection.push_back(utxo_pool_index);</span></span>
<span id="L181"><span class="lineNum">     181</span>         [<span class="tlaGBC" title="Branch 0 was taken 5144546 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     5144546 :                 curr_value += utxo.GetSelectionAmount();</span></span>
<span id="L182"><span class="lineNum">     182</span>                 :<span class="tlaGNC">     5144546 :                 curr_waste += utxo.fee - utxo.long_term_fee;</span></span>
<span id="L183"><span class="lineNum">     183</span>                 :<span class="tlaGNC">     5144546 :                 curr_selection_weight += utxo.m_weight;</span></span>
<span id="L184"><span class="lineNum">     184</span>                 :             :             }</span>
<span id="L185"><span class="lineNum">     185</span>                 :             :         }</span>
<span id="L186"><span class="lineNum">     186</span>                 :             :     }</span>
<span id="L187"><span class="lineNum">     187</span>                 :             : </span>
<span id="L188"><span class="lineNum">     188</span>                 :             :     // Check for solution</span>
<span id="L189"><span class="lineNum">     189</span>         [<span class="tlaGBC" title="Branch 0 was taken 112 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 114 times"> + </span>]:<span class="tlaGNC">         226 :     if (best_selection.empty()) {</span></span>
<span id="L190"><span class="lineNum">     190</span>   [<span class="tlaGBC" title="Branch 0 was taken 8 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 104 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 8 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         216 :         return max_tx_weight_exceeded ? ErrorMaxWeightExceeded() : util::Error();</span></span>
<span id="L191"><span class="lineNum">     191</span>                 :             :     }</span>
<span id="L192"><span class="lineNum">     192</span>                 :             : </span>
<span id="L193"><span class="lineNum">     193</span>                 :             :     // Set output set</span>
<span id="L194"><span class="lineNum">     194</span>         [<span class="tlaGBC" title="Branch 0 was taken 22256 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 114 times"> + </span>]:<span class="tlaGNC">       22370 :     for (const size_t&amp; i : best_selection) {</span></span>
<span id="L195"><span class="lineNum">     195</span>   [<span class="tlaGBC" title="Branch 0 was taken 22256 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 22256 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">       22256 :         result.AddInput(utxo_pool.at(i));</span></span>
<span id="L196"><span class="lineNum">     196</span>                 :             :     }</span>
<span id="L197"><span class="lineNum">     197</span>         [<span class="tlaGBC" title="Branch 0 was taken 114 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         114 :     result.RecalculateWaste(cost_of_change, cost_of_change, CAmount{0});</span></span>
<span id="L198"><span class="lineNum">     198</span>   [<span class="tlaGBC" title="Branch 0 was taken 114 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 114 times"> + </span>]:<span class="tlaGNC">         114 :     assert(best_waste == result.GetWaste());</span></span>
<span id="L199"><span class="lineNum">     199</span>                 :             : </span>
<span id="L200"><span class="lineNum">     200</span>                 :<span class="tlaGNC">         114 :     return result;</span></span>
<span id="L201"><span class="lineNum">     201</span>                 :<span class="tlaGNC">         455 : }</span></span>
<span id="L202"><span class="lineNum">     202</span>                 :             : </span>
<span id="L203"><span class="lineNum">     203</span>                 :             : /*</span>
<span id="L204"><span class="lineNum">     204</span>                 :             :  * TL;DR: Coin Grinder is a DFS-based algorithm that deterministically searches for the minimum-weight input set to fund</span>
<span id="L205"><span class="lineNum">     205</span>                 :             :  * the transaction. The algorithm is similar to the Branch and Bound algorithm, but will produce a transaction _with_ a</span>
<span id="L206"><span class="lineNum">     206</span>                 :             :  * change output instead of a changeless transaction.</span>
<span id="L207"><span class="lineNum">     207</span>                 :             :  *</span>
<span id="L208"><span class="lineNum">     208</span>                 :             :  * Full description: CoinGrinder can be thought of as a graph walking algorithm. It explores a binary tree</span>
<span id="L209"><span class="lineNum">     209</span>                 :             :  * representation of the powerset of the UTXO pool. Each node in the tree represents a candidate input set. The tree’s</span>
<span id="L210"><span class="lineNum">     210</span>                 :             :  * root is the empty set. Each node in the tree has two children which are formed by either adding or skipping the next</span>
<span id="L211"><span class="lineNum">     211</span>                 :             :  * UTXO (&quot;inclusion/omission branch&quot;). Each level in the tree after the root corresponds to a decision about one UTXO in</span>
<span id="L212"><span class="lineNum">     212</span>                 :             :  * the UTXO pool.</span>
<span id="L213"><span class="lineNum">     213</span>                 :             :  *</span>
<span id="L214"><span class="lineNum">     214</span>                 :             :  * Example:</span>
<span id="L215"><span class="lineNum">     215</span>                 :             :  * We represent UTXOs as _alias=[effective_value/weight]_ and indicate omitted UTXOs with an underscore. Given a UTXO</span>
<span id="L216"><span class="lineNum">     216</span>                 :             :  * pool {A=[10/2], B=[7/1], C=[5/1], D=[4/2]} sorted by descending effective value, our search tree looks as follows:</span>
<span id="L217"><span class="lineNum">     217</span>                 :             :  *</span>
<span id="L218"><span class="lineNum">     218</span>                 :             :  *                                       _______________________ {} ________________________</span>
<span id="L219"><span class="lineNum">     219</span>                 :             :  *                                      /                                                   \</span>
<span id="L220"><span class="lineNum">     220</span>                 :             :  * A=[10/2]               __________ {A} _________                                __________ {_} _________</span>
<span id="L221"><span class="lineNum">     221</span>                 :             :  *                       /                        \                              /                        \</span>
<span id="L222"><span class="lineNum">     222</span>                 :             :  * B=[7/1]            {AB} _                      {A_} _                      {_B} _                      {__} _</span>
<span id="L223"><span class="lineNum">     223</span>                 :             :  *                  /       \                   /       \                   /       \                   /       \</span>
<span id="L224"><span class="lineNum">     224</span>                 :             :  * C=[5/1]     {ABC}         {AB_}         {A_C}         {A__}         {_BC}         {_B_}         {__C}         {___}</span>
<span id="L225"><span class="lineNum">     225</span>                 :             :  *              / \           / \           / \           / \           / \           / \           / \           / \</span>
<span id="L226"><span class="lineNum">     226</span>                 :             :  * D=[4/2] {ABCD} {ABC_} {AB_D} {AB__} {A_CD} {A_C_} {A__D} {A___} {_BCD} {_BC_} {_B_D} {_B__} {__CD} {__C_} {___D} {____}</span>
<span id="L227"><span class="lineNum">     227</span>                 :             :  *</span>
<span id="L228"><span class="lineNum">     228</span>                 :             :  *</span>
<span id="L229"><span class="lineNum">     229</span>                 :             :  * CoinGrinder uses a depth-first search to walk this tree. It first tries inclusion branches, then omission branches. A</span>
<span id="L230"><span class="lineNum">     230</span>                 :             :  * naive exploration of a tree with four UTXOs requires visiting all 31 nodes:</span>
<span id="L231"><span class="lineNum">     231</span>                 :             :  *</span>
<span id="L232"><span class="lineNum">     232</span>                 :             :  *     {} {A} {AB} {ABC} {ABCD} {ABC_} {AB_} {AB_D} {AB__} {A_} {A_C} {A_CD} {A_C_} {A__} {A__D} {A___} {_} {_B} {_BC}</span>
<span id="L233"><span class="lineNum">     233</span>                 :             :  *     {_BCD} {_BC_} {_B_} {_B_D} {_B__} {__} {__C} {__CD} {__C} {___} {___D} {____}</span>
<span id="L234"><span class="lineNum">     234</span>                 :             :  *</span>
<span id="L235"><span class="lineNum">     235</span>                 :             :  * As powersets grow exponentially with the set size, walking the entire tree would quickly get computationally</span>
<span id="L236"><span class="lineNum">     236</span>                 :             :  * infeasible with growing UTXO pools. Thanks to traversing the tree in a deterministic order, we can keep track of the</span>
<span id="L237"><span class="lineNum">     237</span>                 :             :  * progress of the search solely on basis of the current selection (and the best selection so far). We visit as few</span>
<span id="L238"><span class="lineNum">     238</span>                 :             :  * nodes as possible by recognizing and skipping any branches that can only contain solutions worse than the best</span>
<span id="L239"><span class="lineNum">     239</span>                 :             :  * solution so far. This makes CoinGrinder a branch-and-bound algorithm</span>
<span id="L240"><span class="lineNum">     240</span>                 :             :  * (https://en.wikipedia.org/wiki/Branch_and_bound).</span>
<span id="L241"><span class="lineNum">     241</span>                 :             :  * CoinGrinder is searching for the input set with lowest weight that can fund a transaction, so for example we can only</span>
<span id="L242"><span class="lineNum">     242</span>                 :             :  * ever find a _better_ candidate input set in a node that adds a UTXO, but never in a node that skips a UTXO. After</span>
<span id="L243"><span class="lineNum">     243</span>                 :             :  * visiting {A} and exploring the inclusion branch {AB} and its descendants, the candidate input set in the omission</span>
<span id="L244"><span class="lineNum">     244</span>                 :             :  * branch {A_} is equivalent to the parent {A} in effective value and weight. While CoinGrinder does need to visit the</span>
<span id="L245"><span class="lineNum">     245</span>                 :             :  * descendants of the omission branch {A_}, it is unnecessary to evaluate the candidate input set in the omission branch</span>
<span id="L246"><span class="lineNum">     246</span>                 :             :  * itself. By skipping evaluation of all nodes on an omission branch we reduce the visited nodes to 15:</span>
<span id="L247"><span class="lineNum">     247</span>                 :             :  *</span>
<span id="L248"><span class="lineNum">     248</span>                 :             :  *     {A} {AB} {ABC} {ABCD} {AB_D} {A_C} {A_CD} {A__D} {_B} {_BC} {_BCD} {_B_D} {__C} {__CD} {___D}</span>
<span id="L249"><span class="lineNum">     249</span>                 :             :  *</span>
<span id="L250"><span class="lineNum">     250</span>                 :             :  *                                       _______________________ {} ________________________</span>
<span id="L251"><span class="lineNum">     251</span>                 :             :  *                                      /                                                   \</span>
<span id="L252"><span class="lineNum">     252</span>                 :             :  * A=[10/2]               __________ {A} _________                                ___________\____________</span>
<span id="L253"><span class="lineNum">     253</span>                 :             :  *                       /                        \                              /                        \</span>
<span id="L254"><span class="lineNum">     254</span>                 :             :  * B=[7/1]            {AB} __                    __\_____                     {_B} __                    __\_____</span>
<span id="L255"><span class="lineNum">     255</span>                 :             :  *                  /        \                  /        \                  /        \                  /        \</span>
<span id="L256"><span class="lineNum">     256</span>                 :             :  * C=[5/1]     {ABC}          \            {A_C}          \            {_BC}          \            {__C}          \</span>
<span id="L257"><span class="lineNum">     257</span>                 :             :  *              /             /             /             /             /             /             /             /</span>
<span id="L258"><span class="lineNum">     258</span>                 :             :  * D=[4/2] {ABCD}        {AB_D}        {A_CD}        {A__D}        {_BCD}        {_B_D}        {__CD}        {___D}</span>
<span id="L259"><span class="lineNum">     259</span>                 :             :  *</span>
<span id="L260"><span class="lineNum">     260</span>                 :             :  *</span>
<span id="L261"><span class="lineNum">     261</span>                 :             :  * We refer to the move from the inclusion branch {AB} via the omission branch {A_} to its inclusion-branch child {A_C}</span>
<span id="L262"><span class="lineNum">     262</span>                 :             :  * as _shifting to the omission branch_ or just _SHIFT_. (The index of the ultimate element in the candidate input set</span>
<span id="L263"><span class="lineNum">     263</span>                 :             :  * shifts right by one: {AB} ⇒ {A_C}.)</span>
<span id="L264"><span class="lineNum">     264</span>                 :             :  * When we reach a leaf node in the last level of the tree, shifting to the omission branch is not possible. Instead we</span>
<span id="L265"><span class="lineNum">     265</span>                 :             :  * go to the omission branch of the node’s last ancestor on an inclusion branch: from {ABCD}, we go to {AB_D}. From</span>
<span id="L266"><span class="lineNum">     266</span>                 :             :  * {AB_D}, we go to {A_C}. We refer to this operation as a _CUT_. (The ultimate element in</span>
<span id="L267"><span class="lineNum">     267</span>                 :             :  * the input set is deselected, and the penultimate element is shifted right by one: {AB_D} ⇒ {A_C}.)</span>
<span id="L268"><span class="lineNum">     268</span>                 :             :  * If a candidate input set in a node has not selected sufficient funds to build the transaction, we continue directly</span>
<span id="L269"><span class="lineNum">     269</span>                 :             :  * along the next inclusion branch. We call this operation _EXPLORE_. (We go from one inclusion branch to the next</span>
<span id="L270"><span class="lineNum">     270</span>                 :             :  * inclusion branch: {_B} ⇒ {_BC}.)</span>
<span id="L271"><span class="lineNum">     271</span>                 :             :  * Further, any prefix that already has selected sufficient effective value to fund the transaction cannot be improved</span>
<span id="L272"><span class="lineNum">     272</span>                 :             :  * by adding more UTXOs. If for example the candidate input set in {AB} is a valid solution, all potential descendant</span>
<span id="L273"><span class="lineNum">     273</span>                 :             :  * solutions {ABC}, {ABCD}, and {AB_D} must have a higher weight, thus instead of exploring the descendants of {AB}, we</span>
<span id="L274"><span class="lineNum">     274</span>                 :             :  * can SHIFT from {AB} to {A_C}.</span>
<span id="L275"><span class="lineNum">     275</span>                 :             :  *</span>
<span id="L276"><span class="lineNum">     276</span>                 :             :  * Given the above UTXO set, using a target of 11, and following these initial observations, the basic implementation of</span>
<span id="L277"><span class="lineNum">     277</span>                 :             :  * CoinGrinder visits the following 10 nodes:</span>
<span id="L278"><span class="lineNum">     278</span>                 :             :  *</span>
<span id="L279"><span class="lineNum">     279</span>                 :             :  *     Node   [eff_val/weight]  Evaluation</span>
<span id="L280"><span class="lineNum">     280</span>                 :             :  *     ---------------------------------------------------------------</span>
<span id="L281"><span class="lineNum">     281</span>                 :             :  *     {A}    [10/2]            Insufficient funds: EXPLORE</span>
<span id="L282"><span class="lineNum">     282</span>                 :             :  *     {AB}   [17/3]            Solution: SHIFT to omission branch</span>
<span id="L283"><span class="lineNum">     283</span>                 :             :  *     {A_C}  [15/3]            Better solution: SHIFT to omission branch</span>
<span id="L284"><span class="lineNum">     284</span>                 :             :  *     {A__D} [14/4]            Worse solution, shift impossible due to leaf node: CUT to omission branch of {A__D},</span>
<span id="L285"><span class="lineNum">     285</span>                 :             :  *                              i.e. SHIFT to omission branch of {A}</span>
<span id="L286"><span class="lineNum">     286</span>                 :             :  *     {_B}   [7/1]             Insufficient funds: EXPLORE</span>
<span id="L287"><span class="lineNum">     287</span>                 :             :  *     {_BC}  [12/2]            Better solution: SHIFT to omission branch</span>
<span id="L288"><span class="lineNum">     288</span>                 :             :  *     {_B_D} [11/3]            Worse solution, shift impossible due to leaf node: CUT to omission branch of {_B_D},</span>
<span id="L289"><span class="lineNum">     289</span>                 :             :  *                              i.e. SHIFT to omission branch of {_B}</span>
<span id="L290"><span class="lineNum">     290</span>                 :             :  *     {__C}  [5/1]             Insufficient funds: EXPLORE</span>
<span id="L291"><span class="lineNum">     291</span>                 :             :  *     {__CD} [9/3]             Insufficient funds, leaf node: CUT</span>
<span id="L292"><span class="lineNum">     292</span>                 :             :  *     {___D} [4/2]             Insufficient funds, leaf node, cannot CUT since only one UTXO selected: done.</span>
<span id="L293"><span class="lineNum">     293</span>                 :             :  *</span>
<span id="L294"><span class="lineNum">     294</span>                 :             :  *                                       _______________________ {} ________________________</span>
<span id="L295"><span class="lineNum">     295</span>                 :             :  *                                      /                                                   \</span>
<span id="L296"><span class="lineNum">     296</span>                 :             :  * A=[10/2]               __________ {A} _________                                ___________\____________</span>
<span id="L297"><span class="lineNum">     297</span>                 :             :  *                       /                        \                              /                        \</span>
<span id="L298"><span class="lineNum">     298</span>                 :             :  * B=[7/1]            {AB}                       __\_____                     {_B} __                    __\_____</span>
<span id="L299"><span class="lineNum">     299</span>                 :             :  *                                              /        \                  /        \                  /        \</span>
<span id="L300"><span class="lineNum">     300</span>                 :             :  * C=[5/1]                                 {A_C}          \            {_BC}          \            {__C}          \</span>
<span id="L301"><span class="lineNum">     301</span>                 :             :  *                                                        /                           /             /             /</span>
<span id="L302"><span class="lineNum">     302</span>                 :             :  * D=[4/2]                                           {A__D}                      {_B_D}        {__CD}        {___D}</span>
<span id="L303"><span class="lineNum">     303</span>                 :             :  *</span>
<span id="L304"><span class="lineNum">     304</span>                 :             :  *</span>
<span id="L305"><span class="lineNum">     305</span>                 :             :  * We implement this tree walk in the following algorithm:</span>
<span id="L306"><span class="lineNum">     306</span>                 :             :  * 1. Add `next_utxo`</span>
<span id="L307"><span class="lineNum">     307</span>                 :             :  * 2. Evaluate candidate input set</span>
<span id="L308"><span class="lineNum">     308</span>                 :             :  * 3. Determine `next_utxo` by deciding whether to</span>
<span id="L309"><span class="lineNum">     309</span>                 :             :  *    a) EXPLORE: Add next inclusion branch, e.g. {_B} ⇒ {_B} + `next_uxto`: C</span>
<span id="L310"><span class="lineNum">     310</span>                 :             :  *    b) SHIFT: Replace last selected UTXO by next higher index, e.g. {A_C} ⇒ {A__} + `next_utxo`: D</span>
<span id="L311"><span class="lineNum">     311</span>                 :             :  *    c) CUT: deselect last selected UTXO and shift to omission branch of penultimate UTXO, e.g. {AB_D} ⇒ {A_} + `next_utxo: C</span>
<span id="L312"><span class="lineNum">     312</span>                 :             :  *</span>
<span id="L313"><span class="lineNum">     313</span>                 :             :  * The implementation then adds further optimizations by discovering further situations in which either the inclusion</span>
<span id="L314"><span class="lineNum">     314</span>                 :             :  * branch can be skipped, or both the inclusion and omission branch can be skipped after evaluating the candidate input</span>
<span id="L315"><span class="lineNum">     315</span>                 :             :  * set in the node.</span>
<span id="L316"><span class="lineNum">     316</span>                 :             :  *</span>
<span id="L317"><span class="lineNum">     317</span>                 :             :  * @param std::vector&lt;OutputGroup&gt;&amp; utxo_pool The UTXOs that we are choosing from. These UTXOs will be sorted in</span>
<span id="L318"><span class="lineNum">     318</span>                 :             :  *        descending order by effective value, with lower weight preferred as a tie-breaker. (We can think of an output</span>
<span id="L319"><span class="lineNum">     319</span>                 :             :  *        group with multiple as a heavier UTXO with the combined amount here.)</span>
<span id="L320"><span class="lineNum">     320</span>                 :             :  * @param const CAmount&amp; selection_target This is the minimum amount that we need for the transaction without considering change.</span>
<span id="L321"><span class="lineNum">     321</span>                 :             :  * @param const CAmount&amp; change_target The minimum budget for creating a change output, by which we increase the selection_target.</span>
<span id="L322"><span class="lineNum">     322</span>                 :             :  * @param int max_selection_weight The maximum allowed weight for a selection result to be valid.</span>
<span id="L323"><span class="lineNum">     323</span>                 :             :  * @returns The result of this coin selection algorithm, or std::nullopt</span>
<span id="L324"><span class="lineNum">     324</span>                 :             :  */</span>
<span id="L325"><span class="lineNum">     325</span>                 :<span class="tlaGNC">           7 : util::Result&lt;SelectionResult&gt; CoinGrinder(std::vector&lt;OutputGroup&gt;&amp; utxo_pool, const CAmount&amp; selection_target, CAmount change_target, int max_selection_weight)</span></span>
<span id="L326"><span class="lineNum">     326</span>                 :             : {</span>
<span id="L327"><span class="lineNum">     327</span>                 :<span class="tlaGNC">           7 :     std::sort(utxo_pool.begin(), utxo_pool.end(), descending_effval_weight);</span></span>
<span id="L328"><span class="lineNum">     328</span>                 :             :     // The sum of UTXO amounts after this UTXO index, e.g. lookahead[5] = Σ(UTXO[6+].amount)</span>
<span id="L329"><span class="lineNum">     329</span>                 :<span class="tlaGNC">           7 :     std::vector&lt;CAmount&gt; lookahead(utxo_pool.size());</span></span>
<span id="L330"><span class="lineNum">     330</span>                 :             :     // The minimum UTXO weight among the remaining UTXOs after this UTXO index, e.g. min_tail_weight[5] = min(UTXO[6+].weight)</span>
<span id="L331"><span class="lineNum">     331</span>         [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           7 :     std::vector&lt;int&gt; min_tail_weight(utxo_pool.size());</span></span>
<span id="L332"><span class="lineNum">     332</span>                 :             : </span>
<span id="L333"><span class="lineNum">     333</span>                 :             :     // Calculate lookahead values, min_tail_weights, and check that there are sufficient funds</span>
<span id="L334"><span class="lineNum">     334</span>                 :<span class="tlaGNC">           7 :     CAmount total_available = 0;</span></span>
<span id="L335"><span class="lineNum">     335</span>                 :<span class="tlaGNC">           7 :     int min_group_weight = std::numeric_limits&lt;int&gt;::max();</span></span>
<span id="L336"><span class="lineNum">     336</span>         [<span class="tlaGBC" title="Branch 0 was taken 635 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 7 times"> + </span>]:<span class="tlaGNC">         642 :     for (size_t i = 0; i &lt; utxo_pool.size(); ++i) {</span></span>
<span id="L337"><span class="lineNum">     337</span>                 :<span class="tlaGNC">         635 :         size_t index = utxo_pool.size() - 1 - i; // Loop over every element in reverse order</span></span>
<span id="L338"><span class="lineNum">     338</span>         [<span class="tlaGBC" title="Branch 0 was taken 635 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         635 :         lookahead[index] = total_available;</span></span>
<span id="L339"><span class="lineNum">     339</span>                 :<span class="tlaGNC">         635 :         min_tail_weight[index] = min_group_weight;</span></span>
<span id="L340"><span class="lineNum">     340</span>                 :             :         // UTXOs with non-positive effective value must have been filtered</span>
<span id="L341"><span class="lineNum">     341</span>   [<span class="tlaGBC" title="Branch 0 was taken 635 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 635 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         635 :         Assume(utxo_pool[index].GetSelectionAmount() &gt; 0);</span></span>
<span id="L342"><span class="lineNum">     342</span>         [<span class="tlaGBC" title="Branch 0 was taken 635 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         635 :         total_available += utxo_pool[index].GetSelectionAmount();</span></span>
<span id="L343"><span class="lineNum">     343</span>         [<span class="tlaGBC" title="Branch 0 was taken 628 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 7 times"> + </span>]:<span class="tlaGNC">        1263 :         min_group_weight = std::min(min_group_weight, utxo_pool[index].m_weight);</span></span>
<span id="L344"><span class="lineNum">     344</span>                 :             :     }</span>
<span id="L345"><span class="lineNum">     345</span>                 :             : </span>
<span id="L346"><span class="lineNum">     346</span>                 :<span class="tlaGNC">           7 :     const CAmount total_target = selection_target + change_target;</span></span>
<span id="L347"><span class="lineNum">     347</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           7 :     if (total_available &lt; total_target) {</span></span>
<span id="L348"><span class="lineNum">     348</span>                 :             :         // Insufficient funds</span>
<span id="L349"><span class="lineNum">     349</span>                 :<span class="tlaGNC">           2 :         return util::Error();</span></span>
<span id="L350"><span class="lineNum">     350</span>                 :             :     }</span>
<span id="L351"><span class="lineNum">     351</span>                 :             : </span>
<span id="L352"><span class="lineNum">     352</span>                 :             :     // The current selection and the best input set found so far, stored as the utxo_pool indices of the UTXOs forming them</span>
<span id="L353"><span class="lineNum">     353</span>                 :<span class="tlaGNC">           6 :     std::vector&lt;size_t&gt; curr_selection;</span></span>
<span id="L354"><span class="lineNum">     354</span>                 :<span class="tlaGNC">           6 :     std::vector&lt;size_t&gt; best_selection;</span></span>
<span id="L355"><span class="lineNum">     355</span>                 :             : </span>
<span id="L356"><span class="lineNum">     356</span>                 :             :     // The currently selected effective amount, and the effective amount of the best selection so far</span>
<span id="L357"><span class="lineNum">     357</span>                 :<span class="tlaGNC">           6 :     CAmount curr_amount = 0;</span></span>
<span id="L358"><span class="lineNum">     358</span>                 :<span class="tlaGNC">           6 :     CAmount best_selection_amount = MAX_MONEY;</span></span>
<span id="L359"><span class="lineNum">     359</span>                 :             : </span>
<span id="L360"><span class="lineNum">     360</span>                 :             :     // The weight of the currently selected input set, and the weight of the best selection</span>
<span id="L361"><span class="lineNum">     361</span>                 :<span class="tlaGNC">           6 :     int curr_weight = 0;</span></span>
<span id="L362"><span class="lineNum">     362</span>                 :<span class="tlaGNC">           6 :     int best_selection_weight = max_selection_weight; // Tie is fine, because we prefer lower selection amount</span></span>
<span id="L363"><span class="lineNum">     363</span>                 :             : </span>
<span id="L364"><span class="lineNum">     364</span>                 :             :     // Whether the input sets generated during this search have exceeded the maximum transaction weight at any point</span>
<span id="L365"><span class="lineNum">     365</span>                 :<span class="tlaGNC">           6 :     bool max_tx_weight_exceeded = false;</span></span>
<span id="L366"><span class="lineNum">     366</span>                 :             : </span>
<span id="L367"><span class="lineNum">     367</span>                 :             :     // Index of the next UTXO to consider in utxo_pool</span>
<span id="L368"><span class="lineNum">     368</span>                 :<span class="tlaGNC">           6 :     size_t next_utxo = 0;</span></span>
<span id="L369"><span class="lineNum">     369</span>                 :             : </span>
<span id="L370"><span class="lineNum">     370</span>                 :             :     /*</span>
<span id="L371"><span class="lineNum">     371</span>                 :             :      * You can think of the current selection as a vector of booleans that has decided inclusion or exclusion of all</span>
<span id="L372"><span class="lineNum">     372</span>                 :             :      * UTXOs before `next_utxo`. When we consider the next UTXO, we extend this hypothetical boolean vector either with</span>
<span id="L373"><span class="lineNum">     373</span>                 :             :      * a true value if the UTXO is included or a false value if it is omitted. The equivalent state is stored more</span>
<span id="L374"><span class="lineNum">     374</span>                 :             :      * compactly as the list of indices of the included UTXOs and the `next_utxo` index.</span>
<span id="L375"><span class="lineNum">     375</span>                 :             :      *</span>
<span id="L376"><span class="lineNum">     376</span>                 :             :      * We can never find a new solution by deselecting a UTXO, because we then revisit a previously evaluated</span>
<span id="L377"><span class="lineNum">     377</span>                 :             :      * selection. Therefore, we only need to check whether we found a new solution _after adding_ a new UTXO.</span>
<span id="L378"><span class="lineNum">     378</span>                 :             :      *</span>
<span id="L379"><span class="lineNum">     379</span>                 :             :      * Each iteration of CoinGrinder starts by selecting the `next_utxo` and evaluating the current selection. We</span>
<span id="L380"><span class="lineNum">     380</span>                 :             :      * use three state transitions to progress from the current selection to the next promising selection:</span>
<span id="L381"><span class="lineNum">     381</span>                 :             :      *</span>
<span id="L382"><span class="lineNum">     382</span>                 :             :      * - EXPLORE inclusion branch: We do not have sufficient funds, yet. Add `next_utxo` to the current selection, then</span>
<span id="L383"><span class="lineNum">     383</span>                 :             :      *                             nominate the direct successor of the just selected UTXO as our `next_utxo` for the</span>
<span id="L384"><span class="lineNum">     384</span>                 :             :      *                             following iteration.</span>
<span id="L385"><span class="lineNum">     385</span>                 :             :      *</span>
<span id="L386"><span class="lineNum">     386</span>                 :             :      *                             Example:</span>
<span id="L387"><span class="lineNum">     387</span>                 :             :      *                                 Current Selection: {0, 5, 7}</span>
<span id="L388"><span class="lineNum">     388</span>                 :             :      *                                 Evaluation: EXPLORE, next_utxo: 8</span>
<span id="L389"><span class="lineNum">     389</span>                 :             :      *                                 Next Selection: {0, 5, 7, 8}</span>
<span id="L390"><span class="lineNum">     390</span>                 :             :      *</span>
<span id="L391"><span class="lineNum">     391</span>                 :             :      * - SHIFT to omission branch: Adding more UTXOs to the current selection cannot produce a solution that is better</span>
<span id="L392"><span class="lineNum">     392</span>                 :             :      *                             than the current best, e.g. the current selection weight exceeds the max weight or</span>
<span id="L393"><span class="lineNum">     393</span>                 :             :      *                             the current selection amount is equal to or greater than the target.</span>
<span id="L394"><span class="lineNum">     394</span>                 :             :      *                             We designate our `next_utxo` the one after the tail of our current selection, then</span>
<span id="L395"><span class="lineNum">     395</span>                 :             :      *                             deselect the tail of our current selection.</span>
<span id="L396"><span class="lineNum">     396</span>                 :             :      *</span>
<span id="L397"><span class="lineNum">     397</span>                 :             :      *                             Example:</span>
<span id="L398"><span class="lineNum">     398</span>                 :             :      *                                 Current Selection: {0, 5, 7}</span>
<span id="L399"><span class="lineNum">     399</span>                 :             :      *                                 Evaluation: SHIFT, next_utxo: 8, omit last selected: {0, 5}</span>
<span id="L400"><span class="lineNum">     400</span>                 :             :      *                                 Next Selection: {0, 5, 8}</span>
<span id="L401"><span class="lineNum">     401</span>                 :             :      *</span>
<span id="L402"><span class="lineNum">     402</span>                 :             :      * - CUT entire subtree:       We have exhausted the inclusion branch for the penultimately selected UTXO, both the</span>
<span id="L403"><span class="lineNum">     403</span>                 :             :      *                             inclusion and the omission branch of the current prefix are barren. E.g. we have</span>
<span id="L404"><span class="lineNum">     404</span>                 :             :      *                             reached the end of the UTXO pool, so neither further EXPLORING nor SHIFTING can find</span>
<span id="L405"><span class="lineNum">     405</span>                 :             :      *                             any solutions. We designate our `next_utxo` the one after our penultimate selected,</span>
<span id="L406"><span class="lineNum">     406</span>                 :             :      *                             then deselect both the last and penultimate selected.</span>
<span id="L407"><span class="lineNum">     407</span>                 :             :      *</span>
<span id="L408"><span class="lineNum">     408</span>                 :             :      *                             Example:</span>
<span id="L409"><span class="lineNum">     409</span>                 :             :      *                                 Current Selection: {0, 5, 7}</span>
<span id="L410"><span class="lineNum">     410</span>                 :             :      *                                 Evaluation: CUT, next_utxo: 6, omit two last selected: {0}</span>
<span id="L411"><span class="lineNum">     411</span>                 :             :      *                                 Next Selection: {0, 6}</span>
<span id="L412"><span class="lineNum">     412</span>                 :             :      */</span>
<span id="L413"><span class="lineNum">     413</span>                 :<span class="tlaGNC">         205 :     auto deselect_last = [&amp;]() {</span></span>
<span id="L414"><span class="lineNum">     414</span>                 :<span class="tlaGNC">         199 :         OutputGroup&amp; utxo = utxo_pool[curr_selection.back()];</span></span>
<span id="L415"><span class="lineNum">     415</span>                 :<span class="tlaGNC">         199 :         curr_amount -= utxo.GetSelectionAmount();</span></span>
<span id="L416"><span class="lineNum">     416</span>                 :<span class="tlaGNC">         199 :         curr_weight -= utxo.m_weight;</span></span>
<span id="L417"><span class="lineNum">     417</span>                 :<span class="tlaGNC">         199 :         curr_selection.pop_back();</span></span>
<span id="L418"><span class="lineNum">     418</span>                 :<span class="tlaGNC">         205 :     };</span></span>
<span id="L419"><span class="lineNum">     419</span>                 :             : </span>
<span id="L420"><span class="lineNum">     420</span>                 :<span class="tlaGNC">           6 :     SelectionResult result(selection_target, SelectionAlgorithm::CG);</span></span>
<span id="L421"><span class="lineNum">     421</span>                 :<span class="tlaGNC">           6 :     bool is_done = false;</span></span>
<span id="L422"><span class="lineNum">     422</span>                 :<span class="tlaGNC">           6 :     size_t curr_try = 0;</span></span>
<span id="L423"><span class="lineNum">     423</span>                 :<span class="tlaGNC">           6 :     while (!is_done) {</span></span>
<span id="L424"><span class="lineNum">     424</span>                 :<span class="tlaGNC">         199 :         bool should_shift{false}, should_cut{false};</span></span>
<span id="L425"><span class="lineNum">     425</span>                 :             :         // Select `next_utxo`</span>
<span id="L426"><span class="lineNum">     426</span>         [<span class="tlaGBC" title="Branch 0 was taken 199 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         199 :         OutputGroup&amp; utxo = utxo_pool[next_utxo];</span></span>
<span id="L427"><span class="lineNum">     427</span>         [<span class="tlaGBC" title="Branch 0 was taken 199 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         199 :         curr_amount += utxo.GetSelectionAmount();</span></span>
<span id="L428"><span class="lineNum">     428</span>                 :<span class="tlaGNC">         199 :         curr_weight += utxo.m_weight;</span></span>
<span id="L429"><span class="lineNum">     429</span>         [<span class="tlaGBC" title="Branch 0 was taken 199 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         199 :         curr_selection.push_back(next_utxo);</span></span>
<span id="L430"><span class="lineNum">     430</span>                 :<span class="tlaGNC">         199 :         ++next_utxo;</span></span>
<span id="L431"><span class="lineNum">     431</span>                 :<span class="tlaGNC">         199 :         ++curr_try;</span></span>
<span id="L432"><span class="lineNum">     432</span>                 :             : </span>
<span id="L433"><span class="lineNum">     433</span>                 :             :         // EVALUATE current selection: check for solutions and see whether we can CUT or SHIFT before EXPLORING further</span>
<span id="L434"><span class="lineNum">     434</span>                 :<span class="tlaGNC">         199 :         auto curr_tail = curr_selection.back();</span></span>
<span id="L435"><span class="lineNum">     435</span>         [<span class="tlaGBC" title="Branch 0 was taken 176 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 23 times"> + </span>]:<span class="tlaGNC">         199 :         if (curr_amount + lookahead[curr_tail] &lt; total_target) {</span></span>
<span id="L436"><span class="lineNum">     436</span>                 :             :             // Insufficient funds with lookahead: CUT</span>
<span id="L437"><span class="lineNum">     437</span>                 :             :             should_cut = true;</span>
<span id="L438"><span class="lineNum">     438</span>         [<span class="tlaGBC" title="Branch 0 was taken 48 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 128 times"> + </span>]:<span class="tlaGNC">         176 :         } else if (curr_weight &gt; best_selection_weight) {</span></span>
<span id="L439"><span class="lineNum">     439</span>                 :             :             // best_selection_weight is initialized to max_selection_weight</span>
<span id="L440"><span class="lineNum">     440</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 47 times"> + </span>]:<span class="tlaGNC">          48 :             if (curr_weight &gt; max_selection_weight) max_tx_weight_exceeded = true;</span></span>
<span id="L441"><span class="lineNum">     441</span>                 :             :             // Worse weight than best solution. More UTXOs only increase weight:</span>
<span id="L442"><span class="lineNum">     442</span>                 :             :             // CUT if last selected group had minimal weight, else SHIFT</span>
<span id="L443"><span class="lineNum">     443</span>         [<span class="tlaGBC" title="Branch 0 was taken 47 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">          48 :             if (utxo_pool[curr_tail].m_weight &lt;= min_tail_weight[curr_tail]) {</span></span>
<span id="L444"><span class="lineNum">     444</span>                 :             :                 should_cut = true;</span>
<span id="L445"><span class="lineNum">     445</span>                 :             :             } else {</span>
<span id="L446"><span class="lineNum">     446</span>                 :<span class="tlaGNC">          47 :                 should_shift  = true;</span></span>
<span id="L447"><span class="lineNum">     447</span>                 :             :             }</span>
<span id="L448"><span class="lineNum">     448</span>         [<span class="tlaGBC" title="Branch 0 was taken 37 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 91 times"> + </span>]:<span class="tlaGNC">         128 :         } else if (curr_amount &gt;= total_target) {</span></span>
<span id="L449"><span class="lineNum">     449</span>                 :             :             // Success, adding more weight cannot be better: SHIFT</span>
<span id="L450"><span class="lineNum">     450</span>                 :<span class="tlaGNC">          37 :             should_shift  = true;</span></span>
<span id="L451"><span class="lineNum">     451</span>   [<span class="tlaGBC" title="Branch 0 was taken 20 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 17 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 20 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          37 :             if (curr_weight &lt; best_selection_weight || (curr_weight == best_selection_weight &amp;&amp; curr_amount &lt; best_selection_amount)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 12 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 8 times"> + </span>]
<span id="L452"><span class="lineNum">     452</span>                 :             :                 // New lowest weight, or same weight with fewer funds tied up</span>
<span id="L453"><span class="lineNum">     453</span>         [<span class="tlaGBC" title="Branch 0 was taken 29 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          29 :                 best_selection = curr_selection;</span></span>
<span id="L454"><span class="lineNum">     454</span>                 :<span class="tlaGNC">          29 :                 best_selection_weight = curr_weight;</span></span>
<span id="L455"><span class="lineNum">     455</span>                 :<span class="tlaGNC">          29 :                 best_selection_amount = curr_amount;</span></span>
<span id="L456"><span class="lineNum">     456</span>                 :             :             }</span>
<span id="L457"><span class="lineNum">     457</span>   [<span class="tlaGBC" title="Branch 0 was taken 50 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 41 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 50 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          91 :         } else if (!best_selection.empty() &amp;&amp; curr_weight + int64_t{min_tail_weight[curr_tail]} * ((total_target - curr_amount + utxo_pool[curr_tail].GetSelectionAmount() - 1) / utxo_pool[curr_tail].GetSelectionAmount()) &gt; best_selection_weight) {</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 50 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 30 times"> + </span><span class="tlaGBC" title="Branch 7 was taken 20 times"> + </span>]
<span id="L458"><span class="lineNum">     458</span>                 :             :             // Compare minimal tail weight and last selected amount with the amount missing to gauge whether a better weight is still possible.</span>
<span id="L459"><span class="lineNum">     459</span>         [<span class="tlaGBC" title="Branch 0 was taken 9 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 21 times"> + </span>]:<span class="tlaGNC">          30 :             if (utxo_pool[curr_tail].m_weight &lt;= min_tail_weight[curr_tail]) {</span></span>
<span id="L460"><span class="lineNum">     460</span>                 :             :                 should_cut = true;</span>
<span id="L461"><span class="lineNum">     461</span>                 :             :             } else {</span>
<span id="L462"><span class="lineNum">     462</span>                 :<span class="tlaGNC">           9 :                 should_shift = true;</span></span>
<span id="L463"><span class="lineNum">     463</span>                 :             :             }</span>
<span id="L464"><span class="lineNum">     464</span>                 :             :         }</span>
<span id="L465"><span class="lineNum">     465</span>                 :             : </span>
<span id="L466"><span class="lineNum">     466</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 199 times"> + </span>]:<span class="tlaGNC">         199 :         if (curr_try &gt;= TOTAL_TRIES) {</span></span>
<span id="L467"><span class="lineNum">     467</span>                 :             :             // Solution is not guaranteed to be optimal if `curr_try` hit TOTAL_TRIES</span>
<span id="L468"><span class="lineNum">     468</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :             result.SetAlgoCompleted(false);</span></span>
<span id="L469"><span class="lineNum">     469</span>                 :             :             break;</span>
<span id="L470"><span class="lineNum">     470</span>                 :             :         }</span>
<span id="L471"><span class="lineNum">     471</span>                 :             : </span>
<span id="L472"><span class="lineNum">     472</span>         [<span class="tlaGBC" title="Branch 0 was taken 191 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 8 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         199 :         if (next_utxo == utxo_pool.size()) {</span></span>
<span id="L473"><span class="lineNum">     473</span>                 :             :             // Last added UTXO was end of UTXO pool, nothing left to add on inclusion or omission branch: CUT</span>
<span id="L474"><span class="lineNum">     474</span>                 :             :             should_cut = true;</span>
<span id="L475"><span class="lineNum">     475</span>                 :             :         }</span>
<span id="L476"><span class="lineNum">     476</span>                 :             : </span>
<span id="L477"><span class="lineNum">     477</span>         [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 151 times"> + </span>]:<span class="tlaGNC">         191 :         if (should_cut) {</span></span>
<span id="L478"><span class="lineNum">     478</span>                 :             :             // Neither adding to the current selection nor exploring the omission branch of the last selected UTXO can</span>
<span id="L479"><span class="lineNum">     479</span>                 :             :             // find any solutions. Redirect to exploring the Omission branch of the penultimate selected UTXO (i.e.</span>
<span id="L480"><span class="lineNum">     480</span>                 :             :             // set `next_utxo` to one after the penultimate selected, then deselect the last two selected UTXOs)</span>
<span id="L481"><span class="lineNum">     481</span>                 :<span class="tlaGNC">          48 :             should_cut = false;</span></span>
<span id="L482"><span class="lineNum">     482</span>         [<span class="tlaGBC" title="Branch 0 was taken 48 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          48 :             deselect_last();</span></span>
<span id="L483"><span class="lineNum">     483</span>                 :             :             should_shift  = true;</span>
<span id="L484"><span class="lineNum">     484</span>                 :             :         }</span>
<span id="L485"><span class="lineNum">     485</span>                 :             : </span>
<span id="L486"><span class="lineNum">     486</span>         [<span class="tlaGBC" title="Branch 0 was taken 157 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 193 times"> + </span>]:<span class="tlaGNC">         350 :         while (should_shift) {</span></span>
<span id="L487"><span class="lineNum">     487</span>                 :             :             // Set `next_utxo` to one after last selected, then deselect last selected UTXO</span>
<span id="L488"><span class="lineNum">     488</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 151 times"> + </span>]:<span class="tlaGNC">         157 :             if (curr_selection.empty()) {</span></span>
<span id="L489"><span class="lineNum">     489</span>                 :             :                 // Exhausted search space before running into attempt limit</span>
<span id="L490"><span class="lineNum">     490</span>                 :<span class="tlaGNC">           6 :                 is_done = true;</span></span>
<span id="L491"><span class="lineNum">     491</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :                 result.SetAlgoCompleted(true);</span></span>
<span id="L492"><span class="lineNum">     492</span>                 :             :                 break;</span>
<span id="L493"><span class="lineNum">     493</span>                 :             :             }</span>
<span id="L494"><span class="lineNum">     494</span>                 :<span class="tlaGNC">         151 :             next_utxo = curr_selection.back() + 1;</span></span>
<span id="L495"><span class="lineNum">     495</span>         [<span class="tlaGBC" title="Branch 0 was taken 151 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         151 :             deselect_last();</span></span>
<span id="L496"><span class="lineNum">     496</span>                 :<span class="tlaGNC">        2483 :             should_shift  = false;</span></span>
<span id="L497"><span class="lineNum">     497</span>                 :             : </span>
<span id="L498"><span class="lineNum">     498</span>                 :             :             // After SHIFTing to an omission branch, the `next_utxo` might have the same effective value as the UTXO we</span>
<span id="L499"><span class="lineNum">     499</span>                 :             :             // just omitted. Since lower weight is our tiebreaker on UTXOs with equal effective value for sorting, if it</span>
<span id="L500"><span class="lineNum">     500</span>                 :             :             // ties on the effective value, it _must_ have the same weight (i.e. be a &quot;clone&quot; of the prior UTXO) or a</span>
<span id="L501"><span class="lineNum">     501</span>                 :             :             // higher weight. If so, selecting `next_utxo` would produce an equivalent or worse selection as one we</span>
<span id="L502"><span class="lineNum">     502</span>                 :             :             // previously evaluated. In that case, increment `next_utxo` until we find a UTXO with a differing amount.</span>
<span id="L503"><span class="lineNum">     503</span>   [<span class="tlaGBC" title="Branch 0 was taken 2483 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 2483 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">        2483 :             while (utxo_pool[next_utxo - 1].GetSelectionAmount() == utxo_pool[next_utxo].GetSelectionAmount()) {</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 2351 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 132 times"> + </span>]
<span id="L504"><span class="lineNum">     504</span>         [<span class="tlaGBC" title="Branch 0 was taken 2332 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 19 times"> + </span>]:<span class="tlaGNC">        2351 :                 if (next_utxo &gt;= utxo_pool.size() - 1) {</span></span>
<span id="L505"><span class="lineNum">     505</span>                 :             :                     // Reached end of UTXO pool skipping clones: SHIFT instead</span>
<span id="L506"><span class="lineNum">     506</span>                 :             :                     should_shift = true;</span>
<span id="L507"><span class="lineNum">     507</span>                 :             :                     break;</span>
<span id="L508"><span class="lineNum">     508</span>                 :             :                 }</span>
<span id="L509"><span class="lineNum">     509</span>                 :             :                 // Skip clone: previous UTXO is equivalent and unselected</span>
<span id="L510"><span class="lineNum">     510</span>                 :<span class="tlaGNC">        2332 :                 ++next_utxo;</span></span>
<span id="L511"><span class="lineNum">     511</span>                 :             :             }</span>
<span id="L512"><span class="lineNum">     512</span>                 :             :         }</span>
<span id="L513"><span class="lineNum">     513</span>                 :             :     }</span>
<span id="L514"><span class="lineNum">     514</span>                 :             : </span>
<span id="L515"><span class="lineNum">     515</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :     result.SetSelectionsEvaluated(curr_try);</span></span>
<span id="L516"><span class="lineNum">     516</span>                 :             : </span>
<span id="L517"><span class="lineNum">     517</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 5 times"> + </span>]:<span class="tlaGNC">           6 :     if (best_selection.empty()) {</span></span>
<span id="L518"><span class="lineNum">     518</span>   [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           1 :         return max_tx_weight_exceeded ? ErrorMaxWeightExceeded() : util::Error();</span></span>
<span id="L519"><span class="lineNum">     519</span>                 :             :     }</span>
<span id="L520"><span class="lineNum">     520</span>                 :             : </span>
<span id="L521"><span class="lineNum">     521</span>         [<span class="tlaGBC" title="Branch 0 was taken 38 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 5 times"> + </span>]:<span class="tlaGNC">          43 :     for (const size_t&amp; i : best_selection) {</span></span>
<span id="L522"><span class="lineNum">     522</span>         [<span class="tlaGBC" title="Branch 0 was taken 38 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          38 :         result.AddInput(utxo_pool[i]);</span></span>
<span id="L523"><span class="lineNum">     523</span>                 :             :     }</span>
<span id="L524"><span class="lineNum">     524</span>                 :             : </span>
<span id="L525"><span class="lineNum">     525</span>                 :<span class="tlaGNC">           5 :     return result;</span></span>
<span id="L526"><span class="lineNum">     526</span>                 :<span class="tlaGNC">          13 : }</span></span>
<span id="L527"><span class="lineNum">     527</span>                 :             : </span>
<span id="L528"><span class="lineNum">     528</span>                 :             : class MinOutputGroupComparator</span>
<span id="L529"><span class="lineNum">     529</span>                 :             : {</span>
<span id="L530"><span class="lineNum">     530</span>                 :             : public:</span>
<span id="L531"><span class="lineNum">     531</span>                 :<span class="tlaGNC">      483696 :     int operator() (const OutputGroup&amp; group1, const OutputGroup&amp; group2) const</span></span>
<span id="L532"><span class="lineNum">     532</span>                 :             :     {</span>
<span id="L533"><span class="lineNum">     533</span>                 :<span class="tlaGNC">      483696 :         return group1.GetSelectionAmount() &gt; group2.GetSelectionAmount();</span></span>
<span id="L534"><span class="lineNum">     534</span>                 :             :     }</span>
<span id="L535"><span class="lineNum">     535</span>                 :             : };</span>
<span id="L536"><span class="lineNum">     536</span>                 :             : </span>
<span id="L537"><span class="lineNum">     537</span>                 :<span class="tlaGNC">         129 : util::Result&lt;SelectionResult&gt; SelectCoinsSRD(const std::vector&lt;OutputGroup&gt;&amp; utxo_pool, CAmount target_value, CAmount change_fee, FastRandomContext&amp; rng,</span></span>
<span id="L538"><span class="lineNum">     538</span>                 :             :                                              int max_selection_weight)</span>
<span id="L539"><span class="lineNum">     539</span>                 :             : {</span>
<span id="L540"><span class="lineNum">     540</span>         [<span class="tlaGBC" title="Branch 0 was taken 129 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         129 :     SelectionResult result(target_value, SelectionAlgorithm::SRD);</span></span>
<span id="L541"><span class="lineNum">     541</span>         [<span class="tlaGBC" title="Branch 0 was taken 129 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         129 :     std::priority_queue&lt;OutputGroup, std::vector&lt;OutputGroup&gt;, MinOutputGroupComparator&gt; heap;</span></span>
<span id="L542"><span class="lineNum">     542</span>                 :             : </span>
<span id="L543"><span class="lineNum">     543</span>                 :             :     // Include change for SRD as we want to avoid making really small change if the selection just</span>
<span id="L544"><span class="lineNum">     544</span>                 :             :     // barely meets the target. Just use the lower bound change target instead of the randomly</span>
<span id="L545"><span class="lineNum">     545</span>                 :             :     // generated one, since SRD will result in a random change amount anyway; avoid making the</span>
<span id="L546"><span class="lineNum">     546</span>                 :             :     // target needlessly large.</span>
<span id="L547"><span class="lineNum">     547</span>                 :<span class="tlaGNC">         129 :     target_value += CHANGE_LOWER + change_fee;</span></span>
<span id="L548"><span class="lineNum">     548</span>                 :             : </span>
<span id="L549"><span class="lineNum">     549</span>                 :<span class="tlaGNC">         129 :     std::vector&lt;size_t&gt; indexes;</span></span>
<span id="L550"><span class="lineNum">     550</span>         [<span class="tlaGBC" title="Branch 0 was taken 129 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         129 :     indexes.resize(utxo_pool.size());</span></span>
<span id="L551"><span class="lineNum">     551</span>                 :<span class="tlaGNC">         129 :     std::iota(indexes.begin(), indexes.end(), 0);</span></span>
<span id="L552"><span class="lineNum">     552</span>                 :<span class="tlaGNC">         129 :     std::shuffle(indexes.begin(), indexes.end(), rng);</span></span>
<span id="L553"><span class="lineNum">     553</span>                 :             : </span>
<span id="L554"><span class="lineNum">     554</span>                 :<span class="tlaGNC">         129 :     CAmount selected_eff_value = 0;</span></span>
<span id="L555"><span class="lineNum">     555</span>                 :<span class="tlaGNC">         129 :     int weight = 0;</span></span>
<span id="L556"><span class="lineNum">     556</span>                 :<span class="tlaGNC">         129 :     bool max_tx_weight_exceeded = false;</span></span>
<span id="L557"><span class="lineNum">     557</span>         [<span class="tlaGBC" title="Branch 0 was taken 56169 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 17 times"> + </span>]:<span class="tlaGNC">       56186 :     for (const size_t i : indexes) {</span></span>
<span id="L558"><span class="lineNum">     558</span>         [<span class="tlaGBC" title="Branch 0 was taken 56169 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       56169 :         const OutputGroup&amp; group = utxo_pool.at(i);</span></span>
<span id="L559"><span class="lineNum">     559</span>   [<span class="tlaGBC" title="Branch 0 was taken 56169 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 56169 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">       56169 :         Assume(group.GetSelectionAmount() &gt; 0);</span></span>
<span id="L560"><span class="lineNum">     560</span>                 :             : </span>
<span id="L561"><span class="lineNum">     561</span>                 :             :         // Add group to selection</span>
<span id="L562"><span class="lineNum">     562</span>         [<span class="tlaGBC" title="Branch 0 was taken 56169 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       56169 :         heap.push(group);</span></span>
<span id="L563"><span class="lineNum">     563</span>         [<span class="tlaGBC" title="Branch 0 was taken 56169 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       56169 :         selected_eff_value += group.GetSelectionAmount();</span></span>
<span id="L564"><span class="lineNum">     564</span>                 :<span class="tlaGNC">       56169 :         weight += group.m_weight;</span></span>
<span id="L565"><span class="lineNum">     565</span>                 :             : </span>
<span id="L566"><span class="lineNum">     566</span>                 :             :         // If the selection weight exceeds the maximum allowed size, remove the least valuable inputs until we</span>
<span id="L567"><span class="lineNum">     567</span>                 :             :         // are below max weight.</span>
<span id="L568"><span class="lineNum">     568</span>         [<span class="tlaGBC" title="Branch 0 was taken 911 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 55258 times"> + </span>]:<span class="tlaGNC">       56169 :         if (weight &gt; max_selection_weight) {</span></span>
<span id="L569"><span class="lineNum">     569</span>                 :<span class="tlaGNC">         911 :             max_tx_weight_exceeded = true; // mark it in case we don't find any useful result.</span></span>
<span id="L570"><span class="lineNum">     570</span>                 :<span class="tlaGNC">         911 :             do {</span></span>
<span id="L571"><span class="lineNum">     571</span>         [<span class="tlaGBC" title="Branch 0 was taken 911 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         911 :                 const OutputGroup&amp; to_remove_group = heap.top();</span></span>
<span id="L572"><span class="lineNum">     572</span>         [<span class="tlaGBC" title="Branch 0 was taken 911 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         911 :                 selected_eff_value -= to_remove_group.GetSelectionAmount();</span></span>
<span id="L573"><span class="lineNum">     573</span>                 :<span class="tlaGNC">         911 :                 weight -= to_remove_group.m_weight;</span></span>
<span id="L574"><span class="lineNum">     574</span>         [<span class="tlaGBC" title="Branch 0 was taken 911 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         911 :                 heap.pop();</span></span>
<span id="L575"><span class="lineNum">     575</span>   [<span class="tlaGBC" title="Branch 0 was taken 911 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 911 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">        1822 :             } while (!heap.empty() &amp;&amp; weight &gt; max_selection_weight);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaGBC" title="Branch 5 was taken 911 times"> + </span>]
<span id="L576"><span class="lineNum">     576</span>                 :             :         }</span>
<span id="L577"><span class="lineNum">     577</span>                 :             : </span>
<span id="L578"><span class="lineNum">     578</span>                 :             :         // Now check if we are above the target</span>
<span id="L579"><span class="lineNum">     579</span>         [<span class="tlaGBC" title="Branch 0 was taken 112 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 56057 times"> + </span>]:<span class="tlaGNC">       56169 :         if (selected_eff_value &gt;= target_value) {</span></span>
<span id="L580"><span class="lineNum">     580</span>                 :             :             // Result found, add it.</span>
<span id="L581"><span class="lineNum">     581</span>         [<span class="tlaGBC" title="Branch 0 was taken 46403 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 112 times"> + </span>]:<span class="tlaGNC">       46515 :             while (!heap.empty()) {</span></span>
<span id="L582"><span class="lineNum">     582</span>         [<span class="tlaGBC" title="Branch 0 was taken 46403 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       46403 :                 result.AddInput(heap.top());</span></span>
<span id="L583"><span class="lineNum">     583</span>         [<span class="tlaGBC" title="Branch 0 was taken 46403 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       46403 :                 heap.pop();</span></span>
<span id="L584"><span class="lineNum">     584</span>                 :             :             }</span>
<span id="L585"><span class="lineNum">     585</span>                 :<span class="tlaGNC">         112 :             return result;</span></span>
<span id="L586"><span class="lineNum">     586</span>                 :             :         }</span>
<span id="L587"><span class="lineNum">     587</span>                 :             :     }</span>
<span id="L588"><span class="lineNum">     588</span>   [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          27 :     return max_tx_weight_exceeded ? ErrorMaxWeightExceeded() : util::Error();</span></span>
<span id="L589"><span class="lineNum">     589</span>                 :<span class="tlaGNC">         129 : }</span></span>
<span id="L590"><span class="lineNum">     590</span>                 :             : </span>
<span id="L591"><span class="lineNum">     591</span>                 :             : /** Find a subset of the OutputGroups that is at least as large as, but as close as possible to, the</span>
<span id="L592"><span class="lineNum">     592</span>                 :             :  * target amount; solve subset sum.</span>
<span id="L593"><span class="lineNum">     593</span>                 :             :  * param@[in]   groups          OutputGroups to choose from, sorted by value in descending order.</span>
<span id="L594"><span class="lineNum">     594</span>                 :             :  * param@[in]   nTotalLower     Total (effective) value of the UTXOs in groups.</span>
<span id="L595"><span class="lineNum">     595</span>                 :             :  * param@[in]   nTargetValue    Subset sum target, not including change.</span>
<span id="L596"><span class="lineNum">     596</span>                 :             :  * param@[out]  vfBest          Boolean vector representing the subset chosen that is closest to</span>
<span id="L597"><span class="lineNum">     597</span>                 :             :  *                              nTargetValue, with indices corresponding to groups. If the ith</span>
<span id="L598"><span class="lineNum">     598</span>                 :             :  *                              entry is true, that means the ith group in groups was selected.</span>
<span id="L599"><span class="lineNum">     599</span>                 :             :  * param@[out]  nBest           Total amount of subset chosen that is closest to nTargetValue.</span>
<span id="L600"><span class="lineNum">     600</span>                 :             :  * paramp[in]   max_selection_weight  The maximum allowed weight for a selection result to be valid.</span>
<span id="L601"><span class="lineNum">     601</span>                 :             :  * param@[in]   iterations      Maximum number of tries.</span>
<span id="L602"><span class="lineNum">     602</span>                 :             :  */</span>
<span id="L603"><span class="lineNum">     603</span>                 :<span class="tlaGNC">        2925 : static void ApproximateBestSubset(FastRandomContext&amp; insecure_rand, const std::vector&lt;OutputGroup&gt;&amp; groups,</span></span>
<span id="L604"><span class="lineNum">     604</span>                 :             :                                   const CAmount&amp; nTotalLower, const CAmount&amp; nTargetValue,</span>
<span id="L605"><span class="lineNum">     605</span>                 :             :                                   std::vector&lt;char&gt;&amp; vfBest, CAmount&amp; nBest, int max_selection_weight, int iterations = 1000)</span>
<span id="L606"><span class="lineNum">     606</span>                 :             : {</span>
<span id="L607"><span class="lineNum">     607</span>                 :<span class="tlaGNC">        2925 :     std::vector&lt;char&gt; vfIncluded;</span></span>
<span id="L608"><span class="lineNum">     608</span>                 :             : </span>
<span id="L609"><span class="lineNum">     609</span>                 :             :     // Worst case &quot;best&quot; approximation is just all of the groups.</span>
<span id="L610"><span class="lineNum">     610</span>         [<span class="tlaGBC" title="Branch 0 was taken 2925 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        2925 :     vfBest.assign(groups.size(), true);</span></span>
<span id="L611"><span class="lineNum">     611</span>                 :<span class="tlaGNC">        2925 :     nBest = nTotalLower;</span></span>
<span id="L612"><span class="lineNum">     612</span>                 :             : </span>
<span id="L613"><span class="lineNum">     613</span>   [<span class="tlaGBC" title="Branch 0 was taken 1736829 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1723 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 1735627 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 1202 times"> + </span>]:<span class="tlaGNC">     1738552 :     for (int nRep = 0; nRep &lt; iterations &amp;&amp; nBest != nTargetValue; nRep++)</span></span>
<span id="L614"><span class="lineNum">     614</span>                 :             :     {</span>
<span id="L615"><span class="lineNum">     615</span>         [<span class="tlaGBC" title="Branch 0 was taken 1735627 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">     1735627 :         vfIncluded.assign(groups.size(), false);</span></span>
<span id="L616"><span class="lineNum">     616</span>                 :             :         CAmount nTotal = 0;</span>
<span id="L617"><span class="lineNum">     617</span>                 :             :         int selected_coins_weight{0};</span>
<span id="L618"><span class="lineNum">     618</span>                 :             :         bool fReachedTarget = false;</span>
<span id="L619"><span class="lineNum">     619</span>         [<span class="tlaGBC" title="Branch 0 was taken 2620191 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1735627 times"> + </span>]:<span class="tlaGNC">     4355818 :         for (int nPass = 0; nPass &lt; 2 &amp;&amp; !fReachedTarget; nPass++)</span></span>
<span id="L620"><span class="lineNum">     620</span>                 :             :         {</span>
<span id="L621"><span class="lineNum">     621</span>         [<span class="tlaGBC" title="Branch 0 was taken 402841594 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2620191 times"> + </span>]:<span class="tlaGNC">   405461785 :             for (unsigned int i = 0; i &lt; groups.size(); i++)</span></span>
<span id="L622"><span class="lineNum">     622</span>                 :             :             {</span>
<span id="L623"><span class="lineNum">     623</span>                 :             :                 //The solver here uses a randomized algorithm,</span>
<span id="L624"><span class="lineNum">     624</span>                 :             :                 //the randomness serves no real security purpose but is just</span>
<span id="L625"><span class="lineNum">     625</span>                 :             :                 //needed to prevent degenerate behavior and it is important</span>
<span id="L626"><span class="lineNum">     626</span>                 :             :                 //that the rng is fast. We do not use a constant random sequence,</span>
<span id="L627"><span class="lineNum">     627</span>                 :             :                 //because there may be some privacy improvement by making</span>
<span id="L628"><span class="lineNum">     628</span>                 :             :                 //the selection random.</span>
<span id="L629"><span class="lineNum">     629</span>   [<span class="tlaGBC" title="Branch 0 was taken 375082197 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 27759397 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 201781475 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 201060119 times"> + </span>]:<span class="tlaGNC">   402841594 :                 if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])</span></span>
<span id="L630"><span class="lineNum">     630</span>                 :             :                 {</span>
<span id="L631"><span class="lineNum">     631</span>         [<span class="tlaGBC" title="Branch 0 was taken 201781475 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">   201781475 :                     nTotal += groups[i].GetSelectionAmount();</span></span>
<span id="L632"><span class="lineNum">     632</span>         [<span class="tlaGBC" title="Branch 0 was taken 168317548 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 33463927 times"> + </span>]:<span class="tlaGNC">   201781475 :                     selected_coins_weight += groups[i].m_weight;</span></span>
<span id="L633"><span class="lineNum">     633</span>         [<span class="tlaGBC" title="Branch 0 was taken 168317548 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 33463927 times"> + </span>]:<span class="tlaGNC">   201781475 :                     vfIncluded[i] = true;</span></span>
<span id="L634"><span class="lineNum">     634</span>   [<span class="tlaGBC" title="Branch 0 was taken 168317548 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 33463927 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 168100548 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 217000 times"> + </span>]:<span class="tlaGNC">   201781475 :                     if (nTotal &gt;= nTargetValue &amp;&amp; selected_coins_weight &lt;= max_selection_weight) {</span></span>
<span id="L635"><span class="lineNum">     635</span>                 :<span class="tlaGNC">   168100548 :                         fReachedTarget = true;</span></span>
<span id="L636"><span class="lineNum">     636</span>                 :             :                         // If the total is between nTargetValue and nBest, it's our new best</span>
<span id="L637"><span class="lineNum">     637</span>                 :             :                         // approximation.</span>
<span id="L638"><span class="lineNum">     638</span>         [<span class="tlaGBC" title="Branch 0 was taken 19801 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 168080747 times"> + </span>]:<span class="tlaGNC">   168100548 :                         if (nTotal &lt; nBest)</span></span>
<span id="L639"><span class="lineNum">     639</span>                 :             :                         {</span>
<span id="L640"><span class="lineNum">     640</span>                 :<span class="tlaGNC">       19801 :                             nBest = nTotal;</span></span>
<span id="L641"><span class="lineNum">     641</span>         [<span class="tlaGBC" title="Branch 0 was taken 19801 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">       19801 :                             vfBest = vfIncluded;</span></span>
<span id="L642"><span class="lineNum">     642</span>                 :             :                         }</span>
<span id="L643"><span class="lineNum">     643</span>         [<span class="tlaGBC" title="Branch 0 was taken 168100548 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">   168100548 :                         nTotal -= groups[i].GetSelectionAmount();</span></span>
<span id="L644"><span class="lineNum">     644</span>                 :<span class="tlaGNC">   168100548 :                         selected_coins_weight -= groups[i].m_weight;</span></span>
<span id="L645"><span class="lineNum">     645</span>                 :<span class="tlaGNC">   168100548 :                         vfIncluded[i] = false;</span></span>
<span id="L646"><span class="lineNum">     646</span>                 :             :                     }</span>
<span id="L647"><span class="lineNum">     647</span>                 :             :                 }</span>
<span id="L648"><span class="lineNum">     648</span>                 :             :             }</span>
<span id="L649"><span class="lineNum">     649</span>                 :             :         }</span>
<span id="L650"><span class="lineNum">     650</span>                 :             :     }</span>
<span id="L651"><span class="lineNum">     651</span>                 :<span class="tlaGNC">        2925 : }</span></span>
<span id="L652"><span class="lineNum">     652</span>                 :             : </span>
<span id="L653"><span class="lineNum">     653</span>                 :<span class="tlaGNC">        5727 : util::Result&lt;SelectionResult&gt; KnapsackSolver(std::vector&lt;OutputGroup&gt;&amp; groups, const CAmount&amp; nTargetValue,</span></span>
<span id="L654"><span class="lineNum">     654</span>                 :             :                                              CAmount change_target, FastRandomContext&amp; rng, int max_selection_weight)</span>
<span id="L655"><span class="lineNum">     655</span>                 :             : {</span>
<span id="L656"><span class="lineNum">     656</span>                 :<span class="tlaGNC">        5727 :     SelectionResult result(nTargetValue, SelectionAlgorithm::KNAPSACK);</span></span>
<span id="L657"><span class="lineNum">     657</span>                 :             : </span>
<span id="L658"><span class="lineNum">     658</span>                 :<span class="tlaGNC">        5727 :     bool max_weight_exceeded{false};</span></span>
<span id="L659"><span class="lineNum">     659</span>                 :             :     // List of values less than target</span>
<span id="L660"><span class="lineNum">     660</span>                 :<span class="tlaGNC">        5727 :     std::optional&lt;OutputGroup&gt; lowest_larger;</span></span>
<span id="L661"><span class="lineNum">     661</span>                 :             :     // Groups with selection amount smaller than the target and any change we might produce.</span>
<span id="L662"><span class="lineNum">     662</span>                 :             :     // Don't include groups larger than this, because they will only cause us to overshoot.</span>
<span id="L663"><span class="lineNum">     663</span>                 :<span class="tlaGNC">        5727 :     std::vector&lt;OutputGroup&gt; applicable_groups;</span></span>
<span id="L664"><span class="lineNum">     664</span>                 :<span class="tlaGNC">        5727 :     CAmount nTotalLower = 0;</span></span>
<span id="L665"><span class="lineNum">     665</span>                 :             : </span>
<span id="L666"><span class="lineNum">     666</span>                 :<span class="tlaGNC">        5727 :     std::shuffle(groups.begin(), groups.end(), rng);</span></span>
<span id="L667"><span class="lineNum">     667</span>                 :             : </span>
<span id="L668"><span class="lineNum">     668</span>         [<span class="tlaGBC" title="Branch 0 was taken 593031 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 4622 times"> + </span>]:<span class="tlaGNC">      597653 :     for (const OutputGroup&amp; group : groups) {</span></span>
<span id="L669"><span class="lineNum">     669</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 593031 times"> + </span>]:<span class="tlaGNC">      593031 :         if (group.m_weight &gt; max_selection_weight) {</span></span>
<span id="L670"><span class="lineNum">     670</span>                 :<span class="tlaUNC tlaBgUNC">           0 :             max_weight_exceeded = true;</span></span>
<span id="L671"><span class="lineNum">     671</span>                 :<span class="tlaUNC">           0 :             continue;</span></span>
<span id="L672"><span class="lineNum">     672</span>                 :             :         }</span>
<span id="L673"><span class="lineNum">     673</span>   [<span class="tlaGBC" title="Branch 0 was taken 593031 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 1105 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 591926 times"> + </span>]:<span class="tlaGNC tlaBgGNC">      593031 :         if (group.GetSelectionAmount() == nTargetValue) {</span></span>
<span id="L674"><span class="lineNum">     674</span>         [<span class="tlaGBC" title="Branch 0 was taken 1105 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        1105 :             result.AddInput(group);</span></span>
<span id="L675"><span class="lineNum">     675</span>                 :<span class="tlaGNC">        1105 :             return result;</span></span>
<span id="L676"><span class="lineNum">     676</span>   [<span class="tlaGBC" title="Branch 0 was taken 591926 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 354019 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 237907 times"> + </span>]:<span class="tlaGNC">      591926 :         } else if (group.GetSelectionAmount() &lt; nTargetValue + change_target) {</span></span>
<span id="L677"><span class="lineNum">     677</span>         [<span class="tlaGBC" title="Branch 0 was taken 354019 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      354019 :             applicable_groups.push_back(group);</span></span>
<span id="L678"><span class="lineNum">     678</span>         [<span class="tlaGBC" title="Branch 0 was taken 354019 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      354019 :             nTotalLower += group.GetSelectionAmount();</span></span>
<span id="L679"><span class="lineNum">     679</span>   [<span class="tlaGBC" title="Branch 0 was taken 235400 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2507 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 235400 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">      237907 :         } else if (!lowest_larger || group.GetSelectionAmount() &lt; lowest_larger-&gt;GetSelectionAmount()) {</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 235400 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 572 times"> + </span><span class="tlaGBC" title="Branch 7 was taken 234828 times"> + </span>]
<span id="L680"><span class="lineNum">     680</span>         [<span class="tlaGBC" title="Branch 0 was taken 3079 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        3079 :             lowest_larger = group;</span></span>
<span id="L681"><span class="lineNum">     681</span>                 :             :         }</span>
<span id="L682"><span class="lineNum">     682</span>                 :             :     }</span>
<span id="L683"><span class="lineNum">     683</span>                 :             : </span>
<span id="L684"><span class="lineNum">     684</span>         [<span class="tlaGBC" title="Branch 0 was taken 501 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 4121 times"> + </span>]:<span class="tlaGNC">        4622 :     if (nTotalLower == nTargetValue) {</span></span>
<span id="L685"><span class="lineNum">     685</span>         [<span class="tlaGBC" title="Branch 0 was taken 1902 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 501 times"> + </span>]:<span class="tlaGNC">        2403 :         for (const auto&amp; group : applicable_groups) {</span></span>
<span id="L686"><span class="lineNum">     686</span>         [<span class="tlaGBC" title="Branch 0 was taken 1902 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        1902 :             result.AddInput(group);</span></span>
<span id="L687"><span class="lineNum">     687</span>                 :             :         }</span>
<span id="L688"><span class="lineNum">     688</span>         [<span class="tlaGBC" title="Branch 0 was taken 501 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         501 :         if (result.GetWeight() &lt;= max_selection_weight) return result;</span></span>
<span id="L689"><span class="lineNum">     689</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         else max_weight_exceeded = true;</span></span>
<span id="L690"><span class="lineNum">     690</span>                 :             : </span>
<span id="L691"><span class="lineNum">     691</span>                 :             :         // Try something else</span>
<span id="L692"><span class="lineNum">     692</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         result.Clear();</span></span>
<span id="L693"><span class="lineNum">     693</span>                 :             :     }</span>
<span id="L694"><span class="lineNum">     694</span>                 :             : </span>
<span id="L695"><span class="lineNum">     695</span>         [<span class="tlaGBC" title="Branch 0 was taken 2105 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2016 times"> + </span>]:<span class="tlaGNC tlaBgGNC">        4121 :     if (nTotalLower &lt; nTargetValue) {</span></span>
<span id="L696"><span class="lineNum">     696</span>         [<span class="tlaGBC" title="Branch 0 was taken 600 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1505 times"> + </span>]:<span class="tlaGNC">        2105 :         if (!lowest_larger) {</span></span>
<span id="L697"><span class="lineNum">     697</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 600 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         600 :             if (max_weight_exceeded) return ErrorMaxWeightExceeded();</span></span>
<span id="L698"><span class="lineNum">     698</span>                 :<span class="tlaGNC">        1200 :             return util::Error();</span></span>
<span id="L699"><span class="lineNum">     699</span>                 :             :         }</span>
<span id="L700"><span class="lineNum">     700</span>         [<span class="tlaGBC" title="Branch 0 was taken 1505 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        1505 :         result.AddInput(*lowest_larger);</span></span>
<span id="L701"><span class="lineNum">     701</span>                 :<span class="tlaGNC">        1505 :         return result;</span></span>
<span id="L702"><span class="lineNum">     702</span>                 :             :     }</span>
<span id="L703"><span class="lineNum">     703</span>                 :             : </span>
<span id="L704"><span class="lineNum">     704</span>                 :             :     // Solve subset sum by stochastic approximation</span>
<span id="L705"><span class="lineNum">     705</span>         [<span class="tlaGBC" title="Branch 0 was taken 2016 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        2016 :     std::sort(applicable_groups.begin(), applicable_groups.end(), descending);</span></span>
<span id="L706"><span class="lineNum">     706</span>                 :<span class="tlaGNC">        2016 :     std::vector&lt;char&gt; vfBest;</span></span>
<span id="L707"><span class="lineNum">     707</span>                 :<span class="tlaGNC">        2016 :     CAmount nBest;</span></span>
<span id="L708"><span class="lineNum">     708</span>                 :             : </span>
<span id="L709"><span class="lineNum">     709</span>         [<span class="tlaGBC" title="Branch 0 was taken 2016 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        2016 :     ApproximateBestSubset(rng, applicable_groups, nTotalLower, nTargetValue, vfBest, nBest, max_selection_weight);</span></span>
<span id="L710"><span class="lineNum">     710</span>   [<span class="tlaGBC" title="Branch 0 was taken 1015 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1001 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 909 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 106 times"> + </span>]:<span class="tlaGNC">        2016 :     if (nBest != nTargetValue &amp;&amp; nTotalLower &gt;= nTargetValue + change_target) {</span></span>
<span id="L711"><span class="lineNum">     711</span>         [<span class="tlaGBC" title="Branch 0 was taken 909 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         909 :         ApproximateBestSubset(rng, applicable_groups, nTotalLower, nTargetValue + change_target, vfBest, nBest, max_selection_weight);</span></span>
<span id="L712"><span class="lineNum">     712</span>                 :             :     }</span>
<span id="L713"><span class="lineNum">     713</span>                 :             : </span>
<span id="L714"><span class="lineNum">     714</span>                 :             :     // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,</span>
<span id="L715"><span class="lineNum">     715</span>                 :             :     //                                   or the next bigger coin is closer), return the bigger coin</span>
<span id="L716"><span class="lineNum">     716</span>         [<span class="tlaGBC" title="Branch 0 was taken 901 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1115 times"> + </span>]:<span class="tlaGNC">        2016 :     if (lowest_larger &amp;&amp;</span></span>
<span id="L717"><span class="lineNum">     717</span>   [<span class="tlaGBC" title="Branch 0 was taken 901 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1115 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 401 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 500 times"> + </span> :<span class="tlaGNC">        2016 :         ((nBest != nTargetValue &amp;&amp; nBest &lt; nTargetValue + change_target) || lowest_larger-&gt;GetSelectionAmount() &lt;= nBest)) {</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 301 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 100 times"> + </span><span class="tlaGBC" title="Branch 6 was taken 801 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span><span class="tlaGBC" title="Branch 8 was taken 200 times"> + </span> 
<span class="lineNum">        </span>             <span class="tlaGBC" title="Branch 9 was taken 601 times"> + </span>]
<span id="L718"><span class="lineNum">     718</span>         [<span class="tlaGBC" title="Branch 0 was taken 300 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         300 :         result.AddInput(*lowest_larger);</span></span>
<span id="L719"><span class="lineNum">     719</span>                 :             :     } else {</span>
<span id="L720"><span class="lineNum">     720</span>         [<span class="tlaGBC" title="Branch 0 was taken 343015 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1716 times"> + </span>]:<span class="tlaGNC">      344731 :         for (unsigned int i = 0; i &lt; applicable_groups.size(); i++) {</span></span>
<span id="L721"><span class="lineNum">     721</span>         [<span class="tlaGBC" title="Branch 0 was taken 131080 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 211935 times"> + </span>]:<span class="tlaGNC">      343015 :             if (vfBest[i]) {</span></span>
<span id="L722"><span class="lineNum">     722</span>         [<span class="tlaGBC" title="Branch 0 was taken 131080 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      131080 :                 result.AddInput(applicable_groups[i]);</span></span>
<span id="L723"><span class="lineNum">     723</span>                 :             :             }</span>
<span id="L724"><span class="lineNum">     724</span>                 :             :         }</span>
<span id="L725"><span class="lineNum">     725</span>                 :             : </span>
<span id="L726"><span class="lineNum">     726</span>                 :             :         // If the result exceeds the maximum allowed size, return closest UTXO above the target</span>
<span id="L727"><span class="lineNum">     727</span>         [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1709 times"> + </span>]:<span class="tlaGNC">        1716 :         if (result.GetWeight() &gt; max_selection_weight) {</span></span>
<span id="L728"><span class="lineNum">     728</span>                 :             :             // No coin above target, nothing to do.</span>
<span id="L729"><span class="lineNum">     729</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 2 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           7 :             if (!lowest_larger) return ErrorMaxWeightExceeded();</span></span>
<span id="L730"><span class="lineNum">     730</span>                 :             : </span>
<span id="L731"><span class="lineNum">     731</span>                 :             :             // Return closest UTXO above target</span>
<span id="L732"><span class="lineNum">     732</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :             result.Clear();</span></span>
<span id="L733"><span class="lineNum">     733</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :             result.AddInput(*lowest_larger);</span></span>
<span id="L734"><span class="lineNum">     734</span>                 :             :         }</span>
<span id="L735"><span class="lineNum">     735</span>                 :             : </span>
<span id="L736"><span class="lineNum">     736</span>   [<span class="tlaGBC" title="Branch 0 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">        1710 :         if (LogAcceptCategory(BCLog::SELECTCOINS, BCLog::Level::Debug)) {</span></span>
<span id="L737"><span class="lineNum">     737</span>         [<span class="tlaGBC" title="Branch 0 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        1710 :             std::string log_message{&quot;Coin selection best subset: &quot;};</span></span>
<span id="L738"><span class="lineNum">     738</span>         [<span class="tlaGBC" title="Branch 0 was taken 333925 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1710 times"> + </span>]:<span class="tlaGNC">      335635 :             for (unsigned int i = 0; i &lt; applicable_groups.size(); i++) {</span></span>
<span id="L739"><span class="lineNum">     739</span>         [<span class="tlaGBC" title="Branch 0 was taken 121990 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 211935 times"> + </span>]:<span class="tlaGNC">      333925 :                 if (vfBest[i]) {</span></span>
<span id="L740"><span class="lineNum">     740</span>   [<span class="tlaGBC" title="Branch 0 was taken 121990 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 121990 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">      243980 :                     log_message += strprintf(&quot;%s &quot;, FormatMoney(applicable_groups[i].m_value));</span></span>
<span id="L741"><span class="lineNum">     741</span>                 :             :                 }</span>
<span id="L742"><span class="lineNum">     742</span>                 :             :             }</span>
<span id="L743"><span class="lineNum">     743</span>   [<span class="tlaGBC" title="Branch 0 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">        3420 :             LogDebug(BCLog::SELECTCOINS, &quot;%stotal %s\n&quot;, log_message, FormatMoney(nBest));</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 1710 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L744"><span class="lineNum">     744</span>                 :<span class="tlaGNC">        1710 :         }</span></span>
<span id="L745"><span class="lineNum">     745</span>                 :             :     }</span>
<span id="L746"><span class="lineNum">     746</span>         [<span class="tlaGBC" title="Branch 0 was taken 2010 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        2010 :     Assume(result.GetWeight() &lt;= max_selection_weight);</span></span>
<span id="L747"><span class="lineNum">     747</span>                 :<span class="tlaGNC">        2010 :     return result;</span></span>
<span id="L748"><span class="lineNum">     748</span>                 :<span class="tlaGNC">        5727 : }</span></span>
<span id="L749"><span class="lineNum">     749</span>                 :             : </span>
<span id="L750"><span class="lineNum">     750</span>                 :             : /******************************************************************************</span>
<span id="L751"><span class="lineNum">     751</span>                 :             : </span>
<span id="L752"><span class="lineNum">     752</span>                 :             :  OutputGroup</span>
<span id="L753"><span class="lineNum">     753</span>                 :             : </span>
<span id="L754"><span class="lineNum">     754</span>                 :             :  ******************************************************************************/</span>
<span id="L755"><span class="lineNum">     755</span>                 :             : </span>
<span id="L756"><span class="lineNum">     756</span>                 :<span class="tlaGNC">      738673 : void OutputGroup::Insert(const std::shared_ptr&lt;COutput&gt;&amp; output, size_t ancestors, size_t descendants) {</span></span>
<span id="L757"><span class="lineNum">     757</span>                 :<span class="tlaGNC">      738673 :     m_outputs.push_back(output);</span></span>
<span id="L758"><span class="lineNum">     758</span>                 :<span class="tlaGNC">      738673 :     auto&amp; coin = *m_outputs.back();</span></span>
<span id="L759"><span class="lineNum">     759</span>                 :             : </span>
<span id="L760"><span class="lineNum">     760</span>                 :<span class="tlaGNC">      738673 :     fee += coin.GetFee();</span></span>
<span id="L761"><span class="lineNum">     761</span>                 :             : </span>
<span id="L762"><span class="lineNum">     762</span>         [<span class="tlaGBC" title="Branch 0 was taken 7296 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 731377 times"> + </span>]:<span class="tlaGNC">      738673 :     coin.long_term_fee = coin.input_bytes &lt; 0 ? 0 : m_long_term_feerate.GetFee(coin.input_bytes);</span></span>
<span id="L763"><span class="lineNum">     763</span>                 :<span class="tlaGNC">      738673 :     long_term_fee += coin.long_term_fee;</span></span>
<span id="L764"><span class="lineNum">     764</span>                 :             : </span>
<span id="L765"><span class="lineNum">     765</span>                 :<span class="tlaGNC">      738673 :     effective_value += coin.GetEffectiveValue();</span></span>
<span id="L766"><span class="lineNum">     766</span>                 :             : </span>
<span id="L767"><span class="lineNum">     767</span>                 :<span class="tlaGNC">      738673 :     m_from_me &amp;= coin.from_me;</span></span>
<span id="L768"><span class="lineNum">     768</span>                 :<span class="tlaGNC">      738673 :     m_value += coin.txout.nValue;</span></span>
<span id="L769"><span class="lineNum">     769</span>         [<span class="tlaGBC" title="Branch 0 was taken 666 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 738007 times"> + </span>]:<span class="tlaGNC">      738673 :     m_depth = std::min(m_depth, coin.depth);</span></span>
<span id="L770"><span class="lineNum">     770</span>                 :             :     // ancestors here express the number of ancestors the new coin will end up having, which is</span>
<span id="L771"><span class="lineNum">     771</span>                 :             :     // the sum, rather than the max; this will overestimate in the cases where multiple inputs</span>
<span id="L772"><span class="lineNum">     772</span>                 :             :     // have common ancestors</span>
<span id="L773"><span class="lineNum">     773</span>                 :<span class="tlaGNC">      738673 :     m_ancestors += ancestors;</span></span>
<span id="L774"><span class="lineNum">     774</span>                 :             :     // descendants is the count as seen from the top ancestor, not the descendants as seen from the</span>
<span id="L775"><span class="lineNum">     775</span>                 :             :     // coin itself; thus, this value is counted as the max, not the sum</span>
<span id="L776"><span class="lineNum">     776</span>         [<span class="tlaGBC" title="Branch 0 was taken 738673 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      738673 :     m_descendants = std::max(m_descendants, descendants);</span></span>
<span id="L777"><span class="lineNum">     777</span>                 :             : </span>
<span id="L778"><span class="lineNum">     778</span>         [<span class="tlaGBC" title="Branch 0 was taken 7296 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 731377 times"> + </span>]:<span class="tlaGNC">      738673 :     if (output-&gt;input_bytes &gt; 0) {</span></span>
<span id="L779"><span class="lineNum">     779</span>                 :<span class="tlaGNC">        7296 :         m_weight += output-&gt;input_bytes * WITNESS_SCALE_FACTOR;</span></span>
<span id="L780"><span class="lineNum">     780</span>                 :             :     }</span>
<span id="L781"><span class="lineNum">     781</span>                 :<span class="tlaGNC">      738673 : }</span></span>
<span id="L782"><span class="lineNum">     782</span>                 :             : </span>
<span id="L783"><span class="lineNum">     783</span>                 :<span class="tlaGNC">      988535 : bool OutputGroup::EligibleForSpending(const CoinEligibilityFilter&amp; eligibility_filter) const</span></span>
<span id="L784"><span class="lineNum">     784</span>                 :             : {</span>
<span id="L785"><span class="lineNum">     785</span>         [<span class="tlaGBC" title="Branch 0 was taken 1229 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 987306 times"> + </span>]:<span class="tlaGNC">      988535 :     return m_depth &gt;= (m_from_me ? eligibility_filter.conf_mine : eligibility_filter.conf_theirs)</span></span>
<span id="L786"><span class="lineNum">     786</span>         [<span class="tlaGBC" title="Branch 0 was taken 987914 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      987914 :         &amp;&amp; m_ancestors &lt;= eligibility_filter.max_ancestors</span></span>
<span id="L787"><span class="lineNum">     787</span>   [<span class="tlaGBC" title="Branch 0 was taken 987914 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 621 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 987914 times"> + </span>]:<span class="tlaGNC">     1976449 :         &amp;&amp; m_descendants &lt;= eligibility_filter.max_descendants;</span></span>
<span id="L788"><span class="lineNum">     788</span>                 :             : }</span>
<span id="L789"><span class="lineNum">     789</span>                 :             : </span>
<span id="L790"><span class="lineNum">     790</span>                 :<span class="tlaGNC">   419980893 : CAmount OutputGroup::GetSelectionAmount() const</span></span>
<span id="L791"><span class="lineNum">     791</span>                 :             : {</span>
<span id="L792"><span class="lineNum">     792</span>         [<span class="tlaGBC" title="Branch 0 was taken 20390 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 419960503 times"> + </span>]:<span class="tlaGNC">   419980893 :     return m_subtract_fee_outputs ? m_value : effective_value;</span></span>
<span id="L793"><span class="lineNum">     793</span>                 :             : }</span>
<span id="L794"><span class="lineNum">     794</span>                 :             : </span>
<span id="L795"><span class="lineNum">     795</span>                 :<span class="tlaGNC">      987912 : void OutputGroupTypeMap::Push(const OutputGroup&amp; group, OutputType type, bool insert_positive, bool insert_mixed)</span></span>
<span id="L796"><span class="lineNum">     796</span>                 :             : {</span>
<span id="L797"><span class="lineNum">     797</span>         [<span class="tlaGBC" title="Branch 0 was taken 987912 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">      987912 :     if (group.m_outputs.empty()) return;</span></span>
<span id="L798"><span class="lineNum">     798</span>                 :             : </span>
<span id="L799"><span class="lineNum">     799</span>                 :<span class="tlaGNC">      987912 :     Groups&amp; groups = groups_by_type[type];</span></span>
<span id="L800"><span class="lineNum">     800</span>   [<span class="tlaGBC" title="Branch 0 was taken 987864 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 48 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 987846 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 18 times"> + </span>]:<span class="tlaGNC">      987912 :     if (insert_positive &amp;&amp; group.GetSelectionAmount() &gt; 0) {</span></span>
<span id="L801"><span class="lineNum">     801</span>                 :<span class="tlaGNC">      987846 :         groups.positive_group.emplace_back(group);</span></span>
<span id="L802"><span class="lineNum">     802</span>                 :<span class="tlaGNC">      987846 :         all_groups.positive_group.emplace_back(group);</span></span>
<span id="L803"><span class="lineNum">     803</span>                 :             :     }</span>
<span id="L804"><span class="lineNum">     804</span>         [<span class="tlaGBC" title="Branch 0 was taken 987870 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 42 times"> + </span>]:<span class="tlaGNC">      987912 :     if (insert_mixed) {</span></span>
<span id="L805"><span class="lineNum">     805</span>                 :<span class="tlaGNC">      987870 :         groups.mixed_group.emplace_back(group);</span></span>
<span id="L806"><span class="lineNum">     806</span>                 :<span class="tlaGNC">      987870 :         all_groups.mixed_group.emplace_back(group);</span></span>
<span id="L807"><span class="lineNum">     807</span>                 :             :     }</span>
<span id="L808"><span class="lineNum">     808</span>                 :             : }</span>
<span id="L809"><span class="lineNum">     809</span>                 :             : </span>
<span id="L810"><span class="lineNum">     810</span>                 :<span class="tlaGNC">          15 : CAmount GenerateChangeTarget(const CAmount payment_value, const CAmount change_fee, FastRandomContext&amp; rng)</span></span>
<span id="L811"><span class="lineNum">     811</span>                 :             : {</span>
<span id="L812"><span class="lineNum">     812</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 15 times"> + </span>]:<span class="tlaGNC">          15 :     if (payment_value &lt;= CHANGE_LOWER / 2) {</span></span>
<span id="L813"><span class="lineNum">     813</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         return change_fee + CHANGE_LOWER;</span></span>
<span id="L814"><span class="lineNum">     814</span>                 :             :     } else {</span>
<span id="L815"><span class="lineNum">     815</span>                 :             :         // random value between 50ksat and min (payment_value * 2, 1milsat)</span>
<span id="L816"><span class="lineNum">     816</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 15 times"> + </span>]:<span class="tlaGNC tlaBgGNC">          15 :         const auto upper_bound = std::min(payment_value * 2, CHANGE_UPPER);</span></span>
<span id="L817"><span class="lineNum">     817</span>                 :<span class="tlaGNC">          15 :         return change_fee + rng.randrange(upper_bound - CHANGE_LOWER) + CHANGE_LOWER;</span></span>
<span id="L818"><span class="lineNum">     818</span>                 :             :     }</span>
<span id="L819"><span class="lineNum">     819</span>                 :             : }</span>
<span id="L820"><span class="lineNum">     820</span>                 :             : </span>
<span id="L821"><span class="lineNum">     821</span>                 :<span class="tlaGNC">           2 : void SelectionResult::SetBumpFeeDiscount(const CAmount discount)</span></span>
<span id="L822"><span class="lineNum">     822</span>                 :             : {</span>
<span id="L823"><span class="lineNum">     823</span>                 :             :     // Overlapping ancestry can only lower the fees, not increase them</span>
<span id="L824"><span class="lineNum">     824</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     assert (discount &gt;= 0);</span></span>
<span id="L825"><span class="lineNum">     825</span>                 :<span class="tlaGNC">           2 :     bump_fee_group_discount = discount;</span></span>
<span id="L826"><span class="lineNum">     826</span>                 :<span class="tlaGNC">           2 : }</span></span>
<span id="L827"><span class="lineNum">     827</span>                 :             : </span>
<span id="L828"><span class="lineNum">     828</span>                 :<span class="tlaGNC">         468 : void SelectionResult::RecalculateWaste(const CAmount min_viable_change, const CAmount change_cost, const CAmount change_fee)</span></span>
<span id="L829"><span class="lineNum">     829</span>                 :             : {</span>
<span id="L830"><span class="lineNum">     830</span>                 :             :     // This function should not be called with empty inputs as that would mean the selection failed</span>
<span id="L831"><span class="lineNum">     831</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 468 times"> + </span>]:<span class="tlaGNC">         468 :     assert(!m_selected_inputs.empty());</span></span>
<span id="L832"><span class="lineNum">     832</span>                 :             : </span>
<span id="L833"><span class="lineNum">     833</span>                 :             :     // Always consider the cost of spending an input now vs in the future.</span>
<span id="L834"><span class="lineNum">     834</span>                 :<span class="tlaGNC">         468 :     CAmount waste = 0;</span></span>
<span id="L835"><span class="lineNum">     835</span>         [<span class="tlaGBC" title="Branch 0 was taken 123562 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 468 times"> + </span>]:<span class="tlaGNC">      124030 :     for (const auto&amp; coin_ptr : m_selected_inputs) {</span></span>
<span id="L836"><span class="lineNum">     836</span>                 :<span class="tlaGNC">      123562 :         const COutput&amp; coin = *coin_ptr;</span></span>
<span id="L837"><span class="lineNum">     837</span>                 :<span class="tlaGNC">      123562 :         waste += coin.GetFee() - coin.long_term_fee;</span></span>
<span id="L838"><span class="lineNum">     838</span>                 :             :     }</span>
<span id="L839"><span class="lineNum">     839</span>                 :             :     // Bump fee of whole selection may diverge from sum of individual bump fees</span>
<span id="L840"><span class="lineNum">     840</span>                 :<span class="tlaGNC">         468 :     waste -= bump_fee_group_discount;</span></span>
<span id="L841"><span class="lineNum">     841</span>                 :             : </span>
<span id="L842"><span class="lineNum">     842</span>         [<span class="tlaGBC" title="Branch 0 was taken 127 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 341 times"> + </span>]:<span class="tlaGNC">         468 :     if (GetChange(min_viable_change, change_fee)) {</span></span>
<span id="L843"><span class="lineNum">     843</span>                 :             :         // if we have a minimum viable amount after deducting fees, account for</span>
<span id="L844"><span class="lineNum">     844</span>                 :             :         // cost of creating and spending change</span>
<span id="L845"><span class="lineNum">     845</span>                 :<span class="tlaGNC">         127 :         waste += change_cost;</span></span>
<span id="L846"><span class="lineNum">     846</span>                 :             :     } else {</span>
<span id="L847"><span class="lineNum">     847</span>                 :             :         // When we are not making change (GetChange(…) == 0), consider the excess we are throwing away to fees</span>
<span id="L848"><span class="lineNum">     848</span>         [<span class="tlaGBC" title="Branch 0 was taken 332 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 9 times"> + </span>]:<span class="tlaGNC">         341 :         CAmount selected_effective_value = m_use_effective ? GetSelectedEffectiveValue() : GetSelectedValue();</span></span>
<span id="L849"><span class="lineNum">     849</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 341 times"> + </span>]:<span class="tlaGNC">         341 :         assert(selected_effective_value &gt;= m_target);</span></span>
<span id="L850"><span class="lineNum">     850</span>                 :<span class="tlaGNC">         341 :         waste += selected_effective_value - m_target;</span></span>
<span id="L851"><span class="lineNum">     851</span>                 :             :     }</span>
<span id="L852"><span class="lineNum">     852</span>                 :             : </span>
<span id="L853"><span class="lineNum">     853</span>                 :<span class="tlaGNC">         468 :     m_waste = waste;</span></span>
<span id="L854"><span class="lineNum">     854</span>                 :<span class="tlaGNC">         468 : }</span></span>
<span id="L855"><span class="lineNum">     855</span>                 :             : </span>
<span id="L856"><span class="lineNum">     856</span>                 :<span class="tlaGNC">           6 : void SelectionResult::SetAlgoCompleted(bool algo_completed)</span></span>
<span id="L857"><span class="lineNum">     857</span>                 :             : {</span>
<span id="L858"><span class="lineNum">     858</span>                 :<span class="tlaGNC">           6 :     m_algo_completed = algo_completed;</span></span>
<span id="L859"><span class="lineNum">     859</span>                 :<span class="tlaGNC">           6 : }</span></span>
<span id="L860"><span class="lineNum">     860</span>                 :             : </span>
<span id="L861"><span class="lineNum">     861</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool SelectionResult::GetAlgoCompleted() const</span></span>
<span id="L862"><span class="lineNum">     862</span>                 :             : {</span>
<span id="L863"><span class="lineNum">     863</span>                 :<span class="tlaUNC">           0 :     return m_algo_completed;</span></span>
<span id="L864"><span class="lineNum">     864</span>                 :             : }</span>
<span id="L865"><span class="lineNum">     865</span>                 :             : </span>
<span id="L866"><span class="lineNum">     866</span>                 :<span class="tlaGNC tlaBgGNC">           6 : void SelectionResult::SetSelectionsEvaluated(size_t attempts)</span></span>
<span id="L867"><span class="lineNum">     867</span>                 :             : {</span>
<span id="L868"><span class="lineNum">     868</span>                 :<span class="tlaGNC">           6 :     m_selections_evaluated = attempts;</span></span>
<span id="L869"><span class="lineNum">     869</span>                 :<span class="tlaGNC">           6 : }</span></span>
<span id="L870"><span class="lineNum">     870</span>                 :             : </span>
<span id="L871"><span class="lineNum">     871</span>                 :<span class="tlaGNC">          10 : size_t SelectionResult::GetSelectionsEvaluated() const</span></span>
<span id="L872"><span class="lineNum">     872</span>                 :             : {</span>
<span id="L873"><span class="lineNum">     873</span>                 :<span class="tlaGNC">          10 :     return m_selections_evaluated;</span></span>
<span id="L874"><span class="lineNum">     874</span>                 :             : }</span>
<span id="L875"><span class="lineNum">     875</span>                 :             : </span>
<span id="L876"><span class="lineNum">     876</span>                 :<span class="tlaGNC">         148 : CAmount SelectionResult::GetWaste() const</span></span>
<span id="L877"><span class="lineNum">     877</span>                 :             : {</span>
<span id="L878"><span class="lineNum">     878</span>                 :<span class="tlaGNC">         148 :     return *Assert(m_waste);</span></span>
<span id="L879"><span class="lineNum">     879</span>                 :             : }</span>
<span id="L880"><span class="lineNum">     880</span>                 :             : </span>
<span id="L881"><span class="lineNum">     881</span>                 :<span class="tlaGNC">        2875 : CAmount SelectionResult::GetSelectedValue() const</span></span>
<span id="L882"><span class="lineNum">     882</span>                 :             : {</span>
<span id="L883"><span class="lineNum">     883</span>                 :<span class="tlaGNC">      116423 :     return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto&amp; coin) { return sum + coin-&gt;txout.nValue; });</span></span>
<span id="L884"><span class="lineNum">     884</span>                 :             : }</span>
<span id="L885"><span class="lineNum">     885</span>                 :             : </span>
<span id="L886"><span class="lineNum">     886</span>                 :<span class="tlaGNC">         782 : CAmount SelectionResult::GetSelectedEffectiveValue() const</span></span>
<span id="L887"><span class="lineNum">     887</span>                 :             : {</span>
<span id="L888"><span class="lineNum">     888</span>                 :<span class="tlaGNC">      201478 :     return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto&amp; coin) { return sum + coin-&gt;GetEffectiveValue(); }) + bump_fee_group_discount;</span></span>
<span id="L889"><span class="lineNum">     889</span>                 :             : }</span>
<span id="L890"><span class="lineNum">     890</span>                 :             : </span>
<span id="L891"><span class="lineNum">     891</span>                 :<span class="tlaGNC">          13 : CAmount SelectionResult::GetTotalBumpFees() const</span></span>
<span id="L892"><span class="lineNum">     892</span>                 :             : {</span>
<span id="L893"><span class="lineNum">     893</span>                 :<span class="tlaGNC">          26 :     return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto&amp; coin) { return sum + coin-&gt;ancestor_bump_fees; }) - bump_fee_group_discount;</span></span>
<span id="L894"><span class="lineNum">     894</span>                 :             : }</span>
<span id="L895"><span class="lineNum">     895</span>                 :             : </span>
<span id="L896"><span class="lineNum">     896</span>                 :<span class="tlaGNC">          13 : void SelectionResult::Clear()</span></span>
<span id="L897"><span class="lineNum">     897</span>                 :             : {</span>
<span id="L898"><span class="lineNum">     898</span>                 :<span class="tlaGNC">          13 :     m_selected_inputs.clear();</span></span>
<span id="L899"><span class="lineNum">     899</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 13 times"> + </span>]:<span class="tlaGNC">          13 :     m_waste.reset();</span></span>
<span id="L900"><span class="lineNum">     900</span>                 :<span class="tlaGNC">          13 :     m_weight = 0;</span></span>
<span id="L901"><span class="lineNum">     901</span>                 :<span class="tlaGNC">          13 : }</span></span>
<span id="L902"><span class="lineNum">     902</span>                 :             : </span>
<span id="L903"><span class="lineNum">     903</span>                 :<span class="tlaGNC">      204651 : void SelectionResult::AddInput(const OutputGroup&amp; group)</span></span>
<span id="L904"><span class="lineNum">     904</span>                 :             : {</span>
<span id="L905"><span class="lineNum">     905</span>                 :             :     // As it can fail, combine inputs first</span>
<span id="L906"><span class="lineNum">     906</span>                 :<span class="tlaGNC">      204651 :     InsertInputs(group.m_outputs);</span></span>
<span id="L907"><span class="lineNum">     907</span>                 :<span class="tlaGNC">      204651 :     m_use_effective = !group.m_subtract_fee_outputs;</span></span>
<span id="L908"><span class="lineNum">     908</span>                 :             : </span>
<span id="L909"><span class="lineNum">     909</span>                 :<span class="tlaGNC">      204651 :     m_weight += group.m_weight;</span></span>
<span id="L910"><span class="lineNum">     910</span>                 :<span class="tlaGNC">      204651 : }</span></span>
<span id="L911"><span class="lineNum">     911</span>                 :             : </span>
<span id="L912"><span class="lineNum">     912</span>                 :<span class="tlaGNC">           2 : void SelectionResult::AddInputs(const std::set&lt;std::shared_ptr&lt;COutput&gt;&gt;&amp; inputs, bool subtract_fee_outputs)</span></span>
<span id="L913"><span class="lineNum">     913</span>                 :             : {</span>
<span id="L914"><span class="lineNum">     914</span>                 :             :     // As it can fail, combine inputs first</span>
<span id="L915"><span class="lineNum">     915</span>                 :<span class="tlaGNC">           2 :     InsertInputs(inputs);</span></span>
<span id="L916"><span class="lineNum">     916</span>                 :<span class="tlaGNC">           2 :     m_use_effective = !subtract_fee_outputs;</span></span>
<span id="L917"><span class="lineNum">     917</span>                 :             : </span>
<span id="L918"><span class="lineNum">     918</span>                 :<span class="tlaGNC">           2 :     m_weight += std::accumulate(inputs.cbegin(), inputs.cend(), 0, [](int sum, const auto&amp; coin) {</span></span>
<span id="L919"><span class="lineNum">     919</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           4 :         return sum + std::max(coin-&gt;input_bytes, 0) * WITNESS_SCALE_FACTOR;</span></span>
<span id="L920"><span class="lineNum">     920</span>                 :             :     });</span>
<span id="L921"><span class="lineNum">     921</span>                 :<span class="tlaGNC">           2 : }</span></span>
<span id="L922"><span class="lineNum">     922</span>                 :             : </span>
<span id="L923"><span class="lineNum">     923</span>                 :<span class="tlaGNC">           2 : void SelectionResult::Merge(const SelectionResult&amp; other)</span></span>
<span id="L924"><span class="lineNum">     924</span>                 :             : {</span>
<span id="L925"><span class="lineNum">     925</span>                 :             :     // As it can fail, combine inputs first</span>
<span id="L926"><span class="lineNum">     926</span>                 :<span class="tlaGNC">           2 :     InsertInputs(other.m_selected_inputs);</span></span>
<span id="L927"><span class="lineNum">     927</span>                 :             : </span>
<span id="L928"><span class="lineNum">     928</span>                 :<span class="tlaGNC">           2 :     m_target += other.m_target;</span></span>
<span id="L929"><span class="lineNum">     929</span>                 :<span class="tlaGNC">           2 :     m_use_effective |= other.m_use_effective;</span></span>
<span id="L930"><span class="lineNum">     930</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     if (m_algo == SelectionAlgorithm::MANUAL) {</span></span>
<span id="L931"><span class="lineNum">     931</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         m_algo = other.m_algo;</span></span>
<span id="L932"><span class="lineNum">     932</span>                 :             :     }</span>
<span id="L933"><span class="lineNum">     933</span>                 :             : </span>
<span id="L934"><span class="lineNum">     934</span>                 :<span class="tlaGNC tlaBgGNC">           2 :     m_weight += other.m_weight;</span></span>
<span id="L935"><span class="lineNum">     935</span>                 :<span class="tlaGNC">           2 : }</span></span>
<span id="L936"><span class="lineNum">     936</span>                 :             : </span>
<span id="L937"><span class="lineNum">     937</span>                 :<span class="tlaGNC">        6784 : const std::set&lt;std::shared_ptr&lt;COutput&gt;&gt;&amp; SelectionResult::GetInputSet() const</span></span>
<span id="L938"><span class="lineNum">     938</span>                 :             : {</span>
<span id="L939"><span class="lineNum">     939</span>                 :<span class="tlaGNC">        6784 :     return m_selected_inputs;</span></span>
<span id="L940"><span class="lineNum">     940</span>                 :             : }</span>
<span id="L941"><span class="lineNum">     941</span>                 :             : </span>
<span id="L942"><span class="lineNum">     942</span>                 :<span class="tlaGNC">          15 : std::vector&lt;std::shared_ptr&lt;COutput&gt;&gt; SelectionResult::GetShuffledInputVector() const</span></span>
<span id="L943"><span class="lineNum">     943</span>                 :             : {</span>
<span id="L944"><span class="lineNum">     944</span>                 :<span class="tlaGNC">          15 :     std::vector&lt;std::shared_ptr&lt;COutput&gt;&gt; coins(m_selected_inputs.begin(), m_selected_inputs.end());</span></span>
<span id="L945"><span class="lineNum">     945</span>                 :<span class="tlaGNC">          15 :     std::shuffle(coins.begin(), coins.end(), FastRandomContext());</span></span>
<span id="L946"><span class="lineNum">     946</span>                 :<span class="tlaGNC">          15 :     return coins;</span></span>
<span id="L947"><span class="lineNum">     947</span>                 :             : }</span>
<span id="L948"><span class="lineNum">     948</span>                 :             : </span>
<span id="L949"><span class="lineNum">     949</span>                 :<span class="tlaGNC">         216 : bool SelectionResult::operator&lt;(SelectionResult other) const</span></span>
<span id="L950"><span class="lineNum">     950</span>                 :             : {</span>
<span id="L951"><span class="lineNum">     951</span>                 :<span class="tlaGNC">         216 :     Assert(m_waste.has_value());</span></span>
<span id="L952"><span class="lineNum">     952</span>                 :<span class="tlaGNC">         216 :     Assert(other.m_waste.has_value());</span></span>
<span id="L953"><span class="lineNum">     953</span>                 :             :     // As this operator is only used in std::min_element, we want the result that has more inputs when waste are equal.</span>
<span id="L954"><span class="lineNum">     954</span>   [<span class="tlaGBC" title="Branch 0 was taken 216 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 111 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 105 times"> + </span> :<span class="tlaGNC">         216 :     return *m_waste &lt; *other.m_waste || (*m_waste == *other.m_waste &amp;&amp; m_selected_inputs.size() &gt; other.m_selected_inputs.size());</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 91 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 20 times"> + </span>]
<span id="L955"><span class="lineNum">     955</span>                 :             : }</span>
<span id="L956"><span class="lineNum">     956</span>                 :             : </span>
<span id="L957"><span class="lineNum">     957</span>                 :<span class="tlaUNC tlaBgUNC">           0 : std::string COutput::ToString() const</span></span>
<span id="L958"><span class="lineNum">     958</span>                 :             : {</span>
<span id="L959"><span class="lineNum">     959</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return strprintf(&quot;COutput(%s, %d, %d) [%s]&quot;, outpoint.hash.ToString(), outpoint.n, depth, FormatMoney(txout.nValue));</span></span>
<span id="L960"><span class="lineNum">     960</span>                 :             : }</span>
<span id="L961"><span class="lineNum">     961</span>                 :             : </span>
<span id="L962"><span class="lineNum">     962</span>                 :<span class="tlaGNC tlaBgGNC">          13 : std::string GetAlgorithmName(const SelectionAlgorithm algo)</span></span>
<span id="L963"><span class="lineNum">     963</span>                 :             : {</span>
<span id="L964"><span class="lineNum">     964</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 13 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          13 :     switch (algo)</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L965"><span class="lineNum">     965</span>                 :             :     {</span>
<span id="L966"><span class="lineNum">     966</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     case SelectionAlgorithm::BNB: return &quot;bnb&quot;;</span></span>
<span id="L967"><span class="lineNum">     967</span>                 :<span class="tlaGNC tlaBgGNC">          13 :     case SelectionAlgorithm::KNAPSACK: return &quot;knapsack&quot;;</span></span>
<span id="L968"><span class="lineNum">     968</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     case SelectionAlgorithm::SRD: return &quot;srd&quot;;</span></span>
<span id="L969"><span class="lineNum">     969</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::CG: return &quot;cg&quot;;</span></span>
<span id="L970"><span class="lineNum">     970</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::MANUAL: return &quot;manual&quot;;</span></span>
<span id="L971"><span class="lineNum">     971</span>                 :             :     // No default case to allow for compiler to warn</span>
<span id="L972"><span class="lineNum">     972</span>                 :             :     }</span>
<span id="L973"><span class="lineNum">     973</span>                 :<span class="tlaUNC">           0 :     assert(false);</span></span>
<span id="L974"><span class="lineNum">     974</span>                 :             : }</span>
<span id="L975"><span class="lineNum">     975</span>                 :             : </span>
<span id="L976"><span class="lineNum">     976</span>                 :<span class="tlaGNC tlaBgGNC">         481 : CAmount SelectionResult::GetChange(const CAmount min_viable_change, const CAmount change_fee) const</span></span>
<span id="L977"><span class="lineNum">     977</span>                 :             : {</span>
<span id="L978"><span class="lineNum">     978</span>                 :             :     // change = SUM(inputs) - SUM(outputs) - fees</span>
<span id="L979"><span class="lineNum">     979</span>                 :             :     // 1) With SFFO we don't pay any fees</span>
<span id="L980"><span class="lineNum">     980</span>                 :             :     // 2) Otherwise we pay all the fees:</span>
<span id="L981"><span class="lineNum">     981</span>                 :             :     //  - input fees are covered by GetSelectedEffectiveValue()</span>
<span id="L982"><span class="lineNum">     982</span>                 :             :     //  - non_input_fee is included in m_target</span>
<span id="L983"><span class="lineNum">     983</span>                 :             :     //  - change_fee</span>
<span id="L984"><span class="lineNum">     984</span>                 :<span class="tlaGNC">         481 :     const CAmount change = m_use_effective</span></span>
<span id="L985"><span class="lineNum">     985</span>         [<span class="tlaGBC" title="Branch 0 was taken 450 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 31 times"> + </span>]:<span class="tlaGNC">         481 :                            ? GetSelectedEffectiveValue() - m_target - change_fee</span></span>
<span id="L986"><span class="lineNum">     986</span>                 :<span class="tlaGNC">          31 :                            : GetSelectedValue() - m_target;</span></span>
<span id="L987"><span class="lineNum">     987</span>                 :             : </span>
<span id="L988"><span class="lineNum">     988</span>         [<span class="tlaGBC" title="Branch 0 was taken 345 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 136 times"> + </span>]:<span class="tlaGNC">         481 :     if (change &lt; min_viable_change) {</span></span>
<span id="L989"><span class="lineNum">     989</span>                 :<span class="tlaGNC">         345 :         return 0;</span></span>
<span id="L990"><span class="lineNum">     990</span>                 :             :     }</span>
<span id="L991"><span class="lineNum">     991</span>                 :             : </span>
<span id="L992"><span class="lineNum">     992</span>                 :             :     return change;</span>
<span id="L993"><span class="lineNum">     993</span>                 :             : }</span>
<span id="L994"><span class="lineNum">     994</span>                 :             : </span>
<span id="L995"><span class="lineNum">     995</span>                 :             : } // namespace wallet</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
