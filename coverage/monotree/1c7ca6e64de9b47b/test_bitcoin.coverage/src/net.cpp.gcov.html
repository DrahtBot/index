<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - test_bitcoin_coverage.info - src/net.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../index.html" title="Click to go to top-level">top level</a> - <a href="index.html" title="Click to go to directory src">src</a> - net.cpp<span style="font-size: 80%;"> (source / <a href="net.cpp.func-c.html" title="Click to go to function table">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">test_bitcoin_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryLo">40.5&nbsp;%</td>
            <td class="headerCovTableEntry">2091</td>
            <td class="headerCovTableEntry">847</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2024-10-28 13:38:31</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryLo">53.2&nbsp;%</td>
            <td class="headerCovTableEntry">156</td>
            <td class="headerCovTableEntry">83</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntryLo">20.3&nbsp;%</td>
            <td class="headerCovTableEntry">2743</td>
            <td class="headerCovTableEntry">556</td>
          </tr>
                  <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">             Branch data     Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>                 :             : // Copyright (c) 2009-2010 Satoshi Nakamoto</span>
<span id="L2"><span class="lineNum">       2</span>                 :             : // Copyright (c) 2009-2022 The Bitcoin Core developers</span>
<span id="L3"><span class="lineNum">       3</span>                 :             : // Distributed under the MIT software license, see the accompanying</span>
<span id="L4"><span class="lineNum">       4</span>                 :             : // file COPYING or http://www.opensource.org/licenses/mit-license.php.</span>
<span id="L5"><span class="lineNum">       5</span>                 :             : </span>
<span id="L6"><span class="lineNum">       6</span>                 :             : #include &lt;bitcoin-build-config.h&gt; // IWYU pragma: keep</span>
<span id="L7"><span class="lineNum">       7</span>                 :             : </span>
<span id="L8"><span class="lineNum">       8</span>                 :             : #include &lt;net.h&gt;</span>
<span id="L9"><span class="lineNum">       9</span>                 :             : </span>
<span id="L10"><span class="lineNum">      10</span>                 :             : #include &lt;addrdb.h&gt;</span>
<span id="L11"><span class="lineNum">      11</span>                 :             : #include &lt;addrman.h&gt;</span>
<span id="L12"><span class="lineNum">      12</span>                 :             : #include &lt;banman.h&gt;</span>
<span id="L13"><span class="lineNum">      13</span>                 :             : #include &lt;clientversion.h&gt;</span>
<span id="L14"><span class="lineNum">      14</span>                 :             : #include &lt;common/args.h&gt;</span>
<span id="L15"><span class="lineNum">      15</span>                 :             : #include &lt;common/netif.h&gt;</span>
<span id="L16"><span class="lineNum">      16</span>                 :             : #include &lt;compat/compat.h&gt;</span>
<span id="L17"><span class="lineNum">      17</span>                 :             : #include &lt;consensus/consensus.h&gt;</span>
<span id="L18"><span class="lineNum">      18</span>                 :             : #include &lt;crypto/sha256.h&gt;</span>
<span id="L19"><span class="lineNum">      19</span>                 :             : #include &lt;i2p.h&gt;</span>
<span id="L20"><span class="lineNum">      20</span>                 :             : #include &lt;key.h&gt;</span>
<span id="L21"><span class="lineNum">      21</span>                 :             : #include &lt;logging.h&gt;</span>
<span id="L22"><span class="lineNum">      22</span>                 :             : #include &lt;memusage.h&gt;</span>
<span id="L23"><span class="lineNum">      23</span>                 :             : #include &lt;net_permissions.h&gt;</span>
<span id="L24"><span class="lineNum">      24</span>                 :             : #include &lt;netaddress.h&gt;</span>
<span id="L25"><span class="lineNum">      25</span>                 :             : #include &lt;netbase.h&gt;</span>
<span id="L26"><span class="lineNum">      26</span>                 :             : #include &lt;node/eviction.h&gt;</span>
<span id="L27"><span class="lineNum">      27</span>                 :             : #include &lt;node/interface_ui.h&gt;</span>
<span id="L28"><span class="lineNum">      28</span>                 :             : #include &lt;protocol.h&gt;</span>
<span id="L29"><span class="lineNum">      29</span>                 :             : #include &lt;random.h&gt;</span>
<span id="L30"><span class="lineNum">      30</span>                 :             : #include &lt;scheduler.h&gt;</span>
<span id="L31"><span class="lineNum">      31</span>                 :             : #include &lt;util/fs.h&gt;</span>
<span id="L32"><span class="lineNum">      32</span>                 :             : #include &lt;util/sock.h&gt;</span>
<span id="L33"><span class="lineNum">      33</span>                 :             : #include &lt;util/strencodings.h&gt;</span>
<span id="L34"><span class="lineNum">      34</span>                 :             : #include &lt;util/thread.h&gt;</span>
<span id="L35"><span class="lineNum">      35</span>                 :             : #include &lt;util/threadinterrupt.h&gt;</span>
<span id="L36"><span class="lineNum">      36</span>                 :             : #include &lt;util/trace.h&gt;</span>
<span id="L37"><span class="lineNum">      37</span>                 :             : #include &lt;util/translation.h&gt;</span>
<span id="L38"><span class="lineNum">      38</span>                 :             : #include &lt;util/vector.h&gt;</span>
<span id="L39"><span class="lineNum">      39</span>                 :             : </span>
<span id="L40"><span class="lineNum">      40</span>                 :             : #ifdef WIN32</span>
<span id="L41"><span class="lineNum">      41</span>                 :             : #include &lt;string.h&gt;</span>
<span id="L42"><span class="lineNum">      42</span>                 :             : #endif</span>
<span id="L43"><span class="lineNum">      43</span>                 :             : </span>
<span id="L44"><span class="lineNum">      44</span>                 :             : #if HAVE_DECL_GETIFADDRS &amp;&amp; HAVE_DECL_FREEIFADDRS</span>
<span id="L45"><span class="lineNum">      45</span>                 :             : #include &lt;ifaddrs.h&gt;</span>
<span id="L46"><span class="lineNum">      46</span>                 :             : #endif</span>
<span id="L47"><span class="lineNum">      47</span>                 :             : </span>
<span id="L48"><span class="lineNum">      48</span>                 :             : #include &lt;algorithm&gt;</span>
<span id="L49"><span class="lineNum">      49</span>                 :             : #include &lt;array&gt;</span>
<span id="L50"><span class="lineNum">      50</span>                 :             : #include &lt;cmath&gt;</span>
<span id="L51"><span class="lineNum">      51</span>                 :             : #include &lt;cstdint&gt;</span>
<span id="L52"><span class="lineNum">      52</span>                 :             : #include &lt;functional&gt;</span>
<span id="L53"><span class="lineNum">      53</span>                 :             : #include &lt;optional&gt;</span>
<span id="L54"><span class="lineNum">      54</span>                 :             : #include &lt;unordered_map&gt;</span>
<span id="L55"><span class="lineNum">      55</span>                 :             : </span>
<span id="L56"><span class="lineNum">      56</span>                 :             : /** Maximum number of block-relay-only anchor connections */</span>
<span id="L57"><span class="lineNum">      57</span>                 :             : static constexpr size_t MAX_BLOCK_RELAY_ONLY_ANCHORS = 2;</span>
<span id="L58"><span class="lineNum">      58</span>                 :             : static_assert (MAX_BLOCK_RELAY_ONLY_ANCHORS &lt;= static_cast&lt;size_t&gt;(MAX_BLOCK_RELAY_ONLY_CONNECTIONS), &quot;MAX_BLOCK_RELAY_ONLY_ANCHORS must not exceed MAX_BLOCK_RELAY_ONLY_CONNECTIONS.&quot;);</span>
<span id="L59"><span class="lineNum">      59</span>                 :             : /** Anchor IP address database file name */</span>
<span id="L60"><span class="lineNum">      60</span>                 :             : const char* const ANCHORS_DATABASE_FILENAME = &quot;anchors.dat&quot;;</span>
<span id="L61"><span class="lineNum">      61</span>                 :             : </span>
<span id="L62"><span class="lineNum">      62</span>                 :             : // How often to dump addresses to peers.dat</span>
<span id="L63"><span class="lineNum">      63</span>                 :             : static constexpr std::chrono::minutes DUMP_PEERS_INTERVAL{15};</span>
<span id="L64"><span class="lineNum">      64</span>                 :             : </span>
<span id="L65"><span class="lineNum">      65</span>                 :             : /** Number of DNS seeds to query when the number of connections is low. */</span>
<span id="L66"><span class="lineNum">      66</span>                 :             : static constexpr int DNSSEEDS_TO_QUERY_AT_ONCE = 3;</span>
<span id="L67"><span class="lineNum">      67</span>                 :             : </span>
<span id="L68"><span class="lineNum">      68</span>                 :             : /** Minimum number of outbound connections under which we will keep fetching our address seeds. */</span>
<span id="L69"><span class="lineNum">      69</span>                 :             : static constexpr int SEED_OUTBOUND_CONNECTION_THRESHOLD = 2;</span>
<span id="L70"><span class="lineNum">      70</span>                 :             : </span>
<span id="L71"><span class="lineNum">      71</span>                 :             : /** How long to delay before querying DNS seeds</span>
<span id="L72"><span class="lineNum">      72</span>                 :             :  *</span>
<span id="L73"><span class="lineNum">      73</span>                 :             :  * If we have more than THRESHOLD entries in addrman, then it's likely</span>
<span id="L74"><span class="lineNum">      74</span>                 :             :  * that we got those addresses from having previously connected to the P2P</span>
<span id="L75"><span class="lineNum">      75</span>                 :             :  * network, and that we'll be able to successfully reconnect to the P2P</span>
<span id="L76"><span class="lineNum">      76</span>                 :             :  * network via contacting one of them. So if that's the case, spend a</span>
<span id="L77"><span class="lineNum">      77</span>                 :             :  * little longer trying to connect to known peers before querying the</span>
<span id="L78"><span class="lineNum">      78</span>                 :             :  * DNS seeds.</span>
<span id="L79"><span class="lineNum">      79</span>                 :             :  */</span>
<span id="L80"><span class="lineNum">      80</span>                 :             : static constexpr std::chrono::seconds DNSSEEDS_DELAY_FEW_PEERS{11};</span>
<span id="L81"><span class="lineNum">      81</span>                 :             : static constexpr std::chrono::minutes DNSSEEDS_DELAY_MANY_PEERS{5};</span>
<span id="L82"><span class="lineNum">      82</span>                 :             : static constexpr int DNSSEEDS_DELAY_PEER_THRESHOLD = 1000; // &quot;many&quot; vs &quot;few&quot; peers</span>
<span id="L83"><span class="lineNum">      83</span>                 :             : </span>
<span id="L84"><span class="lineNum">      84</span>                 :             : /** The default timeframe for -maxuploadtarget. 1 day. */</span>
<span id="L85"><span class="lineNum">      85</span>                 :             : static constexpr std::chrono::seconds MAX_UPLOAD_TIMEFRAME{60 * 60 * 24};</span>
<span id="L86"><span class="lineNum">      86</span>                 :             : </span>
<span id="L87"><span class="lineNum">      87</span>                 :             : // A random time period (0 to 1 seconds) is added to feeler connections to prevent synchronization.</span>
<span id="L88"><span class="lineNum">      88</span>                 :             : static constexpr auto FEELER_SLEEP_WINDOW{1s};</span>
<span id="L89"><span class="lineNum">      89</span>                 :             : </span>
<span id="L90"><span class="lineNum">      90</span>                 :             : /** Frequency to attempt extra connections to reachable networks we're not connected to yet **/</span>
<span id="L91"><span class="lineNum">      91</span>                 :             : static constexpr auto EXTRA_NETWORK_PEER_INTERVAL{5min};</span>
<span id="L92"><span class="lineNum">      92</span>                 :             : </span>
<span id="L93"><span class="lineNum">      93</span>                 :             : /** Used to pass flags to the Bind() function */</span>
<span id="L94"><span class="lineNum">      94</span>                 :             : enum BindFlags {</span>
<span id="L95"><span class="lineNum">      95</span>                 :             :     BF_NONE         = 0,</span>
<span id="L96"><span class="lineNum">      96</span>                 :             :     BF_REPORT_ERROR = (1U &lt;&lt; 0),</span>
<span id="L97"><span class="lineNum">      97</span>                 :             :     /**</span>
<span id="L98"><span class="lineNum">      98</span>                 :             :      * Do not call AddLocal() for our special addresses, e.g., for incoming</span>
<span id="L99"><span class="lineNum">      99</span>                 :             :      * Tor connections, to prevent gossiping them over the network.</span>
<span id="L100"><span class="lineNum">     100</span>                 :             :      */</span>
<span id="L101"><span class="lineNum">     101</span>                 :             :     BF_DONT_ADVERTISE = (1U &lt;&lt; 1),</span>
<span id="L102"><span class="lineNum">     102</span>                 :             : };</span>
<span id="L103"><span class="lineNum">     103</span>                 :             : </span>
<span id="L104"><span class="lineNum">     104</span>                 :             : // The set of sockets cannot be modified while waiting</span>
<span id="L105"><span class="lineNum">     105</span>                 :             : // The sleep time needs to be small to avoid new sockets stalling</span>
<span id="L106"><span class="lineNum">     106</span>                 :             : static const uint64_t SELECT_TIMEOUT_MILLISECONDS = 50;</span>
<span id="L107"><span class="lineNum">     107</span>                 :             : </span>
<span id="L108"><span class="lineNum">     108</span>                 :             : const std::string NET_MESSAGE_TYPE_OTHER = &quot;*other*&quot;;</span>
<span id="L109"><span class="lineNum">     109</span>                 :             : </span>
<span id="L110"><span class="lineNum">     110</span>                 :             : static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(&quot;netgroup&quot;)[0:8]</span>
<span id="L111"><span class="lineNum">     111</span>                 :             : static const uint64_t RANDOMIZER_ID_LOCALHOSTNONCE = 0xd93e69e2bbfa5735ULL; // SHA256(&quot;localhostnonce&quot;)[0:8]</span>
<span id="L112"><span class="lineNum">     112</span>                 :             : static const uint64_t RANDOMIZER_ID_ADDRCACHE = 0x1cf2e4ddd306dda9ULL; // SHA256(&quot;addrcache&quot;)[0:8]</span>
<span id="L113"><span class="lineNum">     113</span>                 :             : //</span>
<span id="L114"><span class="lineNum">     114</span>                 :             : // Global state variables</span>
<span id="L115"><span class="lineNum">     115</span>                 :             : //</span>
<span id="L116"><span class="lineNum">     116</span>                 :             : bool fDiscover = true;</span>
<span id="L117"><span class="lineNum">     117</span>                 :             : bool fListen = true;</span>
<span id="L118"><span class="lineNum">     118</span>                 :             : GlobalMutex g_maplocalhost_mutex;</span>
<span id="L119"><span class="lineNum">     119</span>                 :             : std::map&lt;CNetAddr, LocalServiceInfo&gt; mapLocalHost GUARDED_BY(g_maplocalhost_mutex);</span>
<span id="L120"><span class="lineNum">     120</span>                 :             : std::string strSubVersion;</span>
<span id="L121"><span class="lineNum">     121</span>                 :             : </span>
<span id="L122"><span class="lineNum">     122</span>                 :<span class="tlaGNC tlaBgGNC">          56 : size_t CSerializedNetMsg::GetMemoryUsage() const noexcept</span></span>
<span id="L123"><span class="lineNum">     123</span>                 :             : {</span>
<span id="L124"><span class="lineNum">     124</span>                 :             :     // Don't count the dynamic memory used for the m_type string, by assuming it fits in the</span>
<span id="L125"><span class="lineNum">     125</span>                 :             :     // &quot;small string&quot; optimization area (which stores data inside the object itself, up to some</span>
<span id="L126"><span class="lineNum">     126</span>                 :             :     // size; 15 bytes in modern libstdc++).</span>
<span id="L127"><span class="lineNum">     127</span>         [<span class="tlaGBC" title="Branch 0 was taken 26 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 30 times"> + </span>]:<span class="tlaGNC">          56 :     return sizeof(*this) + memusage::DynamicUsage(data);</span></span>
<span id="L128"><span class="lineNum">     128</span>                 :             : }</span>
<span id="L129"><span class="lineNum">     129</span>                 :             : </span>
<span id="L130"><span class="lineNum">     130</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CConnman::AddAddrFetch(const std::string&amp; strDest)</span></span>
<span id="L131"><span class="lineNum">     131</span>                 :             : {</span>
<span id="L132"><span class="lineNum">     132</span>                 :<span class="tlaUNC">           0 :     LOCK(m_addr_fetches_mutex);</span></span>
<span id="L133"><span class="lineNum">     133</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     m_addr_fetches.push_back(strDest);</span></span>
<span id="L134"><span class="lineNum">     134</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L135"><span class="lineNum">     135</span>                 :             : </span>
<span id="L136"><span class="lineNum">     136</span>                 :<span class="tlaGNC tlaBgGNC">          27 : uint16_t GetListenPort()</span></span>
<span id="L137"><span class="lineNum">     137</span>                 :             : {</span>
<span id="L138"><span class="lineNum">     138</span>                 :             :     // If -bind= is provided with &quot;:port&quot; part, use that (first one if multiple are provided).</span>
<span id="L139"><span class="lineNum">     139</span>   [<span class="tlaGBC" title="Branch 0 was taken 27 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 24 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 24 times"> + </span>]:<span class="tlaGNC">          48 :     for (const std::string&amp; bind_arg : gArgs.GetArgs(&quot;-bind&quot;)) {</span></span>
<span id="L140"><span class="lineNum">     140</span>                 :<span class="tlaGNC">          24 :         constexpr uint16_t dummy_port = 0;</span></span>
<span id="L141"><span class="lineNum">     141</span>                 :             : </span>
<span id="L142"><span class="lineNum">     142</span>   [<span class="tlaGBC" title="Branch 0 was taken 24 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 24 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          24 :         const std::optional&lt;CService&gt; bind_addr{Lookup(bind_arg, dummy_port, /*fAllowLookup=*/false)};</span></span>
<span id="L143"><span class="lineNum">     143</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 21 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          24 :         if (bind_addr.has_value() &amp;&amp; bind_addr-&gt;GetPort() != dummy_port) return bind_addr-&gt;GetPort();</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L144"><span class="lineNum">     144</span>                 :<span class="tlaGNC">          48 :     }</span></span>
<span id="L145"><span class="lineNum">     145</span>                 :             : </span>
<span id="L146"><span class="lineNum">     146</span>                 :             :     // Otherwise, if -whitebind= without NetPermissionFlags::NoBan is provided, use that</span>
<span id="L147"><span class="lineNum">     147</span>                 :             :     // (-whitebind= is required to have &quot;:port&quot;).</span>
<span id="L148"><span class="lineNum">     148</span>   [<span class="tlaGBC" title="Branch 0 was taken 24 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 24 times"> + </span>]:<span class="tlaGNC">          24 :     for (const std::string&amp; whitebind_arg : gArgs.GetArgs(&quot;-whitebind&quot;)) {</span></span>
<span id="L149"><span class="lineNum">     149</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         NetWhitebindPermissions whitebind;</span></span>
<span id="L150"><span class="lineNum">     150</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         bilingual_str error;</span></span>
<span id="L151"><span class="lineNum">     151</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (NetWhitebindPermissions::TryParse(whitebind_arg, whitebind, error)) {</span></span>
<span id="L152"><span class="lineNum">     152</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!NetPermissions::HasFlag(whitebind.m_flags, NetPermissionFlags::NoBan)) {</span></span>
<span id="L153"><span class="lineNum">     153</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 return whitebind.m_service.GetPort();</span></span>
<span id="L154"><span class="lineNum">     154</span>                 :             :             }</span>
<span id="L155"><span class="lineNum">     155</span>                 :             :         }</span>
<span id="L156"><span class="lineNum">     156</span>                 :<span class="tlaGNC tlaBgGNC">          24 :     }</span></span>
<span id="L157"><span class="lineNum">     157</span>                 :             : </span>
<span id="L158"><span class="lineNum">     158</span>                 :             :     // Otherwise, if -port= is provided, use that. Otherwise use the default port.</span>
<span id="L159"><span class="lineNum">     159</span>         [<span class="tlaGBC" title="Branch 0 was taken 24 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          24 :     return static_cast&lt;uint16_t&gt;(gArgs.GetIntArg(&quot;-port&quot;, Params().GetDefaultPort()));</span></span>
<span id="L160"><span class="lineNum">     160</span>                 :             : }</span>
<span id="L161"><span class="lineNum">     161</span>                 :             : </span>
<span id="L162"><span class="lineNum">     162</span>                 :             : // Determine the &quot;best&quot; local address for a particular peer.</span>
<span id="L163"><span class="lineNum">     163</span>                 :<span class="tlaGNC">          25 : [[nodiscard]] static std::optional&lt;CService&gt; GetLocal(const CNode&amp; peer)</span></span>
<span id="L164"><span class="lineNum">     164</span>                 :             : {</span>
<span id="L165"><span class="lineNum">     165</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 25 times"> + </span>]:<span class="tlaGNC">          25 :     if (!fListen) return std::nullopt;</span></span>
<span id="L166"><span class="lineNum">     166</span>                 :             : </span>
<span id="L167"><span class="lineNum">     167</span>                 :<span class="tlaGNC">          25 :     std::optional&lt;CService&gt; addr;</span></span>
<span id="L168"><span class="lineNum">     168</span>                 :<span class="tlaGNC">          25 :     int nBestScore = -1;</span></span>
<span id="L169"><span class="lineNum">     169</span>                 :<span class="tlaGNC">          25 :     int nBestReachability = -1;</span></span>
<span id="L170"><span class="lineNum">     170</span>                 :<span class="tlaGNC">          25 :     {</span></span>
<span id="L171"><span class="lineNum">     171</span>         [<span class="tlaGBC" title="Branch 0 was taken 25 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          25 :         LOCK(g_maplocalhost_mutex);</span></span>
<span id="L172"><span class="lineNum">     172</span>   [<span class="tlaGBC" title="Branch 0 was taken 71 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 71 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 25 times"> + </span>]:<span class="tlaGNC">          96 :         for (const auto&amp; [local_addr, local_service_info] : mapLocalHost) {</span></span>
<span id="L173"><span class="lineNum">     173</span>                 :             :             // For privacy reasons, don't advertise our privacy-network address</span>
<span id="L174"><span class="lineNum">     174</span>                 :             :             // to other networks and don't advertise our other-network address</span>
<span id="L175"><span class="lineNum">     175</span>                 :             :             // to privacy networks.</span>
<span id="L176"><span class="lineNum">     176</span>   [<span class="tlaGBC" title="Branch 0 was taken 71 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 71 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          71 :             if (local_addr.GetNetwork() != peer.ConnectedThroughNetwork()</span></span>
<span id="L177"><span class="lineNum">     177</span>   [<span class="tlaGBC" title="Branch 0 was taken 57 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 14 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 33 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">         104 :                 &amp;&amp; (local_addr.IsPrivacyNet() || peer.IsConnectedThroughPrivacyNet())) {</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 12 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 21 times"> + </span>]
<span id="L178"><span class="lineNum">     178</span>                 :<span class="tlaGNC">          36 :                 continue;</span></span>
<span id="L179"><span class="lineNum">     179</span>                 :             :             }</span>
<span id="L180"><span class="lineNum">     180</span>                 :<span class="tlaGNC">          35 :             const int nScore{local_service_info.nScore};</span></span>
<span id="L181"><span class="lineNum">     181</span>         [<span class="tlaGBC" title="Branch 0 was taken 35 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          35 :             const int nReachability{local_addr.GetReachabilityFrom(peer.addr)};</span></span>
<span id="L182"><span class="lineNum">     182</span>   [<span class="tlaGBC" title="Branch 0 was taken 17 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 18 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 17 times"> + </span>]:<span class="tlaGNC">          35 :             if (nReachability &gt; nBestReachability || (nReachability == nBestReachability &amp;&amp; nScore &gt; nBestScore)) {</span></span>
<span id="L183"><span class="lineNum">     183</span>         [<span class="tlaGBC" title="Branch 0 was taken 18 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          18 :                 addr.emplace(CService{local_addr, local_service_info.nPort});</span></span>
<span id="L184"><span class="lineNum">     184</span>                 :<span class="tlaGNC">          18 :                 nBestReachability = nReachability;</span></span>
<span id="L185"><span class="lineNum">     185</span>                 :<span class="tlaGNC">          18 :                 nBestScore = nScore;</span></span>
<span id="L186"><span class="lineNum">     186</span>                 :             :             }</span>
<span id="L187"><span class="lineNum">     187</span>                 :             :         }</span>
<span id="L188"><span class="lineNum">     188</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     }</span></span>
<span id="L189"><span class="lineNum">     189</span>         [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC tlaBgGNC">          40 :     return addr;</span></span>
<span id="L190"><span class="lineNum">     190</span>                 :<span class="tlaGNC">          25 : }</span></span>
<span id="L191"><span class="lineNum">     191</span>                 :             : </span>
<span id="L192"><span class="lineNum">     192</span>                 :             : //! Convert the serialized seeds into usable address objects.</span>
<span id="L193"><span class="lineNum">     193</span>                 :<span class="tlaUNC tlaBgUNC">           0 : static std::vector&lt;CAddress&gt; ConvertSeeds(const std::vector&lt;uint8_t&gt; &amp;vSeedsIn)</span></span>
<span id="L194"><span class="lineNum">     194</span>                 :             : {</span>
<span id="L195"><span class="lineNum">     195</span>                 :             :     // It'll only connect to one or two seed nodes because once it connects,</span>
<span id="L196"><span class="lineNum">     196</span>                 :             :     // it'll get a pile of addresses with newer timestamps.</span>
<span id="L197"><span class="lineNum">     197</span>                 :             :     // Seed nodes are given a random 'last seen time' of between one and two</span>
<span id="L198"><span class="lineNum">     198</span>                 :             :     // weeks ago.</span>
<span id="L199"><span class="lineNum">     199</span>                 :<span class="tlaUNC">           0 :     const auto one_week{7 * 24h};</span></span>
<span id="L200"><span class="lineNum">     200</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;CAddress&gt; vSeedsOut;</span></span>
<span id="L201"><span class="lineNum">     201</span>                 :<span class="tlaUNC">           0 :     FastRandomContext rng;</span></span>
<span id="L202"><span class="lineNum">     202</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     ParamsStream s{DataStream{vSeedsIn}, CAddress::V2_NETWORK};</span></span>
<span id="L203"><span class="lineNum">     203</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     while (!s.eof()) {</span></span>
<span id="L204"><span class="lineNum">     204</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         CService endpoint;</span></span>
<span id="L205"><span class="lineNum">     205</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         s &gt;&gt; endpoint;</span></span>
<span id="L206"><span class="lineNum">     206</span>                 :<span class="tlaUNC">           0 :         CAddress addr{endpoint, SeedsServiceFlags()};</span></span>
<span id="L207"><span class="lineNum">     207</span>                 :<span class="tlaUNC">           0 :         addr.nTime = rng.rand_uniform_delay(Now&lt;NodeSeconds&gt;() - one_week, -one_week);</span></span>
<span id="L208"><span class="lineNum">     208</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;Added hardcoded seed: %s\n&quot;, addr.ToStringAddrPort());</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L209"><span class="lineNum">     209</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         vSeedsOut.push_back(addr);</span></span>
<span id="L210"><span class="lineNum">     210</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L211"><span class="lineNum">     211</span>                 :<span class="tlaUNC">           0 :     return vSeedsOut;</span></span>
<span id="L212"><span class="lineNum">     212</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L213"><span class="lineNum">     213</span>                 :             : </span>
<span id="L214"><span class="lineNum">     214</span>                 :             : // Determine the &quot;best&quot; local address for a particular peer.</span>
<span id="L215"><span class="lineNum">     215</span>                 :             : // If none, return the unroutable 0.0.0.0 but filled in with</span>
<span id="L216"><span class="lineNum">     216</span>                 :             : // the normal parameters, since the IP may be changed to a useful</span>
<span id="L217"><span class="lineNum">     217</span>                 :             : // one by discovery.</span>
<span id="L218"><span class="lineNum">     218</span>                 :<span class="tlaGNC tlaBgGNC">          25 : CService GetLocalAddress(const CNode&amp; peer)</span></span>
<span id="L219"><span class="lineNum">     219</span>                 :             : {</span>
<span id="L220"><span class="lineNum">     220</span>   [<span class="tlaGBC" title="Branch 0 was taken 25 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 25 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          25 :     return GetLocal(peer).value_or(CService{CNetAddr(), GetListenPort()});</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 25 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L221"><span class="lineNum">     221</span>                 :             : }</span>
<span id="L222"><span class="lineNum">     222</span>                 :             : </span>
<span id="L223"><span class="lineNum">     223</span>                 :<span class="tlaUNC tlaBgUNC">           0 : static int GetnScore(const CService&amp; addr)</span></span>
<span id="L224"><span class="lineNum">     224</span>                 :             : {</span>
<span id="L225"><span class="lineNum">     225</span>                 :<span class="tlaUNC">           0 :     LOCK(g_maplocalhost_mutex);</span></span>
<span id="L226"><span class="lineNum">     226</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const auto it = mapLocalHost.find(addr);</span></span>
<span id="L227"><span class="lineNum">     227</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return (it != mapLocalHost.end()) ? it-&gt;second.nScore : 0;</span></span>
<span id="L228"><span class="lineNum">     228</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L229"><span class="lineNum">     229</span>                 :             : </span>
<span id="L230"><span class="lineNum">     230</span>                 :             : // Is our peer's addrLocal potentially useful as an external IP source?</span>
<span id="L231"><span class="lineNum">     231</span>                 :<span class="tlaGNC tlaBgGNC">           4 : [[nodiscard]] static bool IsPeerAddrLocalGood(CNode *pnode)</span></span>
<span id="L232"><span class="lineNum">     232</span>                 :             : {</span>
<span id="L233"><span class="lineNum">     233</span>                 :<span class="tlaGNC">           4 :     CService addrLocal = pnode-&gt;GetAddrLocal();</span></span>
<span id="L234"><span class="lineNum">     234</span>   [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           8 :     return fDiscover &amp;&amp; pnode-&gt;addr.IsRoutable() &amp;&amp; addrLocal.IsRoutable() &amp;&amp;</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span><span class="tlaGBC" title="Branch 8 was taken 4 times"> + </span> 
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 9 was not taken"> - </span><span class="tlaUNC" title="Branch 10 was not taken"> - </span><span class="tlaGBC" title="Branch 11 was taken 4 times"> + </span>]
<span id="L235"><span class="lineNum">     235</span>         [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           8 :            g_reachable_nets.Contains(addrLocal);</span></span>
<span id="L236"><span class="lineNum">     236</span>                 :<span class="tlaGNC">           4 : }</span></span>
<span id="L237"><span class="lineNum">     237</span>                 :             : </span>
<span id="L238"><span class="lineNum">     238</span>                 :<span class="tlaGNC">           4 : std::optional&lt;CService&gt; GetLocalAddrForPeer(CNode&amp; node)</span></span>
<span id="L239"><span class="lineNum">     239</span>                 :             : {</span>
<span id="L240"><span class="lineNum">     240</span>                 :<span class="tlaGNC">           4 :     CService addrLocal{GetLocalAddress(node)};</span></span>
<span id="L241"><span class="lineNum">     241</span>                 :             :     // If discovery is enabled, sometimes give our peer the address it</span>
<span id="L242"><span class="lineNum">     242</span>                 :             :     // tells us that it sees us as in case it has a better idea of our</span>
<span id="L243"><span class="lineNum">     243</span>                 :             :     // address than we do.</span>
<span id="L244"><span class="lineNum">     244</span>                 :<span class="tlaGNC">           4 :     FastRandomContext rng;</span></span>
<span id="L245"><span class="lineNum">     245</span>   [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           4 :     if (IsPeerAddrLocalGood(&amp;node) &amp;&amp; (!addrLocal.IsRoutable() ||</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaGBC" title="Branch 7 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 8 was not taken"> - </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not taken"> - </span>]
<span id="L246"><span class="lineNum">     246</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :          rng.randbits((GetnScore(addrLocal) &gt; LOCAL_MANUAL) ? 3 : 1) == 0))</span></span>
<span id="L247"><span class="lineNum">     247</span>                 :             :     {</span>
<span id="L248"><span class="lineNum">     248</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC tlaBgGNC">           4 :         if (node.IsInboundConn()) {</span></span>
<span id="L249"><span class="lineNum">     249</span>                 :             :             // For inbound connections, assume both the address and the port</span>
<span id="L250"><span class="lineNum">     250</span>                 :             :             // as seen from the peer.</span>
<span id="L251"><span class="lineNum">     251</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :             addrLocal = CService{node.GetAddrLocal()};</span></span>
<span id="L252"><span class="lineNum">     252</span>                 :             :         } else {</span>
<span id="L253"><span class="lineNum">     253</span>                 :             :             // For outbound connections, assume just the address as seen from</span>
<span id="L254"><span class="lineNum">     254</span>                 :             :             // the peer and leave the port in `addrLocal` as returned by</span>
<span id="L255"><span class="lineNum">     255</span>                 :             :             // `GetLocalAddress()` above. The peer has no way to observe our</span>
<span id="L256"><span class="lineNum">     256</span>                 :             :             // listening port when we have initiated the connection.</span>
<span id="L257"><span class="lineNum">     257</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           6 :             addrLocal.SetIP(node.GetAddrLocal());</span></span>
<span id="L258"><span class="lineNum">     258</span>                 :             :         }</span>
<span id="L259"><span class="lineNum">     259</span>                 :             :     }</span>
<span id="L260"><span class="lineNum">     260</span>   [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           4 :     if (addrLocal.IsRoutable()) {</span></span>
<span id="L261"><span class="lineNum">     261</span>   [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           8 :         LogDebug(BCLog::NET, &quot;Advertising address %s to peer=%d\n&quot;, addrLocal.ToStringAddrPort(), node.GetId());</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L262"><span class="lineNum">     262</span>                 :<span class="tlaGNC">           4 :         return addrLocal;</span></span>
<span id="L263"><span class="lineNum">     263</span>                 :             :     }</span>
<span id="L264"><span class="lineNum">     264</span>                 :             :     // Address is unroutable. Don't advertise.</span>
<span id="L265"><span class="lineNum">     265</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     return std::nullopt;</span></span>
<span id="L266"><span class="lineNum">     266</span>                 :<span class="tlaGNC tlaBgGNC">           4 : }</span></span>
<span id="L267"><span class="lineNum">     267</span>                 :             : </span>
<span id="L268"><span class="lineNum">     268</span>                 :             : // learn a new local address</span>
<span id="L269"><span class="lineNum">     269</span>                 :<span class="tlaGNC">          11 : bool AddLocal(const CService&amp; addr_, int nScore)</span></span>
<span id="L270"><span class="lineNum">     270</span>                 :             : {</span>
<span id="L271"><span class="lineNum">     271</span>                 :<span class="tlaGNC">          11 :     CService addr{MaybeFlipIPv6toCJDNS(addr_)};</span></span>
<span id="L272"><span class="lineNum">     272</span>                 :             : </span>
<span id="L273"><span class="lineNum">     273</span>   [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :     if (!addr.IsRoutable())</span></span>
<span id="L274"><span class="lineNum">     274</span>                 :             :         return false;</span>
<span id="L275"><span class="lineNum">     275</span>                 :             : </span>
<span id="L276"><span class="lineNum">     276</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :     if (!fDiscover &amp;&amp; nScore &lt; LOCAL_MANUAL)</span></span>
<span id="L277"><span class="lineNum">     277</span>                 :             :         return false;</span>
<span id="L278"><span class="lineNum">     278</span>                 :             : </span>
<span id="L279"><span class="lineNum">     279</span>   [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :     if (!g_reachable_nets.Contains(addr))</span></span>
<span id="L280"><span class="lineNum">     280</span>                 :             :         return false;</span>
<span id="L281"><span class="lineNum">     281</span>                 :             : </span>
<span id="L282"><span class="lineNum">     282</span>   [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :     LogPrintf(&quot;AddLocal(%s,%i)\n&quot;, addr.ToStringAddrPort(), nScore);</span></span>
<span id="L283"><span class="lineNum">     283</span>                 :             : </span>
<span id="L284"><span class="lineNum">     284</span>                 :<span class="tlaGNC">          11 :     {</span></span>
<span id="L285"><span class="lineNum">     285</span>         [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          11 :         LOCK(g_maplocalhost_mutex);</span></span>
<span id="L286"><span class="lineNum">     286</span>   [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 11 times"> + </span>]:<span class="tlaGNC">          11 :         const auto [it, is_newly_added] = mapLocalHost.emplace(addr, LocalServiceInfo());</span></span>
<span id="L287"><span class="lineNum">     287</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 11 times"> + </span>]:<span class="tlaGNC">          11 :         LocalServiceInfo &amp;info = it-&gt;second;</span></span>
<span id="L288"><span class="lineNum">     288</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :         if (is_newly_added || nScore &gt;= info.nScore) {</span></span>
<span id="L289"><span class="lineNum">     289</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 11 times"> + </span>]:<span class="tlaGNC">          11 :             info.nScore = nScore + (is_newly_added ? 0 : 1);</span></span>
<span id="L290"><span class="lineNum">     290</span>         [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          11 :             info.nPort = addr.GetPort();</span></span>
<span id="L291"><span class="lineNum">     291</span>                 :             :         }</span>
<span id="L292"><span class="lineNum">     292</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     }</span></span>
<span id="L293"><span class="lineNum">     293</span>                 :             : </span>
<span id="L294"><span class="lineNum">     294</span>                 :<span class="tlaGNC tlaBgGNC">          11 :     return true;</span></span>
<span id="L295"><span class="lineNum">     295</span>                 :<span class="tlaGNC">          11 : }</span></span>
<span id="L296"><span class="lineNum">     296</span>                 :             : </span>
<span id="L297"><span class="lineNum">     297</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool AddLocal(const CNetAddr &amp;addr, int nScore)</span></span>
<span id="L298"><span class="lineNum">     298</span>                 :             : {</span>
<span id="L299"><span class="lineNum">     299</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return AddLocal(CService(addr, GetListenPort()), nScore);</span></span>
<span id="L300"><span class="lineNum">     300</span>                 :             : }</span>
<span id="L301"><span class="lineNum">     301</span>                 :             : </span>
<span id="L302"><span class="lineNum">     302</span>                 :<span class="tlaGNC tlaBgGNC">          11 : void RemoveLocal(const CService&amp; addr)</span></span>
<span id="L303"><span class="lineNum">     303</span>                 :             : {</span>
<span id="L304"><span class="lineNum">     304</span>                 :<span class="tlaGNC">          11 :     LOCK(g_maplocalhost_mutex);</span></span>
<span id="L305"><span class="lineNum">     305</span>   [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :     LogPrintf(&quot;RemoveLocal(%s)\n&quot;, addr.ToStringAddrPort());</span></span>
<span id="L306"><span class="lineNum">     306</span>   [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          11 :     mapLocalHost.erase(addr);</span></span>
<span id="L307"><span class="lineNum">     307</span>                 :<span class="tlaGNC">          11 : }</span></span>
<span id="L308"><span class="lineNum">     308</span>                 :             : </span>
<span id="L309"><span class="lineNum">     309</span>                 :             : /** vote for a local address */</span>
<span id="L310"><span class="lineNum">     310</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool SeenLocal(const CService&amp; addr)</span></span>
<span id="L311"><span class="lineNum">     311</span>                 :             : {</span>
<span id="L312"><span class="lineNum">     312</span>                 :<span class="tlaUNC">           0 :     LOCK(g_maplocalhost_mutex);</span></span>
<span id="L313"><span class="lineNum">     313</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const auto it = mapLocalHost.find(addr);</span></span>
<span id="L314"><span class="lineNum">     314</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (it == mapLocalHost.end()) return false;</span></span>
<span id="L315"><span class="lineNum">     315</span>                 :<span class="tlaUNC">           0 :     ++it-&gt;second.nScore;</span></span>
<span id="L316"><span class="lineNum">     316</span>                 :<span class="tlaUNC">           0 :     return true;</span></span>
<span id="L317"><span class="lineNum">     317</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L318"><span class="lineNum">     318</span>                 :             : </span>
<span id="L319"><span class="lineNum">     319</span>                 :             : </span>
<span id="L320"><span class="lineNum">     320</span>                 :             : /** check whether a given address is potentially local */</span>
<span id="L321"><span class="lineNum">     321</span>                 :<span class="tlaGNC tlaBgGNC">           3 : bool IsLocal(const CService&amp; addr)</span></span>
<span id="L322"><span class="lineNum">     322</span>                 :             : {</span>
<span id="L323"><span class="lineNum">     323</span>                 :<span class="tlaGNC">           3 :     LOCK(g_maplocalhost_mutex);</span></span>
<span id="L324"><span class="lineNum">     324</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           3 :     return mapLocalHost.count(addr) &gt; 0;</span></span>
<span id="L325"><span class="lineNum">     325</span>                 :<span class="tlaGNC">           3 : }</span></span>
<span id="L326"><span class="lineNum">     326</span>                 :             : </span>
<span id="L327"><span class="lineNum">     327</span>                 :<span class="tlaGNC">           6 : CNode* CConnman::FindNode(const CNetAddr&amp; ip)</span></span>
<span id="L328"><span class="lineNum">     328</span>                 :             : {</span>
<span id="L329"><span class="lineNum">     329</span>                 :<span class="tlaGNC">           6 :     LOCK(m_nodes_mutex);</span></span>
<span id="L330"><span class="lineNum">     330</span>         [<span class="tlaGBC" title="Branch 0 was taken 21 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          21 :     for (CNode* pnode : m_nodes) {</span></span>
<span id="L331"><span class="lineNum">     331</span>   [<span class="tlaGBC" title="Branch 0 was taken 21 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 15 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 6 times"> + </span>]:<span class="tlaGNC">          21 :       if (static_cast&lt;CNetAddr&gt;(pnode-&gt;addr) == ip) {</span></span>
<span id="L332"><span class="lineNum">     332</span>                 :             :             return pnode;</span>
<span id="L333"><span class="lineNum">     333</span>                 :             :         }</span>
<span id="L334"><span class="lineNum">     334</span>                 :             :     }</span>
<span id="L335"><span class="lineNum">     335</span>                 :             :     return nullptr;</span>
<span id="L336"><span class="lineNum">     336</span>                 :<span class="tlaGNC">           6 : }</span></span>
<span id="L337"><span class="lineNum">     337</span>                 :             : </span>
<span id="L338"><span class="lineNum">     338</span>                 :<span class="tlaUNC tlaBgUNC">           0 : CNode* CConnman::FindNode(const std::string&amp; addrName)</span></span>
<span id="L339"><span class="lineNum">     339</span>                 :             : {</span>
<span id="L340"><span class="lineNum">     340</span>                 :<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L341"><span class="lineNum">     341</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (CNode* pnode : m_nodes) {</span></span>
<span id="L342"><span class="lineNum">     342</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (pnode-&gt;m_addr_name == addrName) {</span></span>
<span id="L343"><span class="lineNum">     343</span>                 :             :             return pnode;</span>
<span id="L344"><span class="lineNum">     344</span>                 :             :         }</span>
<span id="L345"><span class="lineNum">     345</span>                 :             :     }</span>
<span id="L346"><span class="lineNum">     346</span>                 :             :     return nullptr;</span>
<span id="L347"><span class="lineNum">     347</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L348"><span class="lineNum">     348</span>                 :             : </span>
<span id="L349"><span class="lineNum">     349</span>                 :<span class="tlaGNC tlaBgGNC">          14 : CNode* CConnman::FindNode(const CService&amp; addr)</span></span>
<span id="L350"><span class="lineNum">     350</span>                 :             : {</span>
<span id="L351"><span class="lineNum">     351</span>                 :<span class="tlaGNC">          14 :     LOCK(m_nodes_mutex);</span></span>
<span id="L352"><span class="lineNum">     352</span>         [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 4 times"> + </span>]:<span class="tlaGNC">          18 :     for (CNode* pnode : m_nodes) {</span></span>
<span id="L353"><span class="lineNum">     353</span>   [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 4 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 10 times"> + </span>]:<span class="tlaGNC">          14 :         if (static_cast&lt;CService&gt;(pnode-&gt;addr) == addr) {</span></span>
<span id="L354"><span class="lineNum">     354</span>                 :             :             return pnode;</span>
<span id="L355"><span class="lineNum">     355</span>                 :             :         }</span>
<span id="L356"><span class="lineNum">     356</span>                 :             :     }</span>
<span id="L357"><span class="lineNum">     357</span>                 :             :     return nullptr;</span>
<span id="L358"><span class="lineNum">     358</span>                 :<span class="tlaGNC">          14 : }</span></span>
<span id="L359"><span class="lineNum">     359</span>                 :             : </span>
<span id="L360"><span class="lineNum">     360</span>                 :<span class="tlaGNC">           6 : bool CConnman::AlreadyConnectedToAddress(const CAddress&amp; addr)</span></span>
<span id="L361"><span class="lineNum">     361</span>                 :             : {</span>
<span id="L362"><span class="lineNum">     362</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 6 times"> + </span> :<span class="tlaGNC">          12 :     return FindNode(static_cast&lt;CNetAddr&gt;(addr)) || FindNode(addr.ToStringAddrPort());</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span><span class="tlaUNC" title="Branch 8 was not taken"> - </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not taken"> - </span>]
<span id="L363"><span class="lineNum">     363</span>                 :             : }</span>
<span id="L364"><span class="lineNum">     364</span>                 :             : </span>
<span id="L365"><span class="lineNum">     365</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::CheckIncomingNonce(uint64_t nonce)</span></span>
<span id="L366"><span class="lineNum">     366</span>                 :             : {</span>
<span id="L367"><span class="lineNum">     367</span>                 :<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L368"><span class="lineNum">     368</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const CNode* pnode : m_nodes) {</span></span>
<span id="L369"><span class="lineNum">     369</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         if (!pnode-&gt;fSuccessfullyConnected &amp;&amp; !pnode-&gt;IsInboundConn() &amp;&amp; pnode-&gt;GetLocalNonce() == nonce)</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L370"><span class="lineNum">     370</span>                 :             :             return false;</span>
<span id="L371"><span class="lineNum">     371</span>                 :             :     }</span>
<span id="L372"><span class="lineNum">     372</span>                 :             :     return true;</span>
<span id="L373"><span class="lineNum">     373</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L374"><span class="lineNum">     374</span>                 :             : </span>
<span id="L375"><span class="lineNum">     375</span>                 :             : /** Get the bind address for a socket as CAddress */</span>
<span id="L376"><span class="lineNum">     376</span>                 :<span class="tlaUNC">           0 : static CAddress GetBindAddress(const Sock&amp; sock)</span></span>
<span id="L377"><span class="lineNum">     377</span>                 :             : {</span>
<span id="L378"><span class="lineNum">     378</span>                 :<span class="tlaUNC">           0 :     CAddress addr_bind;</span></span>
<span id="L379"><span class="lineNum">     379</span>                 :<span class="tlaUNC">           0 :     struct sockaddr_storage sockaddr_bind;</span></span>
<span id="L380"><span class="lineNum">     380</span>                 :<span class="tlaUNC">           0 :     socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);</span></span>
<span id="L381"><span class="lineNum">     381</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!sock.GetSockName((struct sockaddr*)&amp;sockaddr_bind, &amp;sockaddr_bind_len)) {</span></span>
<span id="L382"><span class="lineNum">     382</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         addr_bind.SetSockAddr((const struct sockaddr*)&amp;sockaddr_bind);</span></span>
<span id="L383"><span class="lineNum">     383</span>                 :             :     } else {</span>
<span id="L384"><span class="lineNum">     384</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogPrintLevel(BCLog::NET, BCLog::Level::Warning, &quot;getsockname failed\n&quot;);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L385"><span class="lineNum">     385</span>                 :             :     }</span>
<span id="L386"><span class="lineNum">     386</span>                 :<span class="tlaUNC">           0 :     return addr_bind;</span></span>
<span id="L387"><span class="lineNum">     387</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L388"><span class="lineNum">     388</span>                 :             : </span>
<span id="L389"><span class="lineNum">     389</span>                 :<span class="tlaGNC tlaBgGNC">          10 : CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type, bool use_v2transport)</span></span>
<span id="L390"><span class="lineNum">     390</span>                 :             : {</span>
<span id="L391"><span class="lineNum">     391</span>                 :<span class="tlaGNC">          10 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L392"><span class="lineNum">     392</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC">          10 :     assert(conn_type != ConnectionType::INBOUND);</span></span>
<span id="L393"><span class="lineNum">     393</span>                 :             : </span>
<span id="L394"><span class="lineNum">     394</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC">          10 :     if (pszDest == nullptr) {</span></span>
<span id="L395"><span class="lineNum">     395</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         if (IsLocal(addrConnect))</span></span>
<span id="L396"><span class="lineNum">     396</span>                 :             :             return nullptr;</span>
<span id="L397"><span class="lineNum">     397</span>                 :             : </span>
<span id="L398"><span class="lineNum">     398</span>                 :             :         // Look for an existing connection</span>
<span id="L399"><span class="lineNum">     399</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         CNode* pnode = FindNode(static_cast&lt;CService&gt;(addrConnect));</span></span>
<span id="L400"><span class="lineNum">     400</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (pnode)</span></span>
<span id="L401"><span class="lineNum">     401</span>                 :             :         {</span>
<span id="L402"><span class="lineNum">     402</span>                 :<span class="tlaUNC">           0 :             LogPrintf(&quot;Failed to open new connection, already connected\n&quot;);</span></span>
<span id="L403"><span class="lineNum">     403</span>                 :<span class="tlaUNC">           0 :             return nullptr;</span></span>
<span id="L404"><span class="lineNum">     404</span>                 :             :         }</span>
<span id="L405"><span class="lineNum">     405</span>                 :             :     }</span>
<span id="L406"><span class="lineNum">     406</span>                 :             : </span>
<span id="L407"><span class="lineNum">     407</span>   [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC tlaBgGNC">          20 :     LogPrintLevel(BCLog::NET, BCLog::Level::Debug, &quot;trying %s connection %s lastseen=%.1fhrs\n&quot;,</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaGBC" title="Branch 7 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 8 was taken 10 times"> + </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not taken"> - </span>]
<span id="L408"><span class="lineNum">     408</span>                 :             :         use_v2transport ? &quot;v2&quot; : &quot;v1&quot;,</span>
<span id="L409"><span class="lineNum">     409</span>                 :             :         pszDest ? pszDest : addrConnect.ToStringAddrPort(),</span>
<span id="L410"><span class="lineNum">     410</span>                 :             :         Ticks&lt;HoursDouble&gt;(pszDest ? 0h : Now&lt;NodeSeconds&gt;() - addrConnect.nTime));</span>
<span id="L411"><span class="lineNum">     411</span>                 :             : </span>
<span id="L412"><span class="lineNum">     412</span>                 :             :     // Resolve</span>
<span id="L413"><span class="lineNum">     413</span>   [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          20 :     const uint16_t default_port{pszDest != nullptr ? GetDefaultPort(pszDest) :</span></span>
<span id="L414"><span class="lineNum">     414</span>                 :<span class="tlaGNC">          10 :                                                      m_params.GetDefaultPort()};</span></span>
<span id="L415"><span class="lineNum">     415</span>                 :             : </span>
<span id="L416"><span class="lineNum">     416</span>                 :             :     // Collection of addresses to try to connect to: either all dns resolved addresses if a domain name (pszDest) is provided, or addrConnect otherwise.</span>
<span id="L417"><span class="lineNum">     417</span>                 :<span class="tlaGNC">          10 :     std::vector&lt;CAddress&gt; connect_to{};</span></span>
<span id="L418"><span class="lineNum">     418</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          10 :     if (pszDest) {</span></span>
<span id="L419"><span class="lineNum">     419</span>   [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          20 :         std::vector&lt;CService&gt; resolved{Lookup(pszDest, default_port, fNameLookup &amp;&amp; !HaveNameProxy(), 256)};</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaGBC" title="Branch 7 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 8 was taken 10 times"> + </span> 
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 9 was not taken"> - </span><span class="tlaGBC" title="Branch 10 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 11 was not taken"> - </span>]
<span id="L420"><span class="lineNum">     420</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          10 :         if (!resolved.empty()) {</span></span>
<span id="L421"><span class="lineNum">     421</span>                 :<span class="tlaGNC">          10 :             std::shuffle(resolved.begin(), resolved.end(), FastRandomContext());</span></span>
<span id="L422"><span class="lineNum">     422</span>                 :             :             // If the connection is made by name, it can be the case that the name resolves to more than one address.</span>
<span id="L423"><span class="lineNum">     423</span>                 :             :             // We don't want to connect any more of them if we are already connected to one</span>
<span id="L424"><span class="lineNum">     424</span>         [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          14 :             for (const auto&amp; r : resolved) {</span></span>
<span id="L425"><span class="lineNum">     425</span>         [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          14 :                 addrConnect = CAddress{MaybeFlipIPv6toCJDNS(r), NODE_NONE};</span></span>
<span id="L426"><span class="lineNum">     426</span>   [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 14 times"> + </span>]:<span class="tlaGNC">          14 :                 if (!addrConnect.IsValid()) {</span></span>
<span id="L427"><span class="lineNum">     427</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC tlaBgUNC">           0 :                     LogDebug(BCLog::NET, &quot;Resolver returned invalid address %s for %s\n&quot;, addrConnect.ToStringAddrPort(), pszDest);</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L428"><span class="lineNum">     428</span>                 :<span class="tlaUNC">           0 :                     return nullptr;</span></span>
<span id="L429"><span class="lineNum">     429</span>                 :             :                 }</span>
<span id="L430"><span class="lineNum">     430</span>                 :             :                 // It is possible that we already have a connection to the IP/port pszDest resolved to.</span>
<span id="L431"><span class="lineNum">     431</span>                 :             :                 // In that case, drop the connection that was just created.</span>
<span id="L432"><span class="lineNum">     432</span>         [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC tlaBgGNC">          14 :                 LOCK(m_nodes_mutex);</span></span>
<span id="L433"><span class="lineNum">     433</span>         [<span class="tlaGBC" title="Branch 0 was taken 14 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          14 :                 CNode* pnode = FindNode(static_cast&lt;CService&gt;(addrConnect));</span></span>
<span id="L434"><span class="lineNum">     434</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 4 times"> + </span>]:<span class="tlaGNC">          14 :                 if (pnode) {</span></span>
<span id="L435"><span class="lineNum">     435</span>   [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          10 :                     LogPrintf(&quot;Not opening a connection to %s, already connected to %s\n&quot;, pszDest, addrConnect.ToStringAddrPort());</span></span>
<span id="L436"><span class="lineNum">     436</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          10 :                     return nullptr;</span></span>
<span id="L437"><span class="lineNum">     437</span>                 :             :                 }</span>
<span id="L438"><span class="lineNum">     438</span>                 :             :                 // Add the address to the resolved addresses vector so we can try to connect to it later on</span>
<span id="L439"><span class="lineNum">     439</span>         [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           4 :                 connect_to.push_back(addrConnect);</span></span>
<span id="L440"><span class="lineNum">     440</span>                 :<span class="tlaGNC">          14 :             }</span></span>
<span id="L441"><span class="lineNum">     441</span>                 :             :         } else {</span>
<span id="L442"><span class="lineNum">     442</span>                 :             :             // For resolution via proxy</span>
<span id="L443"><span class="lineNum">     443</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :             connect_to.push_back(addrConnect);</span></span>
<span id="L444"><span class="lineNum">     444</span>                 :             :         }</span>
<span id="L445"><span class="lineNum">     445</span>                 :<span class="tlaGNC tlaBgGNC">          10 :     } else {</span></span>
<span id="L446"><span class="lineNum">     446</span>                 :             :         // Connect via addrConnect directly</span>
<span id="L447"><span class="lineNum">     447</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         connect_to.push_back(addrConnect);</span></span>
<span id="L448"><span class="lineNum">     448</span>                 :             :     }</span>
<span id="L449"><span class="lineNum">     449</span>                 :             : </span>
<span id="L450"><span class="lineNum">     450</span>                 :             :     // Connect</span>
<span id="L451"><span class="lineNum">     451</span>                 :<span class="tlaUNC">           0 :     std::unique_ptr&lt;Sock&gt; sock;</span></span>
<span id="L452"><span class="lineNum">     452</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     Proxy proxy;</span></span>
<span id="L453"><span class="lineNum">     453</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     CAddress addr_bind;</span></span>
<span id="L454"><span class="lineNum">     454</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert(!addr_bind.IsValid());</span></span>
<span id="L455"><span class="lineNum">     455</span>                 :<span class="tlaUNC">           0 :     std::unique_ptr&lt;i2p::sam::Session&gt; i2p_transient_session;</span></span>
<span id="L456"><span class="lineNum">     456</span>                 :             : </span>
<span id="L457"><span class="lineNum">     457</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (auto&amp; target_addr: connect_to) {</span></span>
<span id="L458"><span class="lineNum">     458</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (target_addr.IsValid()) {</span></span>
<span id="L459"><span class="lineNum">     459</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             const bool use_proxy{GetProxy(target_addr.GetNetwork(), proxy)};</span></span>
<span id="L460"><span class="lineNum">     460</span>                 :<span class="tlaUNC">           0 :             bool proxyConnectionFailed = false;</span></span>
<span id="L461"><span class="lineNum">     461</span>                 :             : </span>
<span id="L462"><span class="lineNum">     462</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (target_addr.IsI2P() &amp;&amp; use_proxy) {</span></span>
<span id="L463"><span class="lineNum">     463</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 i2p::Connection conn;</span></span>
<span id="L464"><span class="lineNum">     464</span>                 :<span class="tlaUNC">           0 :                 bool connected{false};</span></span>
<span id="L465"><span class="lineNum">     465</span>                 :             : </span>
<span id="L466"><span class="lineNum">     466</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (m_i2p_sam_session) {</span></span>
<span id="L467"><span class="lineNum">     467</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     connected = m_i2p_sam_session-&gt;Connect(target_addr, conn, proxyConnectionFailed);</span></span>
<span id="L468"><span class="lineNum">     468</span>                 :             :                 } else {</span>
<span id="L469"><span class="lineNum">     469</span>                 :<span class="tlaUNC">           0 :                     {</span></span>
<span id="L470"><span class="lineNum">     470</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         LOCK(m_unused_i2p_sessions_mutex);</span></span>
<span id="L471"><span class="lineNum">     471</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         if (m_unused_i2p_sessions.empty()) {</span></span>
<span id="L472"><span class="lineNum">     472</span>                 :<span class="tlaUNC">           0 :                             i2p_transient_session =</span></span>
<span id="L473"><span class="lineNum">     473</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                 std::make_unique&lt;i2p::sam::Session&gt;(proxy, &amp;interruptNet);</span></span>
<span id="L474"><span class="lineNum">     474</span>                 :             :                         } else {</span>
<span id="L475"><span class="lineNum">     475</span>                 :<span class="tlaUNC">           0 :                             i2p_transient_session.swap(m_unused_i2p_sessions.front());</span></span>
<span id="L476"><span class="lineNum">     476</span>                 :<span class="tlaUNC">           0 :                             m_unused_i2p_sessions.pop();</span></span>
<span id="L477"><span class="lineNum">     477</span>                 :             :                         }</span>
<span id="L478"><span class="lineNum">     478</span>                 :<span class="tlaUNC">           0 :                     }</span></span>
<span id="L479"><span class="lineNum">     479</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     connected = i2p_transient_session-&gt;Connect(target_addr, conn, proxyConnectionFailed);</span></span>
<span id="L480"><span class="lineNum">     480</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     if (!connected) {</span></span>
<span id="L481"><span class="lineNum">     481</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         LOCK(m_unused_i2p_sessions_mutex);</span></span>
<span id="L482"><span class="lineNum">     482</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         if (m_unused_i2p_sessions.size() &lt; MAX_UNUSED_I2P_SESSIONS_SIZE) {</span></span>
<span id="L483"><span class="lineNum">     483</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                             m_unused_i2p_sessions.emplace(i2p_transient_session.release());</span></span>
<span id="L484"><span class="lineNum">     484</span>                 :             :                         }</span>
<span id="L485"><span class="lineNum">     485</span>                 :<span class="tlaUNC">           0 :                     }</span></span>
<span id="L486"><span class="lineNum">     486</span>                 :             :                 }</span>
<span id="L487"><span class="lineNum">     487</span>                 :             : </span>
<span id="L488"><span class="lineNum">     488</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (connected) {</span></span>
<span id="L489"><span class="lineNum">     489</span>                 :<span class="tlaUNC">           0 :                     sock = std::move(conn.sock);</span></span>
<span id="L490"><span class="lineNum">     490</span>                 :<span class="tlaUNC">           0 :                     addr_bind = CAddress{conn.me, NODE_NONE};</span></span>
<span id="L491"><span class="lineNum">     491</span>                 :             :                 }</span>
<span id="L492"><span class="lineNum">     492</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             } else if (use_proxy) {</span></span>
<span id="L493"><span class="lineNum">     493</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 LogPrintLevel(BCLog::PROXY, BCLog::Level::Debug, &quot;Using proxy: %s to connect to %s\n&quot;, proxy.ToString(), target_addr.ToStringAddrPort());</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L494"><span class="lineNum">     494</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 sock = ConnectThroughProxy(proxy, target_addr.ToStringAddr(), target_addr.GetPort(), proxyConnectionFailed);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L495"><span class="lineNum">     495</span>                 :             :             } else {</span>
<span id="L496"><span class="lineNum">     496</span>                 :             :                 // no proxy needed (none set for target network)</span>
<span id="L497"><span class="lineNum">     497</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 sock = ConnectDirectly(target_addr, conn_type == ConnectionType::MANUAL);</span></span>
<span id="L498"><span class="lineNum">     498</span>                 :             :             }</span>
<span id="L499"><span class="lineNum">     499</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!proxyConnectionFailed) {</span></span>
<span id="L500"><span class="lineNum">     500</span>                 :             :                 // If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to</span>
<span id="L501"><span class="lineNum">     501</span>                 :             :                 // the proxy, mark this as an attempt.</span>
<span id="L502"><span class="lineNum">     502</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 addrman.Attempt(target_addr, fCountFailure);</span></span>
<span id="L503"><span class="lineNum">     503</span>                 :             :             }</span>
<span id="L504"><span class="lineNum">     504</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         } else if (pszDest &amp;&amp; GetNameProxy(proxy)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L505"><span class="lineNum">     505</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             std::string host;</span></span>
<span id="L506"><span class="lineNum">     506</span>                 :<span class="tlaUNC">           0 :             uint16_t port{default_port};</span></span>
<span id="L507"><span class="lineNum">     507</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             SplitHostPort(std::string(pszDest), port, host);</span></span>
<span id="L508"><span class="lineNum">     508</span>                 :<span class="tlaUNC">           0 :             bool proxyConnectionFailed;</span></span>
<span id="L509"><span class="lineNum">     509</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             sock = ConnectThroughProxy(proxy, host, port, proxyConnectionFailed);</span></span>
<span id="L510"><span class="lineNum">     510</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L511"><span class="lineNum">     511</span>                 :             :         // Check any other resolved address (if any) if we fail to connect</span>
<span id="L512"><span class="lineNum">     512</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!sock) {</span></span>
<span id="L513"><span class="lineNum">     513</span>                 :<span class="tlaUNC">           0 :             continue;</span></span>
<span id="L514"><span class="lineNum">     514</span>                 :             :         }</span>
<span id="L515"><span class="lineNum">     515</span>                 :             : </span>
<span id="L516"><span class="lineNum">     516</span>                 :<span class="tlaUNC">           0 :         NetPermissionFlags permission_flags = NetPermissionFlags::None;</span></span>
<span id="L517"><span class="lineNum">     517</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         std::vector&lt;NetWhitelistPermissions&gt; whitelist_permissions = conn_type == ConnectionType::MANUAL ? vWhitelistedRangeOutgoing : std::vector&lt;NetWhitelistPermissions&gt;{};</span></span>
<span id="L518"><span class="lineNum">     518</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         AddWhitelistPermissionFlags(permission_flags, target_addr, whitelist_permissions);</span></span>
<span id="L519"><span class="lineNum">     519</span>                 :             : </span>
<span id="L520"><span class="lineNum">     520</span>                 :             :         // Add node</span>
<span id="L521"><span class="lineNum">     521</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         NodeId id = GetNewNodeId();</span></span>
<span id="L522"><span class="lineNum">     522</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L523"><span class="lineNum">     523</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!addr_bind.IsValid()) {</span></span>
<span id="L524"><span class="lineNum">     524</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             addr_bind = GetBindAddress(*sock);</span></span>
<span id="L525"><span class="lineNum">     525</span>                 :             :         }</span>
<span id="L526"><span class="lineNum">     526</span>                 :<span class="tlaUNC">           0 :         CNode* pnode = new CNode(id,</span></span>
<span id="L527"><span class="lineNum">     527</span>                 :             :                                 std::move(sock),</span>
<span id="L528"><span class="lineNum">     528</span>                 :             :                                 target_addr,</span>
<span id="L529"><span class="lineNum">     529</span>                 :             :                                 CalculateKeyedNetGroup(target_addr),</span>
<span id="L530"><span class="lineNum">     530</span>                 :             :                                 nonce,</span>
<span id="L531"><span class="lineNum">     531</span>                 :             :                                 addr_bind,</span>
<span id="L532"><span class="lineNum">     532</span>                 :<span class="tlaUNC">           0 :                                 pszDest ? pszDest : &quot;&quot;,</span></span>
<span id="L533"><span class="lineNum">     533</span>                 :             :                                 conn_type,</span>
<span id="L534"><span class="lineNum">     534</span>                 :             :                                 /*inbound_onion=*/false,</span>
<span id="L535"><span class="lineNum">     535</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                 CNodeOptions{</span></span>
<span id="L536"><span class="lineNum">     536</span>                 :             :                                     .permission_flags = permission_flags,</span>
<span id="L537"><span class="lineNum">     537</span>                 :             :                                     .i2p_sam_session = std::move(i2p_transient_session),</span>
<span id="L538"><span class="lineNum">     538</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                     .recv_flood_size = nReceiveFloodSize,</span></span>
<span id="L539"><span class="lineNum">     539</span>                 :             :                                     .use_v2transport = use_v2transport,</span>
<span id="L540"><span class="lineNum">     540</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                                 });</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span><span class="tlaUNC" title="Branch 12 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 13 was not executed"> # </span>]
<span id="L541"><span class="lineNum">     541</span>                 :<span class="tlaUNC">           0 :         pnode-&gt;AddRef();</span></span>
<span id="L542"><span class="lineNum">     542</span>                 :             : </span>
<span id="L543"><span class="lineNum">     543</span>                 :             :         // We're making a new connection, harvest entropy from the time (and our peer count)</span>
<span id="L544"><span class="lineNum">     544</span>                 :<span class="tlaUNC">           0 :         RandAddEvent((uint32_t)id);</span></span>
<span id="L545"><span class="lineNum">     545</span>                 :             : </span>
<span id="L546"><span class="lineNum">     546</span>                 :<span class="tlaUNC">           0 :         return pnode;</span></span>
<span id="L547"><span class="lineNum">     547</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L548"><span class="lineNum">     548</span>                 :             : </span>
<span id="L549"><span class="lineNum">     549</span>                 :             :     return nullptr;</span>
<span id="L550"><span class="lineNum">     550</span>                 :<span class="tlaGNC tlaBgGNC">          10 : }</span></span>
<span id="L551"><span class="lineNum">     551</span>                 :             : </span>
<span id="L552"><span class="lineNum">     552</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CNode::CloseSocketDisconnect()</span></span>
<span id="L553"><span class="lineNum">     553</span>                 :             : {</span>
<span id="L554"><span class="lineNum">     554</span>                 :<span class="tlaUNC">           0 :     fDisconnect = true;</span></span>
<span id="L555"><span class="lineNum">     555</span>                 :<span class="tlaUNC">           0 :     LOCK(m_sock_mutex);</span></span>
<span id="L556"><span class="lineNum">     556</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_sock) {</span></span>
<span id="L557"><span class="lineNum">     557</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;disconnecting peer=%d\n&quot;, id);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L558"><span class="lineNum">     558</span>                 :<span class="tlaUNC">           0 :         m_sock.reset();</span></span>
<span id="L559"><span class="lineNum">     559</span>                 :             :     }</span>
<span id="L560"><span class="lineNum">     560</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     m_i2p_sam_session.reset();</span></span>
<span id="L561"><span class="lineNum">     561</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L562"><span class="lineNum">     562</span>                 :             : </span>
<span id="L563"><span class="lineNum">     563</span>                 :<span class="tlaUNC">           0 : void CConnman::AddWhitelistPermissionFlags(NetPermissionFlags&amp; flags, const CNetAddr &amp;addr, const std::vector&lt;NetWhitelistPermissions&gt;&amp; ranges) const {</span></span>
<span id="L564"><span class="lineNum">     564</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const auto&amp; subnet : ranges) {</span></span>
<span id="L565"><span class="lineNum">     565</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (subnet.m_subnet.Match(addr)) {</span></span>
<span id="L566"><span class="lineNum">     566</span>                 :<span class="tlaUNC">           0 :             NetPermissions::AddFlag(flags, subnet.m_flags);</span></span>
<span id="L567"><span class="lineNum">     567</span>                 :             :         }</span>
<span id="L568"><span class="lineNum">     568</span>                 :             :     }</span>
<span id="L569"><span class="lineNum">     569</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (NetPermissions::HasFlag(flags, NetPermissionFlags::Implicit)) {</span></span>
<span id="L570"><span class="lineNum">     570</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         NetPermissions::ClearFlag(flags, NetPermissionFlags::Implicit);</span></span>
<span id="L571"><span class="lineNum">     571</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (whitelist_forcerelay) NetPermissions::AddFlag(flags, NetPermissionFlags::ForceRelay);</span></span>
<span id="L572"><span class="lineNum">     572</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (whitelist_relay) NetPermissions::AddFlag(flags, NetPermissionFlags::Relay);</span></span>
<span id="L573"><span class="lineNum">     573</span>                 :<span class="tlaUNC">           0 :         NetPermissions::AddFlag(flags, NetPermissionFlags::Mempool);</span></span>
<span id="L574"><span class="lineNum">     574</span>                 :<span class="tlaUNC">           0 :         NetPermissions::AddFlag(flags, NetPermissionFlags::NoBan);</span></span>
<span id="L575"><span class="lineNum">     575</span>                 :             :     }</span>
<span id="L576"><span class="lineNum">     576</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L577"><span class="lineNum">     577</span>                 :             : </span>
<span id="L578"><span class="lineNum">     578</span>                 :<span class="tlaGNC tlaBgGNC">           8 : CService CNode::GetAddrLocal() const</span></span>
<span id="L579"><span class="lineNum">     579</span>                 :             : {</span>
<span id="L580"><span class="lineNum">     580</span>                 :<span class="tlaGNC">           8 :     AssertLockNotHeld(m_addr_local_mutex);</span></span>
<span id="L581"><span class="lineNum">     581</span>                 :<span class="tlaGNC">           8 :     LOCK(m_addr_local_mutex);</span></span>
<span id="L582"><span class="lineNum">     582</span>         [<span class="tlaGBC" title="Branch 0 was taken 8 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           8 :     return m_addr_local;</span></span>
<span id="L583"><span class="lineNum">     583</span>                 :<span class="tlaGNC">           8 : }</span></span>
<span id="L584"><span class="lineNum">     584</span>                 :             : </span>
<span id="L585"><span class="lineNum">     585</span>                 :<span class="tlaGNC">           5 : void CNode::SetAddrLocal(const CService&amp; addrLocalIn) {</span></span>
<span id="L586"><span class="lineNum">     586</span>                 :<span class="tlaGNC">           5 :     AssertLockNotHeld(m_addr_local_mutex);</span></span>
<span id="L587"><span class="lineNum">     587</span>                 :<span class="tlaGNC">           5 :     LOCK(m_addr_local_mutex);</span></span>
<span id="L588"><span class="lineNum">     588</span>   [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           5 :     if (Assume(!m_addr_local.IsValid())) { // Addr local can only be set once during version msg processing</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L589"><span class="lineNum">     589</span>                 :<span class="tlaGNC">           5 :         m_addr_local = addrLocalIn;</span></span>
<span id="L590"><span class="lineNum">     590</span>                 :             :     }</span>
<span id="L591"><span class="lineNum">     591</span>                 :<span class="tlaGNC">           5 : }</span></span>
<span id="L592"><span class="lineNum">     592</span>                 :             : </span>
<span id="L593"><span class="lineNum">     593</span>                 :<span class="tlaGNC">          76 : Network CNode::ConnectedThroughNetwork() const</span></span>
<span id="L594"><span class="lineNum">     594</span>                 :             : {</span>
<span id="L595"><span class="lineNum">     595</span>         [<span class="tlaGBC" title="Branch 0 was taken 75 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">          76 :     return m_inbound_onion ? NET_ONION : addr.GetNetClass();</span></span>
<span id="L596"><span class="lineNum">     596</span>                 :             : }</span>
<span id="L597"><span class="lineNum">     597</span>                 :             : </span>
<span id="L598"><span class="lineNum">     598</span>                 :<span class="tlaGNC">          33 : bool CNode::IsConnectedThroughPrivacyNet() const</span></span>
<span id="L599"><span class="lineNum">     599</span>                 :             : {</span>
<span id="L600"><span class="lineNum">     600</span>   [<span class="tlaGBC" title="Branch 0 was taken 33 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 27 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 6 times"> + </span>]:<span class="tlaGNC">          33 :     return m_inbound_onion || addr.IsPrivacyNet();</span></span>
<span id="L601"><span class="lineNum">     601</span>                 :             : }</span>
<span id="L602"><span class="lineNum">     602</span>                 :             : </span>
<span id="L603"><span class="lineNum">     603</span>                 :             : #undef X</span>
<span id="L604"><span class="lineNum">     604</span>                 :             : #define X(name) stats.name = name</span>
<span id="L605"><span class="lineNum">     605</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CNode::CopyStats(CNodeStats&amp; stats)</span></span>
<span id="L606"><span class="lineNum">     606</span>                 :             : {</span>
<span id="L607"><span class="lineNum">     607</span>                 :<span class="tlaUNC">           0 :     stats.nodeid = this-&gt;GetId();</span></span>
<span id="L608"><span class="lineNum">     608</span>                 :<span class="tlaUNC">           0 :     X(addr);</span></span>
<span id="L609"><span class="lineNum">     609</span>                 :<span class="tlaUNC">           0 :     X(addrBind);</span></span>
<span id="L610"><span class="lineNum">     610</span>                 :<span class="tlaUNC">           0 :     stats.m_network = ConnectedThroughNetwork();</span></span>
<span id="L611"><span class="lineNum">     611</span>                 :<span class="tlaUNC">           0 :     X(m_last_send);</span></span>
<span id="L612"><span class="lineNum">     612</span>                 :<span class="tlaUNC">           0 :     X(m_last_recv);</span></span>
<span id="L613"><span class="lineNum">     613</span>                 :<span class="tlaUNC">           0 :     X(m_last_tx_time);</span></span>
<span id="L614"><span class="lineNum">     614</span>                 :<span class="tlaUNC">           0 :     X(m_last_block_time);</span></span>
<span id="L615"><span class="lineNum">     615</span>                 :<span class="tlaUNC">           0 :     X(m_connected);</span></span>
<span id="L616"><span class="lineNum">     616</span>                 :<span class="tlaUNC">           0 :     X(m_addr_name);</span></span>
<span id="L617"><span class="lineNum">     617</span>                 :<span class="tlaUNC">           0 :     X(nVersion);</span></span>
<span id="L618"><span class="lineNum">     618</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L619"><span class="lineNum">     619</span>                 :<span class="tlaUNC">           0 :         LOCK(m_subver_mutex);</span></span>
<span id="L620"><span class="lineNum">     620</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         X(cleanSubVer);</span></span>
<span id="L621"><span class="lineNum">     621</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L622"><span class="lineNum">     622</span>                 :<span class="tlaUNC">           0 :     stats.fInbound = IsInboundConn();</span></span>
<span id="L623"><span class="lineNum">     623</span>                 :<span class="tlaUNC">           0 :     X(m_bip152_highbandwidth_to);</span></span>
<span id="L624"><span class="lineNum">     624</span>                 :<span class="tlaUNC">           0 :     X(m_bip152_highbandwidth_from);</span></span>
<span id="L625"><span class="lineNum">     625</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L626"><span class="lineNum">     626</span>                 :<span class="tlaUNC">           0 :         LOCK(cs_vSend);</span></span>
<span id="L627"><span class="lineNum">     627</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         X(mapSendBytesPerMsgType);</span></span>
<span id="L628"><span class="lineNum">     628</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         X(nSendBytes);</span></span>
<span id="L629"><span class="lineNum">     629</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L630"><span class="lineNum">     630</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L631"><span class="lineNum">     631</span>                 :<span class="tlaUNC">           0 :         LOCK(cs_vRecv);</span></span>
<span id="L632"><span class="lineNum">     632</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         X(mapRecvBytesPerMsgType);</span></span>
<span id="L633"><span class="lineNum">     633</span>                 :<span class="tlaUNC">           0 :         X(nRecvBytes);</span></span>
<span id="L634"><span class="lineNum">     634</span>                 :<span class="tlaUNC">           0 :         Transport::Info info = m_transport-&gt;GetInfo();</span></span>
<span id="L635"><span class="lineNum">     635</span>                 :<span class="tlaUNC">           0 :         stats.m_transport_type = info.transport_type;</span></span>
<span id="L636"><span class="lineNum">     636</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (info.session_id) stats.m_session_id = HexStr(*info.session_id);</span></span>
<span id="L637"><span class="lineNum">     637</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L638"><span class="lineNum">     638</span>                 :<span class="tlaUNC">           0 :     X(m_permission_flags);</span></span>
<span id="L639"><span class="lineNum">     639</span>                 :             : </span>
<span id="L640"><span class="lineNum">     640</span>                 :<span class="tlaUNC">           0 :     X(m_last_ping_time);</span></span>
<span id="L641"><span class="lineNum">     641</span>                 :<span class="tlaUNC">           0 :     X(m_min_ping_time);</span></span>
<span id="L642"><span class="lineNum">     642</span>                 :             : </span>
<span id="L643"><span class="lineNum">     643</span>                 :             :     // Leave string empty if addrLocal invalid (not filled in yet)</span>
<span id="L644"><span class="lineNum">     644</span>                 :<span class="tlaUNC">           0 :     CService addrLocalUnlocked = GetAddrLocal();</span></span>
<span id="L645"><span class="lineNum">     645</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     stats.addrLocal = addrLocalUnlocked.IsValid() ? addrLocalUnlocked.ToStringAddrPort() : &quot;&quot;;</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L646"><span class="lineNum">     646</span>                 :             : </span>
<span id="L647"><span class="lineNum">     647</span>                 :<span class="tlaUNC">           0 :     X(m_conn_type);</span></span>
<span id="L648"><span class="lineNum">     648</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L649"><span class="lineNum">     649</span>                 :             : #undef X</span>
<span id="L650"><span class="lineNum">     650</span>                 :             : </span>
<span id="L651"><span class="lineNum">     651</span>                 :<span class="tlaGNC tlaBgGNC">           3 : bool CNode::ReceiveMsgBytes(Span&lt;const uint8_t&gt; msg_bytes, bool&amp; complete)</span></span>
<span id="L652"><span class="lineNum">     652</span>                 :             : {</span>
<span id="L653"><span class="lineNum">     653</span>                 :<span class="tlaGNC">           3 :     complete = false;</span></span>
<span id="L654"><span class="lineNum">     654</span>                 :<span class="tlaGNC">           3 :     const auto time = GetTime&lt;std::chrono::microseconds&gt;();</span></span>
<span id="L655"><span class="lineNum">     655</span>                 :<span class="tlaGNC">           3 :     LOCK(cs_vRecv);</span></span>
<span id="L656"><span class="lineNum">     656</span>                 :<span class="tlaGNC">           3 :     m_last_recv = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(time);</span></span>
<span id="L657"><span class="lineNum">     657</span>                 :<span class="tlaGNC">           3 :     nRecvBytes += msg_bytes.size();</span></span>
<span id="L658"><span class="lineNum">     658</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC">           9 :     while (msg_bytes.size() &gt; 0) {</span></span>
<span id="L659"><span class="lineNum">     659</span>                 :             :         // absorb network data</span>
<span id="L660"><span class="lineNum">     660</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           3 :         if (!m_transport-&gt;ReceivedBytes(msg_bytes)) {</span></span>
<span id="L661"><span class="lineNum">     661</span>                 :             :             // Serious transport problem, disconnect from the peer.</span>
<span id="L662"><span class="lineNum">     662</span>                 :             :             return false;</span>
<span id="L663"><span class="lineNum">     663</span>                 :             :         }</span>
<span id="L664"><span class="lineNum">     664</span>                 :             : </span>
<span id="L665"><span class="lineNum">     665</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 1 time"> + </span>]:<span class="tlaGNC">           3 :         if (m_transport-&gt;ReceivedMessageComplete()) {</span></span>
<span id="L666"><span class="lineNum">     666</span>                 :             :             // decompose a transport agnostic CNetMessage from the deserializer</span>
<span id="L667"><span class="lineNum">     667</span>                 :<span class="tlaGNC">           2 :             bool reject_message{false};</span></span>
<span id="L668"><span class="lineNum">     668</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :             CNetMessage msg = m_transport-&gt;GetReceivedMessage(time, reject_message);</span></span>
<span id="L669"><span class="lineNum">     669</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :             if (reject_message) {</span></span>
<span id="L670"><span class="lineNum">     670</span>                 :             :                 // Message deserialization failed. Drop the message but don't disconnect the peer.</span>
<span id="L671"><span class="lineNum">     671</span>                 :             :                 // store the size of the corrupt message</span>
<span id="L672"><span class="lineNum">     672</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :                 mapRecvBytesPerMsgType.at(NET_MESSAGE_TYPE_OTHER) += msg.m_raw_message_size;</span></span>
<span id="L673"><span class="lineNum">     673</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L674"><span class="lineNum">     674</span>                 :             :             }</span>
<span id="L675"><span class="lineNum">     675</span>                 :             : </span>
<span id="L676"><span class="lineNum">     676</span>                 :             :             // Store received bytes per message type.</span>
<span id="L677"><span class="lineNum">     677</span>                 :             :             // To prevent a memory DOS, only allow known message types.</span>
<span id="L678"><span class="lineNum">     678</span>                 :<span class="tlaGNC tlaBgGNC">           2 :             auto i = mapRecvBytesPerMsgType.find(msg.m_type);</span></span>
<span id="L679"><span class="lineNum">     679</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :             if (i == mapRecvBytesPerMsgType.end()) {</span></span>
<span id="L680"><span class="lineNum">     680</span>                 :<span class="tlaUNC tlaBgUNC">           0 :                 i = mapRecvBytesPerMsgType.find(NET_MESSAGE_TYPE_OTHER);</span></span>
<span id="L681"><span class="lineNum">     681</span>                 :             :             }</span>
<span id="L682"><span class="lineNum">     682</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC tlaBgGNC">           2 :             assert(i != mapRecvBytesPerMsgType.end());</span></span>
<span id="L683"><span class="lineNum">     683</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :             i-&gt;second += msg.m_raw_message_size;</span></span>
<span id="L684"><span class="lineNum">     684</span>                 :             : </span>
<span id="L685"><span class="lineNum">     685</span>                 :             :             // push the message to the process queue,</span>
<span id="L686"><span class="lineNum">     686</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :             vRecvMsg.push_back(std::move(msg));</span></span>
<span id="L687"><span class="lineNum">     687</span>                 :             : </span>
<span id="L688"><span class="lineNum">     688</span>                 :<span class="tlaGNC">           2 :             complete = true;</span></span>
<span id="L689"><span class="lineNum">     689</span>                 :<span class="tlaGNC">           2 :         }</span></span>
<span id="L690"><span class="lineNum">     690</span>                 :             :     }</span>
<span id="L691"><span class="lineNum">     691</span>                 :             : </span>
<span id="L692"><span class="lineNum">     692</span>                 :             :     return true;</span>
<span id="L693"><span class="lineNum">     693</span>                 :<span class="tlaGNC">           3 : }</span></span>
<span id="L694"><span class="lineNum">     694</span>                 :             : </span>
<span id="L695"><span class="lineNum">     695</span>                 :<span class="tlaGNC">         115 : V1Transport::V1Transport(const NodeId node_id) noexcept</span></span>
<span id="L696"><span class="lineNum">     696</span>                 :<span class="tlaGNC">         115 :     : m_magic_bytes{Params().MessageStart()}, m_node_id{node_id}</span></span>
<span id="L697"><span class="lineNum">     697</span>                 :             : {</span>
<span id="L698"><span class="lineNum">     698</span>                 :<span class="tlaGNC">         115 :     LOCK(m_recv_mutex);</span></span>
<span id="L699"><span class="lineNum">     699</span>         [<span class="tlaGBC" title="Branch 0 was taken 115 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         115 :     Reset();</span></span>
<span id="L700"><span class="lineNum">     700</span>                 :<span class="tlaGNC">         115 : }</span></span>
<span id="L701"><span class="lineNum">     701</span>                 :             : </span>
<span id="L702"><span class="lineNum">     702</span>                 :<span class="tlaGNC">           2 : Transport::Info V1Transport::GetInfo() const noexcept</span></span>
<span id="L703"><span class="lineNum">     703</span>                 :             : {</span>
<span id="L704"><span class="lineNum">     704</span>                 :<span class="tlaGNC">           2 :     return {.transport_type = TransportProtocolType::V1, .session_id = {}};</span></span>
<span id="L705"><span class="lineNum">     705</span>                 :             : }</span>
<span id="L706"><span class="lineNum">     706</span>                 :             : </span>
<span id="L707"><span class="lineNum">     707</span>                 :<span class="tlaGNC">           5 : int V1Transport::readHeader(Span&lt;const uint8_t&gt; msg_bytes)</span></span>
<span id="L708"><span class="lineNum">     708</span>                 :             : {</span>
<span id="L709"><span class="lineNum">     709</span>                 :<span class="tlaGNC">           5 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L710"><span class="lineNum">     710</span>                 :             :     // copy data to temporary parsing buffer</span>
<span id="L711"><span class="lineNum">     711</span>                 :<span class="tlaGNC">           5 :     unsigned int nRemaining = CMessageHeader::HEADER_SIZE - nHdrPos;</span></span>
<span id="L712"><span class="lineNum">     712</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           5 :     unsigned int nCopy = std::min&lt;unsigned int&gt;(nRemaining, msg_bytes.size());</span></span>
<span id="L713"><span class="lineNum">     713</span>                 :             : </span>
<span id="L714"><span class="lineNum">     714</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC">           5 :     memcpy(&amp;hdrbuf[nHdrPos], msg_bytes.data(), nCopy);</span></span>
<span id="L715"><span class="lineNum">     715</span>                 :<span class="tlaGNC">           5 :     nHdrPos += nCopy;</span></span>
<span id="L716"><span class="lineNum">     716</span>                 :             : </span>
<span id="L717"><span class="lineNum">     717</span>                 :             :     // if header incomplete, exit</span>
<span id="L718"><span class="lineNum">     718</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC">           5 :     if (nHdrPos &lt; CMessageHeader::HEADER_SIZE)</span></span>
<span id="L719"><span class="lineNum">     719</span>                 :<span class="tlaGNC">           2 :         return nCopy;</span></span>
<span id="L720"><span class="lineNum">     720</span>                 :             : </span>
<span id="L721"><span class="lineNum">     721</span>                 :             :     // deserialize to CMessageHeader</span>
<span id="L722"><span class="lineNum">     722</span>                 :<span class="tlaGNC">           3 :     try {</span></span>
<span id="L723"><span class="lineNum">     723</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           3 :         hdrbuf &gt;&gt; hdr;</span></span>
<span id="L724"><span class="lineNum">     724</span>                 :             :     }</span>
<span id="L725"><span class="lineNum">     725</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaUNC tlaBgUNC">           0 :     catch (const std::exception&amp;) {</span></span>
<span id="L726"><span class="lineNum">     726</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;Header error: Unable to deserialize, peer=%d\n&quot;, m_node_id);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L727"><span class="lineNum">     727</span>                 :<span class="tlaUNC">           0 :         return -1;</span></span>
<span id="L728"><span class="lineNum">     728</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L729"><span class="lineNum">     729</span>                 :             : </span>
<span id="L730"><span class="lineNum">     730</span>                 :             :     // Check start string, network magic</span>
<span id="L731"><span class="lineNum">     731</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC tlaBgGNC">           3 :     if (hdr.pchMessageStart != m_magic_bytes) {</span></span>
<span id="L732"><span class="lineNum">     732</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         LogDebug(BCLog::NET, &quot;Header error: Wrong MessageStart %s received, peer=%d\n&quot;, HexStr(hdr.pchMessageStart), m_node_id);</span></span>
<span id="L733"><span class="lineNum">     733</span>                 :<span class="tlaUNC">           0 :         return -1;</span></span>
<span id="L734"><span class="lineNum">     734</span>                 :             :     }</span>
<span id="L735"><span class="lineNum">     735</span>                 :             : </span>
<span id="L736"><span class="lineNum">     736</span>                 :             :     // reject messages larger than MAX_SIZE or MAX_PROTOCOL_MESSAGE_LENGTH</span>
<span id="L737"><span class="lineNum">     737</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC tlaBgGNC">           3 :     if (hdr.nMessageSize &gt; MAX_SIZE || hdr.nMessageSize &gt; MAX_PROTOCOL_MESSAGE_LENGTH) {</span></span>
<span id="L738"><span class="lineNum">     738</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC tlaBgUNC">           0 :         LogDebug(BCLog::NET, &quot;Header error: Size too large (%s, %u bytes), peer=%d\n&quot;, SanitizeString(hdr.GetCommand()), hdr.nMessageSize, m_node_id);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L739"><span class="lineNum">     739</span>                 :<span class="tlaUNC">           0 :         return -1;</span></span>
<span id="L740"><span class="lineNum">     740</span>                 :             :     }</span>
<span id="L741"><span class="lineNum">     741</span>                 :             : </span>
<span id="L742"><span class="lineNum">     742</span>                 :             :     // switch state to reading message data</span>
<span id="L743"><span class="lineNum">     743</span>                 :<span class="tlaGNC tlaBgGNC">           3 :     in_data = true;</span></span>
<span id="L744"><span class="lineNum">     744</span>                 :             : </span>
<span id="L745"><span class="lineNum">     745</span>                 :<span class="tlaGNC">           3 :     return nCopy;</span></span>
<span id="L746"><span class="lineNum">     746</span>                 :             : }</span>
<span id="L747"><span class="lineNum">     747</span>                 :             : </span>
<span id="L748"><span class="lineNum">     748</span>                 :<span class="tlaGNC">           1 : int V1Transport::readData(Span&lt;const uint8_t&gt; msg_bytes)</span></span>
<span id="L749"><span class="lineNum">     749</span>                 :             : {</span>
<span id="L750"><span class="lineNum">     750</span>                 :<span class="tlaGNC">           1 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L751"><span class="lineNum">     751</span>                 :<span class="tlaGNC">           1 :     unsigned int nRemaining = hdr.nMessageSize - nDataPos;</span></span>
<span id="L752"><span class="lineNum">     752</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :     unsigned int nCopy = std::min&lt;unsigned int&gt;(nRemaining, msg_bytes.size());</span></span>
<span id="L753"><span class="lineNum">     753</span>                 :             : </span>
<span id="L754"><span class="lineNum">     754</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :     if (vRecv.size() &lt; nDataPos + nCopy) {</span></span>
<span id="L755"><span class="lineNum">     755</span>                 :             :         // Allocate up to 256 KiB ahead, but never more than the total message size.</span>
<span id="L756"><span class="lineNum">     756</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :         vRecv.resize(std::min(hdr.nMessageSize, nDataPos + nCopy + 256 * 1024));</span></span>
<span id="L757"><span class="lineNum">     757</span>                 :             :     }</span>
<span id="L758"><span class="lineNum">     758</span>                 :             : </span>
<span id="L759"><span class="lineNum">     759</span>                 :<span class="tlaGNC">           1 :     hasher.Write(msg_bytes.first(nCopy));</span></span>
<span id="L760"><span class="lineNum">     760</span>                 :<span class="tlaGNC">           1 :     memcpy(&amp;vRecv[nDataPos], msg_bytes.data(), nCopy);</span></span>
<span id="L761"><span class="lineNum">     761</span>                 :<span class="tlaGNC">           1 :     nDataPos += nCopy;</span></span>
<span id="L762"><span class="lineNum">     762</span>                 :             : </span>
<span id="L763"><span class="lineNum">     763</span>                 :<span class="tlaGNC">           1 :     return nCopy;</span></span>
<span id="L764"><span class="lineNum">     764</span>                 :             : }</span>
<span id="L765"><span class="lineNum">     765</span>                 :             : </span>
<span id="L766"><span class="lineNum">     766</span>                 :<span class="tlaGNC">           2 : const uint256&amp; V1Transport::GetMessageHash() const</span></span>
<span id="L767"><span class="lineNum">     767</span>                 :             : {</span>
<span id="L768"><span class="lineNum">     768</span>                 :<span class="tlaGNC">           2 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L769"><span class="lineNum">     769</span>   [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     assert(CompleteInternal());</span></span>
<span id="L770"><span class="lineNum">     770</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :     if (data_hash.IsNull())</span></span>
<span id="L771"><span class="lineNum">     771</span>                 :<span class="tlaGNC">           2 :         hasher.Finalize(data_hash);</span></span>
<span id="L772"><span class="lineNum">     772</span>                 :<span class="tlaGNC">           2 :     return data_hash;</span></span>
<span id="L773"><span class="lineNum">     773</span>                 :             : }</span>
<span id="L774"><span class="lineNum">     774</span>                 :             : </span>
<span id="L775"><span class="lineNum">     775</span>                 :<span class="tlaGNC">           2 : CNetMessage V1Transport::GetReceivedMessage(const std::chrono::microseconds time, bool&amp; reject_message)</span></span>
<span id="L776"><span class="lineNum">     776</span>                 :             : {</span>
<span id="L777"><span class="lineNum">     777</span>                 :<span class="tlaGNC">           2 :     AssertLockNotHeld(m_recv_mutex);</span></span>
<span id="L778"><span class="lineNum">     778</span>                 :             :     // Initialize out parameter</span>
<span id="L779"><span class="lineNum">     779</span>                 :<span class="tlaGNC">           2 :     reject_message = false;</span></span>
<span id="L780"><span class="lineNum">     780</span>                 :             :     // decompose a single CNetMessage from the TransportDeserializer</span>
<span id="L781"><span class="lineNum">     781</span>                 :<span class="tlaGNC">           2 :     LOCK(m_recv_mutex);</span></span>
<span id="L782"><span class="lineNum">     782</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :     CNetMessage msg(std::move(vRecv));</span></span>
<span id="L783"><span class="lineNum">     783</span>                 :             : </span>
<span id="L784"><span class="lineNum">     784</span>                 :             :     // store message type string, time, and sizes</span>
<span id="L785"><span class="lineNum">     785</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :     msg.m_type = hdr.GetCommand();</span></span>
<span id="L786"><span class="lineNum">     786</span>                 :<span class="tlaGNC">           2 :     msg.m_time = time;</span></span>
<span id="L787"><span class="lineNum">     787</span>                 :<span class="tlaGNC">           2 :     msg.m_message_size = hdr.nMessageSize;</span></span>
<span id="L788"><span class="lineNum">     788</span>                 :<span class="tlaGNC">           2 :     msg.m_raw_message_size = hdr.nMessageSize + CMessageHeader::HEADER_SIZE;</span></span>
<span id="L789"><span class="lineNum">     789</span>                 :             : </span>
<span id="L790"><span class="lineNum">     790</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :     uint256 hash = GetMessageHash();</span></span>
<span id="L791"><span class="lineNum">     791</span>                 :             : </span>
<span id="L792"><span class="lineNum">     792</span>                 :             :     // We just received a message off the wire, harvest entropy from the time (and the message checksum)</span>
<span id="L793"><span class="lineNum">     793</span>                 :<span class="tlaGNC">           2 :     RandAddEvent(ReadLE32(hash.begin()));</span></span>
<span id="L794"><span class="lineNum">     794</span>                 :             : </span>
<span id="L795"><span class="lineNum">     795</span>                 :             :     // Check checksum and header message type string</span>
<span id="L796"><span class="lineNum">     796</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0) {</span></span>
<span id="L797"><span class="lineNum">     797</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC tlaBgUNC">           0 :         LogDebug(BCLog::NET, &quot;Header error: Wrong checksum (%s, %u bytes), expected %s was %s, peer=%d\n&quot;,</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span>]
<span id="L798"><span class="lineNum">     798</span>                 :             :                  SanitizeString(msg.m_type), msg.m_message_size,</span>
<span id="L799"><span class="lineNum">     799</span>                 :             :                  HexStr(Span{hash}.first(CMessageHeader::CHECKSUM_SIZE)),</span>
<span id="L800"><span class="lineNum">     800</span>                 :             :                  HexStr(hdr.pchChecksum),</span>
<span id="L801"><span class="lineNum">     801</span>                 :             :                  m_node_id);</span>
<span id="L802"><span class="lineNum">     802</span>                 :<span class="tlaUNC">           0 :         reject_message = true;</span></span>
<span id="L803"><span class="lineNum">     803</span>   [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 2 times"> + </span>]:<span class="tlaGNC tlaBgGNC">           2 :     } else if (!hdr.IsCommandValid()) {</span></span>
<span id="L804"><span class="lineNum">     804</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC tlaBgUNC">           0 :         LogDebug(BCLog::NET, &quot;Header error: Invalid message type (%s, %u bytes), peer=%d\n&quot;,</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L805"><span class="lineNum">     805</span>                 :             :                  SanitizeString(hdr.GetCommand()), msg.m_message_size, m_node_id);</span>
<span id="L806"><span class="lineNum">     806</span>                 :<span class="tlaUNC">           0 :         reject_message = true;</span></span>
<span id="L807"><span class="lineNum">     807</span>                 :             :     }</span>
<span id="L808"><span class="lineNum">     808</span>                 :             : </span>
<span id="L809"><span class="lineNum">     809</span>                 :             :     // Always reset the network deserializer (prepare for the next message)</span>
<span id="L810"><span class="lineNum">     810</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC tlaBgGNC">           2 :     Reset();</span></span>
<span id="L811"><span class="lineNum">     811</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :     return msg;</span></span>
<span id="L812"><span class="lineNum">     812</span>                 :<span class="tlaGNC">           2 : }</span></span>
<span id="L813"><span class="lineNum">     813</span>                 :             : </span>
<span id="L814"><span class="lineNum">     814</span>                 :<span class="tlaGNC">           8 : bool V1Transport::SetMessageToSend(CSerializedNetMsg&amp; msg) noexcept</span></span>
<span id="L815"><span class="lineNum">     815</span>                 :             : {</span>
<span id="L816"><span class="lineNum">     816</span>                 :<span class="tlaGNC">           8 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L817"><span class="lineNum">     817</span>                 :             :     // Determine whether a new message can be set.</span>
<span id="L818"><span class="lineNum">     818</span>                 :<span class="tlaGNC">           8 :     LOCK(m_send_mutex);</span></span>
<span id="L819"><span class="lineNum">     819</span>   [<span class="tlaGBC" title="Branch 0 was taken 8 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 8 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           8 :     if (m_sending_header || m_bytes_sent &lt; m_message_to_send.data.size()) return false;</span></span>
<span id="L820"><span class="lineNum">     820</span>                 :             : </span>
<span id="L821"><span class="lineNum">     821</span>                 :             :     // create dbl-sha256 checksum</span>
<span id="L822"><span class="lineNum">     822</span>                 :<span class="tlaGNC">           8 :     uint256 hash = Hash(msg.data);</span></span>
<span id="L823"><span class="lineNum">     823</span>                 :             : </span>
<span id="L824"><span class="lineNum">     824</span>                 :             :     // create header</span>
<span id="L825"><span class="lineNum">     825</span>                 :<span class="tlaGNC">           8 :     CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());</span></span>
<span id="L826"><span class="lineNum">     826</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC">           8 :     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);</span></span>
<span id="L827"><span class="lineNum">     827</span>                 :             : </span>
<span id="L828"><span class="lineNum">     828</span>                 :             :     // serialize header</span>
<span id="L829"><span class="lineNum">     829</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC">           8 :     m_header_to_send.clear();</span></span>
<span id="L830"><span class="lineNum">     830</span>                 :<span class="tlaGNC">           8 :     VectorWriter{m_header_to_send, 0, hdr};</span></span>
<span id="L831"><span class="lineNum">     831</span>                 :             : </span>
<span id="L832"><span class="lineNum">     832</span>                 :             :     // update state</span>
<span id="L833"><span class="lineNum">     833</span>                 :<span class="tlaGNC">           8 :     m_message_to_send = std::move(msg);</span></span>
<span id="L834"><span class="lineNum">     834</span>                 :<span class="tlaGNC">           8 :     m_sending_header = true;</span></span>
<span id="L835"><span class="lineNum">     835</span>                 :<span class="tlaGNC">           8 :     m_bytes_sent = 0;</span></span>
<span id="L836"><span class="lineNum">     836</span>                 :<span class="tlaGNC">           8 :     return true;</span></span>
<span id="L837"><span class="lineNum">     837</span>                 :<span class="tlaGNC">           8 : }</span></span>
<span id="L838"><span class="lineNum">     838</span>                 :             : </span>
<span id="L839"><span class="lineNum">     839</span>                 :<span class="tlaGNC">          47 : Transport::BytesToSend V1Transport::GetBytesToSend(bool have_next_message) const noexcept</span></span>
<span id="L840"><span class="lineNum">     840</span>                 :             : {</span>
<span id="L841"><span class="lineNum">     841</span>                 :<span class="tlaGNC">          47 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L842"><span class="lineNum">     842</span>                 :<span class="tlaGNC">          47 :     LOCK(m_send_mutex);</span></span>
<span id="L843"><span class="lineNum">     843</span>         [<span class="tlaGBC" title="Branch 0 was taken 29 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 18 times"> + </span>]:<span class="tlaGNC">          47 :     if (m_sending_header) {</span></span>
<span id="L844"><span class="lineNum">     844</span>         [<span class="tlaGBC" title="Branch 0 was taken 13 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 16 times"> + </span>]:<span class="tlaGNC">          29 :         return {Span{m_header_to_send}.subspan(m_bytes_sent),</span></span>
<span id="L845"><span class="lineNum">     845</span>                 :             :                 // We have more to send after the header if the message has payload, or if there</span>
<span id="L846"><span class="lineNum">     846</span>                 :             :                 // is a next message after that.</span>
<span id="L847"><span class="lineNum">     847</span>   [<span class="tlaGBC" title="Branch 0 was taken 13 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 16 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 9 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 4 times"> + </span>]:<span class="tlaGNC">          29 :                 have_next_message || !m_message_to_send.data.empty(),</span></span>
<span id="L848"><span class="lineNum">     848</span>                 :<span class="tlaGNC">          29 :                 m_message_to_send.m_type</span></span>
<span id="L849"><span class="lineNum">     849</span>                 :<span class="tlaGNC">          29 :                };</span></span>
<span id="L850"><span class="lineNum">     850</span>                 :             :     } else {</span>
<span id="L851"><span class="lineNum">     851</span>                 :<span class="tlaGNC">          18 :         return {Span{m_message_to_send.data}.subspan(m_bytes_sent),</span></span>
<span id="L852"><span class="lineNum">     852</span>                 :             :                 // We only have more to send after this message's payload if there is another</span>
<span id="L853"><span class="lineNum">     853</span>                 :             :                 // message.</span>
<span id="L854"><span class="lineNum">     854</span>                 :             :                 have_next_message,</span>
<span id="L855"><span class="lineNum">     855</span>                 :<span class="tlaGNC">          18 :                 m_message_to_send.m_type</span></span>
<span id="L856"><span class="lineNum">     856</span>                 :<span class="tlaGNC">          18 :                };</span></span>
<span id="L857"><span class="lineNum">     857</span>                 :             :     }</span>
<span id="L858"><span class="lineNum">     858</span>                 :<span class="tlaGNC">          47 : }</span></span>
<span id="L859"><span class="lineNum">     859</span>                 :             : </span>
<span id="L860"><span class="lineNum">     860</span>                 :<span class="tlaGNC">           8 : void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept</span></span>
<span id="L861"><span class="lineNum">     861</span>                 :             : {</span>
<span id="L862"><span class="lineNum">     862</span>                 :<span class="tlaGNC">           8 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L863"><span class="lineNum">     863</span>                 :<span class="tlaGNC">           8 :     LOCK(m_send_mutex);</span></span>
<span id="L864"><span class="lineNum">     864</span>                 :<span class="tlaGNC">           8 :     m_bytes_sent += bytes_sent;</span></span>
<span id="L865"><span class="lineNum">     865</span>   [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           8 :     if (m_sending_header &amp;&amp; m_bytes_sent == m_header_to_send.size()) {</span></span>
<span id="L866"><span class="lineNum">     866</span>                 :             :         // We're done sending a message's header. Switch to sending its data bytes.</span>
<span id="L867"><span class="lineNum">     867</span>                 :<span class="tlaGNC">           5 :         m_sending_header = false;</span></span>
<span id="L868"><span class="lineNum">     868</span>                 :<span class="tlaGNC">           5 :         m_bytes_sent = 0;</span></span>
<span id="L869"><span class="lineNum">     869</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           3 :     } else if (!m_sending_header &amp;&amp; m_bytes_sent == m_message_to_send.data.size()) {</span></span>
<span id="L870"><span class="lineNum">     870</span>                 :             :         // We're done sending a message's data. Wipe the data vector to reduce memory consumption.</span>
<span id="L871"><span class="lineNum">     871</span>                 :<span class="tlaGNC">           3 :         ClearShrink(m_message_to_send.data);</span></span>
<span id="L872"><span class="lineNum">     872</span>                 :<span class="tlaGNC">           3 :         m_bytes_sent = 0;</span></span>
<span id="L873"><span class="lineNum">     873</span>                 :             :     }</span>
<span id="L874"><span class="lineNum">     874</span>                 :<span class="tlaGNC">           8 : }</span></span>
<span id="L875"><span class="lineNum">     875</span>                 :             : </span>
<span id="L876"><span class="lineNum">     876</span>                 :<span class="tlaGNC">          28 : size_t V1Transport::GetSendMemoryUsage() const noexcept</span></span>
<span id="L877"><span class="lineNum">     877</span>                 :             : {</span>
<span id="L878"><span class="lineNum">     878</span>                 :<span class="tlaGNC">          28 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L879"><span class="lineNum">     879</span>                 :<span class="tlaGNC">          28 :     LOCK(m_send_mutex);</span></span>
<span id="L880"><span class="lineNum">     880</span>                 :             :     // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.</span>
<span id="L881"><span class="lineNum">     881</span>         [<span class="tlaGBC" title="Branch 0 was taken 28 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          28 :     return m_message_to_send.GetMemoryUsage();</span></span>
<span id="L882"><span class="lineNum">     882</span>                 :<span class="tlaGNC">          28 : }</span></span>
<span id="L883"><span class="lineNum">     883</span>                 :             : </span>
<span id="L884"><span class="lineNum">     884</span>                 :             : namespace {</span>
<span id="L885"><span class="lineNum">     885</span>                 :             : </span>
<span id="L886"><span class="lineNum">     886</span>                 :             : /** List of short messages as defined in BIP324, in order.</span>
<span id="L887"><span class="lineNum">     887</span>                 :             :  *</span>
<span id="L888"><span class="lineNum">     888</span>                 :             :  * Only message types that are actually implemented in this codebase need to be listed, as other</span>
<span id="L889"><span class="lineNum">     889</span>                 :             :  * messages get ignored anyway - whether we know how to decode them or not.</span>
<span id="L890"><span class="lineNum">     890</span>                 :             :  */</span>
<span id="L891"><span class="lineNum">     891</span>                 :             : const std::array&lt;std::string, 33&gt; V2_MESSAGE_IDS = {</span>
<span id="L892"><span class="lineNum">     892</span>                 :             :     &quot;&quot;, // 12 bytes follow encoding the message type like in V1</span>
<span id="L893"><span class="lineNum">     893</span>                 :             :     NetMsgType::ADDR,</span>
<span id="L894"><span class="lineNum">     894</span>                 :             :     NetMsgType::BLOCK,</span>
<span id="L895"><span class="lineNum">     895</span>                 :             :     NetMsgType::BLOCKTXN,</span>
<span id="L896"><span class="lineNum">     896</span>                 :             :     NetMsgType::CMPCTBLOCK,</span>
<span id="L897"><span class="lineNum">     897</span>                 :             :     NetMsgType::FEEFILTER,</span>
<span id="L898"><span class="lineNum">     898</span>                 :             :     NetMsgType::FILTERADD,</span>
<span id="L899"><span class="lineNum">     899</span>                 :             :     NetMsgType::FILTERCLEAR,</span>
<span id="L900"><span class="lineNum">     900</span>                 :             :     NetMsgType::FILTERLOAD,</span>
<span id="L901"><span class="lineNum">     901</span>                 :             :     NetMsgType::GETBLOCKS,</span>
<span id="L902"><span class="lineNum">     902</span>                 :             :     NetMsgType::GETBLOCKTXN,</span>
<span id="L903"><span class="lineNum">     903</span>                 :             :     NetMsgType::GETDATA,</span>
<span id="L904"><span class="lineNum">     904</span>                 :             :     NetMsgType::GETHEADERS,</span>
<span id="L905"><span class="lineNum">     905</span>                 :             :     NetMsgType::HEADERS,</span>
<span id="L906"><span class="lineNum">     906</span>                 :             :     NetMsgType::INV,</span>
<span id="L907"><span class="lineNum">     907</span>                 :             :     NetMsgType::MEMPOOL,</span>
<span id="L908"><span class="lineNum">     908</span>                 :             :     NetMsgType::MERKLEBLOCK,</span>
<span id="L909"><span class="lineNum">     909</span>                 :             :     NetMsgType::NOTFOUND,</span>
<span id="L910"><span class="lineNum">     910</span>                 :             :     NetMsgType::PING,</span>
<span id="L911"><span class="lineNum">     911</span>                 :             :     NetMsgType::PONG,</span>
<span id="L912"><span class="lineNum">     912</span>                 :             :     NetMsgType::SENDCMPCT,</span>
<span id="L913"><span class="lineNum">     913</span>                 :             :     NetMsgType::TX,</span>
<span id="L914"><span class="lineNum">     914</span>                 :             :     NetMsgType::GETCFILTERS,</span>
<span id="L915"><span class="lineNum">     915</span>                 :             :     NetMsgType::CFILTER,</span>
<span id="L916"><span class="lineNum">     916</span>                 :             :     NetMsgType::GETCFHEADERS,</span>
<span id="L917"><span class="lineNum">     917</span>                 :             :     NetMsgType::CFHEADERS,</span>
<span id="L918"><span class="lineNum">     918</span>                 :             :     NetMsgType::GETCFCHECKPT,</span>
<span id="L919"><span class="lineNum">     919</span>                 :             :     NetMsgType::CFCHECKPT,</span>
<span id="L920"><span class="lineNum">     920</span>                 :             :     NetMsgType::ADDRV2,</span>
<span id="L921"><span class="lineNum">     921</span>                 :             :     // Unimplemented message types that are assigned in BIP324:</span>
<span id="L922"><span class="lineNum">     922</span>                 :             :     &quot;&quot;,</span>
<span id="L923"><span class="lineNum">     923</span>                 :             :     &quot;&quot;,</span>
<span id="L924"><span class="lineNum">     924</span>                 :             :     &quot;&quot;,</span>
<span id="L925"><span class="lineNum">     925</span>                 :             :     &quot;&quot;</span>
<span id="L926"><span class="lineNum">     926</span>                 :             : };</span>
<span id="L927"><span class="lineNum">     927</span>                 :             : </span>
<span id="L928"><span class="lineNum">     928</span>                 :             : class V2MessageMap</span>
<span id="L929"><span class="lineNum">     929</span>                 :             : {</span>
<span id="L930"><span class="lineNum">     930</span>                 :             :     std::unordered_map&lt;std::string, uint8_t&gt; m_map;</span>
<span id="L931"><span class="lineNum">     931</span>                 :             : </span>
<span id="L932"><span class="lineNum">     932</span>                 :             : public:</span>
<span id="L933"><span class="lineNum">     933</span>                 :<span class="tlaGNC">         129 :     V2MessageMap() noexcept</span></span>
<span id="L934"><span class="lineNum">     934</span>                 :<span class="tlaGNC">         129 :     {</span></span>
<span id="L935"><span class="lineNum">     935</span>         [<span class="tlaGBC" title="Branch 0 was taken 4128 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 129 times"> + </span>]:<span class="tlaGNC">        4257 :         for (size_t i = 1; i &lt; std::size(V2_MESSAGE_IDS); ++i) {</span></span>
<span id="L936"><span class="lineNum">     936</span>                 :<span class="tlaGNC">        4128 :             m_map.emplace(V2_MESSAGE_IDS[i], i);</span></span>
<span id="L937"><span class="lineNum">     937</span>                 :             :         }</span>
<span id="L938"><span class="lineNum">     938</span>                 :<span class="tlaGNC">         129 :     }</span></span>
<span id="L939"><span class="lineNum">     939</span>                 :             : </span>
<span id="L940"><span class="lineNum">     940</span>                 :<span class="tlaGNC">          51 :     std::optional&lt;uint8_t&gt; operator()(const std::string&amp; message_name) const noexcept</span></span>
<span id="L941"><span class="lineNum">     941</span>                 :             :     {</span>
<span id="L942"><span class="lineNum">     942</span>                 :<span class="tlaGNC">          51 :         auto it = m_map.find(message_name);</span></span>
<span id="L943"><span class="lineNum">     943</span>         [<span class="tlaGBC" title="Branch 0 was taken 50 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">          51 :         if (it == m_map.end()) return std::nullopt;</span></span>
<span id="L944"><span class="lineNum">     944</span>                 :<span class="tlaGNC">           1 :         return it-&gt;second;</span></span>
<span id="L945"><span class="lineNum">     945</span>                 :             :     }</span>
<span id="L946"><span class="lineNum">     946</span>                 :             : };</span>
<span id="L947"><span class="lineNum">     947</span>                 :             : </span>
<span id="L948"><span class="lineNum">     948</span>                 :             : const V2MessageMap V2_MESSAGE_MAP;</span>
<span id="L949"><span class="lineNum">     949</span>                 :             : </span>
<span id="L950"><span class="lineNum">     950</span>                 :<span class="tlaGNC">          75 : std::vector&lt;uint8_t&gt; GenerateRandomGarbage() noexcept</span></span>
<span id="L951"><span class="lineNum">     951</span>                 :             : {</span>
<span id="L952"><span class="lineNum">     952</span>                 :<span class="tlaGNC">          75 :     std::vector&lt;uint8_t&gt; ret;</span></span>
<span id="L953"><span class="lineNum">     953</span>                 :<span class="tlaGNC">          75 :     FastRandomContext rng;</span></span>
<span id="L954"><span class="lineNum">     954</span>                 :<span class="tlaGNC">          75 :     ret.resize(rng.randrange(V2Transport::MAX_GARBAGE_LEN + 1));</span></span>
<span id="L955"><span class="lineNum">     955</span>                 :<span class="tlaGNC">          75 :     rng.fillrand(MakeWritableByteSpan(ret));</span></span>
<span id="L956"><span class="lineNum">     956</span>                 :<span class="tlaGNC">          75 :     return ret;</span></span>
<span id="L957"><span class="lineNum">     957</span>                 :<span class="tlaGNC">          75 : }</span></span>
<span id="L958"><span class="lineNum">     958</span>                 :             : </span>
<span id="L959"><span class="lineNum">     959</span>                 :             : } // namespace</span>
<span id="L960"><span class="lineNum">     960</span>                 :             : </span>
<span id="L961"><span class="lineNum">     961</span>                 :<span class="tlaGNC">          74 : void V2Transport::StartSendingHandshake() noexcept</span></span>
<span id="L962"><span class="lineNum">     962</span>                 :             : {</span>
<span id="L963"><span class="lineNum">     963</span>                 :<span class="tlaGNC">          74 :     AssertLockHeld(m_send_mutex);</span></span>
<span id="L964"><span class="lineNum">     964</span>                 :<span class="tlaGNC">          74 :     Assume(m_send_state == SendState::AWAITING_KEY);</span></span>
<span id="L965"><span class="lineNum">     965</span>                 :<span class="tlaGNC">          74 :     Assume(m_send_buffer.empty());</span></span>
<span id="L966"><span class="lineNum">     966</span>                 :             :     // Initialize the send buffer with ellswift pubkey + provided garbage.</span>
<span id="L967"><span class="lineNum">     967</span>                 :<span class="tlaGNC">          74 :     m_send_buffer.resize(EllSwiftPubKey::size() + m_send_garbage.size());</span></span>
<span id="L968"><span class="lineNum">     968</span>                 :<span class="tlaGNC">          74 :     std::copy(std::begin(m_cipher.GetOurPubKey()), std::end(m_cipher.GetOurPubKey()), MakeWritableByteSpan(m_send_buffer).begin());</span></span>
<span id="L969"><span class="lineNum">     969</span>                 :<span class="tlaGNC">          74 :     std::copy(m_send_garbage.begin(), m_send_garbage.end(), m_send_buffer.begin() + EllSwiftPubKey::size());</span></span>
<span id="L970"><span class="lineNum">     970</span>                 :             :     // We cannot wipe m_send_garbage as it will still be used as AAD later in the handshake.</span>
<span id="L971"><span class="lineNum">     971</span>                 :<span class="tlaGNC">          74 : }</span></span>
<span id="L972"><span class="lineNum">     972</span>                 :             : </span>
<span id="L973"><span class="lineNum">     973</span>                 :<span class="tlaGNC">          75 : V2Transport::V2Transport(NodeId nodeid, bool initiating, const CKey&amp; key, Span&lt;const std::byte&gt; ent32, std::vector&lt;uint8_t&gt; garbage) noexcept</span></span>
<span id="L974"><span class="lineNum">     974</span>                 :<span class="tlaGNC">          75 :     : m_cipher{key, ent32}, m_initiating{initiating}, m_nodeid{nodeid},</span></span>
<span id="L975"><span class="lineNum">     975</span>                 :<span class="tlaGNC">          75 :       m_v1_fallback{nodeid},</span></span>
<span id="L976"><span class="lineNum">     976</span>         [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 36 times"> + </span>]:<span class="tlaGNC">          75 :       m_recv_state{initiating ? RecvState::KEY : RecvState::KEY_MAYBE_V1},</span></span>
<span id="L977"><span class="lineNum">     977</span>                 :<span class="tlaGNC">          75 :       m_send_garbage{std::move(garbage)},</span></span>
<span id="L978"><span class="lineNum">     978</span>         [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 36 times"> + </span>]:<span class="tlaGNC">         189 :       m_send_state{initiating ? SendState::AWAITING_KEY : SendState::MAYBE_V1}</span></span>
<span id="L979"><span class="lineNum">     979</span>                 :             : {</span>
<span id="L980"><span class="lineNum">     980</span>                 :<span class="tlaGNC">          75 :     Assume(m_send_garbage.size() &lt;= MAX_GARBAGE_LEN);</span></span>
<span id="L981"><span class="lineNum">     981</span>                 :             :     // Start sending immediately if we're the initiator of the connection.</span>
<span id="L982"><span class="lineNum">     982</span>         [<span class="tlaGBC" title="Branch 0 was taken 36 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 39 times"> + </span>]:<span class="tlaGNC">          75 :     if (initiating) {</span></span>
<span id="L983"><span class="lineNum">     983</span>                 :<span class="tlaGNC">          36 :         LOCK(m_send_mutex);</span></span>
<span id="L984"><span class="lineNum">     984</span>         [<span class="tlaGBC" title="Branch 0 was taken 36 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          36 :         StartSendingHandshake();</span></span>
<span id="L985"><span class="lineNum">     985</span>                 :<span class="tlaGNC">          36 :     }</span></span>
<span id="L986"><span class="lineNum">     986</span>                 :<span class="tlaGNC">          75 : }</span></span>
<span id="L987"><span class="lineNum">     987</span>                 :             : </span>
<span id="L988"><span class="lineNum">     988</span>                 :<span class="tlaGNC">          75 : V2Transport::V2Transport(NodeId nodeid, bool initiating) noexcept</span></span>
<span id="L989"><span class="lineNum">     989</span>                 :<span class="tlaGNC">         150 :     : V2Transport{nodeid, initiating, GenerateRandomKey(),</span></span>
<span id="L990"><span class="lineNum">     990</span>                 :<span class="tlaGNC">         150 :                   MakeByteSpan(GetRandHash()), GenerateRandomGarbage()} {}</span></span>
<span id="L991"><span class="lineNum">     991</span>                 :             : </span>
<span id="L992"><span class="lineNum">     992</span>                 :<span class="tlaGNC">         758 : void V2Transport::SetReceiveState(RecvState recv_state) noexcept</span></span>
<span id="L993"><span class="lineNum">     993</span>                 :             : {</span>
<span id="L994"><span class="lineNum">     994</span>                 :<span class="tlaGNC">         758 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L995"><span class="lineNum">     995</span>                 :             :     // Enforce allowed state transitions.</span>
<span id="L996"><span class="lineNum">     996</span>   [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 73 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 71 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 71 times"> + </span> :<span class="tlaGNC">         758 :     switch (m_recv_state) {</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 252 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 252 times"> + </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L997"><span class="lineNum">     997</span>                 :<span class="tlaGNC">          39 :     case RecvState::KEY_MAYBE_V1:</span></span>
<span id="L998"><span class="lineNum">     998</span>                 :<span class="tlaGNC">          39 :         Assume(recv_state == RecvState::KEY || recv_state == RecvState::V1);</span></span>
<span id="L999"><span class="lineNum">     999</span>                 :<span class="tlaGNC">          39 :         break;</span></span>
<span id="L1000"><span class="lineNum">    1000</span>                 :<span class="tlaGNC">          73 :     case RecvState::KEY:</span></span>
<span id="L1001"><span class="lineNum">    1001</span>                 :<span class="tlaGNC">          73 :         Assume(recv_state == RecvState::GARB_GARBTERM);</span></span>
<span id="L1002"><span class="lineNum">    1002</span>                 :<span class="tlaGNC">          73 :         break;</span></span>
<span id="L1003"><span class="lineNum">    1003</span>                 :<span class="tlaGNC">          71 :     case RecvState::GARB_GARBTERM:</span></span>
<span id="L1004"><span class="lineNum">    1004</span>                 :<span class="tlaGNC">          71 :         Assume(recv_state == RecvState::VERSION);</span></span>
<span id="L1005"><span class="lineNum">    1005</span>                 :<span class="tlaGNC">          71 :         break;</span></span>
<span id="L1006"><span class="lineNum">    1006</span>                 :<span class="tlaGNC">          71 :     case RecvState::VERSION:</span></span>
<span id="L1007"><span class="lineNum">    1007</span>                 :<span class="tlaGNC">          71 :         Assume(recv_state == RecvState::APP);</span></span>
<span id="L1008"><span class="lineNum">    1008</span>                 :<span class="tlaGNC">          71 :         break;</span></span>
<span id="L1009"><span class="lineNum">    1009</span>                 :<span class="tlaGNC">         252 :     case RecvState::APP:</span></span>
<span id="L1010"><span class="lineNum">    1010</span>                 :<span class="tlaGNC">         252 :         Assume(recv_state == RecvState::APP_READY);</span></span>
<span id="L1011"><span class="lineNum">    1011</span>                 :<span class="tlaGNC">         252 :         break;</span></span>
<span id="L1012"><span class="lineNum">    1012</span>                 :<span class="tlaGNC">         252 :     case RecvState::APP_READY:</span></span>
<span id="L1013"><span class="lineNum">    1013</span>                 :<span class="tlaGNC">         252 :         Assume(recv_state == RecvState::APP);</span></span>
<span id="L1014"><span class="lineNum">    1014</span>                 :<span class="tlaGNC">         252 :         break;</span></span>
<span id="L1015"><span class="lineNum">    1015</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     case RecvState::V1:</span></span>
<span id="L1016"><span class="lineNum">    1016</span>                 :<span class="tlaUNC">           0 :         Assume(false); // V1 state cannot be left</span></span>
<span id="L1017"><span class="lineNum">    1017</span>                 :<span class="tlaUNC">           0 :         break;</span></span>
<span id="L1018"><span class="lineNum">    1018</span>                 :             :     }</span>
<span id="L1019"><span class="lineNum">    1019</span>                 :             :     // Change state.</span>
<span id="L1020"><span class="lineNum">    1020</span>                 :<span class="tlaGNC tlaBgGNC">         758 :     m_recv_state = recv_state;</span></span>
<span id="L1021"><span class="lineNum">    1021</span>                 :<span class="tlaGNC">         758 : }</span></span>
<span id="L1022"><span class="lineNum">    1022</span>                 :             : </span>
<span id="L1023"><span class="lineNum">    1023</span>                 :<span class="tlaGNC">         112 : void V2Transport::SetSendState(SendState send_state) noexcept</span></span>
<span id="L1024"><span class="lineNum">    1024</span>                 :             : {</span>
<span id="L1025"><span class="lineNum">    1025</span>                 :<span class="tlaGNC">         112 :     AssertLockHeld(m_send_mutex);</span></span>
<span id="L1026"><span class="lineNum">    1026</span>                 :             :     // Enforce allowed state transitions.</span>
<span id="L1027"><span class="lineNum">    1027</span>   [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 73 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         112 :     switch (m_send_state) {</span></span>
<span id="L1028"><span class="lineNum">    1028</span>                 :<span class="tlaGNC">          39 :     case SendState::MAYBE_V1:</span></span>
<span id="L1029"><span class="lineNum">    1029</span>                 :<span class="tlaGNC">          39 :         Assume(send_state == SendState::V1 || send_state == SendState::AWAITING_KEY);</span></span>
<span id="L1030"><span class="lineNum">    1030</span>                 :<span class="tlaGNC">          39 :         break;</span></span>
<span id="L1031"><span class="lineNum">    1031</span>                 :<span class="tlaGNC">          73 :     case SendState::AWAITING_KEY:</span></span>
<span id="L1032"><span class="lineNum">    1032</span>                 :<span class="tlaGNC">          73 :         Assume(send_state == SendState::READY);</span></span>
<span id="L1033"><span class="lineNum">    1033</span>                 :<span class="tlaGNC">          73 :         break;</span></span>
<span id="L1034"><span class="lineNum">    1034</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     case SendState::READY:</span></span>
<span id="L1035"><span class="lineNum">    1035</span>                 :<span class="tlaUNC">           0 :     case SendState::V1:</span></span>
<span id="L1036"><span class="lineNum">    1036</span>                 :<span class="tlaUNC">           0 :         Assume(false); // Final states</span></span>
<span id="L1037"><span class="lineNum">    1037</span>                 :<span class="tlaUNC">           0 :         break;</span></span>
<span id="L1038"><span class="lineNum">    1038</span>                 :             :     }</span>
<span id="L1039"><span class="lineNum">    1039</span>                 :             :     // Change state.</span>
<span id="L1040"><span class="lineNum">    1040</span>                 :<span class="tlaGNC tlaBgGNC">         112 :     m_send_state = send_state;</span></span>
<span id="L1041"><span class="lineNum">    1041</span>                 :<span class="tlaGNC">         112 : }</span></span>
<span id="L1042"><span class="lineNum">    1042</span>                 :             : </span>
<span id="L1043"><span class="lineNum">    1043</span>                 :<span class="tlaGNC">        3002 : bool V2Transport::ReceivedMessageComplete() const noexcept</span></span>
<span id="L1044"><span class="lineNum">    1044</span>                 :             : {</span>
<span id="L1045"><span class="lineNum">    1045</span>                 :<span class="tlaGNC">        3002 :     AssertLockNotHeld(m_recv_mutex);</span></span>
<span id="L1046"><span class="lineNum">    1046</span>                 :<span class="tlaGNC">        3002 :     LOCK(m_recv_mutex);</span></span>
<span id="L1047"><span class="lineNum">    1047</span>         [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2998 times"> + </span>]:<span class="tlaGNC">        3002 :     if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedMessageComplete();</span></span>
<span id="L1048"><span class="lineNum">    1048</span>                 :             : </span>
<span id="L1049"><span class="lineNum">    1049</span>                 :<span class="tlaGNC">        2998 :     return m_recv_state == RecvState::APP_READY;</span></span>
<span id="L1050"><span class="lineNum">    1050</span>                 :<span class="tlaGNC">        3002 : }</span></span>
<span id="L1051"><span class="lineNum">    1051</span>                 :             : </span>
<span id="L1052"><span class="lineNum">    1052</span>                 :<span class="tlaGNC">          39 : void V2Transport::ProcessReceivedMaybeV1Bytes() noexcept</span></span>
<span id="L1053"><span class="lineNum">    1053</span>                 :             : {</span>
<span id="L1054"><span class="lineNum">    1054</span>                 :<span class="tlaGNC">          39 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L1055"><span class="lineNum">    1055</span>                 :<span class="tlaGNC">          39 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1056"><span class="lineNum">    1056</span>                 :<span class="tlaGNC">          39 :     Assume(m_recv_state == RecvState::KEY_MAYBE_V1);</span></span>
<span id="L1057"><span class="lineNum">    1057</span>                 :             :     // We still have to determine if this is a v1 or v2 connection. The bytes being received could</span>
<span id="L1058"><span class="lineNum">    1058</span>                 :             :     // be the beginning of either a v1 packet (network magic + &quot;version\x00\x00\x00\x00\x00&quot;), or</span>
<span id="L1059"><span class="lineNum">    1059</span>                 :             :     // of a v2 public key. BIP324 specifies that a mismatch with this 16-byte string should trigger</span>
<span id="L1060"><span class="lineNum">    1060</span>                 :             :     // sending of the key.</span>
<span id="L1061"><span class="lineNum">    1061</span>                 :<span class="tlaGNC">          39 :     std::array&lt;uint8_t, V1_PREFIX_LEN&gt; v1_prefix = {0, 0, 0, 0, 'v', 'e', 'r', 's', 'i', 'o', 'n', 0, 0, 0, 0, 0};</span></span>
<span id="L1062"><span class="lineNum">    1062</span>                 :<span class="tlaGNC">          39 :     std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), v1_prefix.begin());</span></span>
<span id="L1063"><span class="lineNum">    1063</span>                 :<span class="tlaGNC">          39 :     Assume(m_recv_buffer.size() &lt;= v1_prefix.size());</span></span>
<span id="L1064"><span class="lineNum">    1064</span>         [<span class="tlaGBC" title="Branch 0 was taken 38 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">          39 :     if (!std::equal(m_recv_buffer.begin(), m_recv_buffer.end(), v1_prefix.begin())) {</span></span>
<span id="L1065"><span class="lineNum">    1065</span>                 :             :         // Mismatch with v1 prefix, so we can assume a v2 connection.</span>
<span id="L1066"><span class="lineNum">    1066</span>                 :<span class="tlaGNC">          38 :         SetReceiveState(RecvState::KEY); // Convert to KEY state, leaving received bytes around.</span></span>
<span id="L1067"><span class="lineNum">    1067</span>                 :             :         // Transition the sender to AWAITING_KEY state and start sending.</span>
<span id="L1068"><span class="lineNum">    1068</span>                 :<span class="tlaGNC">          38 :         LOCK(m_send_mutex);</span></span>
<span id="L1069"><span class="lineNum">    1069</span>                 :<span class="tlaGNC">          38 :         SetSendState(SendState::AWAITING_KEY);</span></span>
<span id="L1070"><span class="lineNum">    1070</span>         [<span class="tlaGBC" title="Branch 0 was taken 38 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          38 :         StartSendingHandshake();</span></span>
<span id="L1071"><span class="lineNum">    1071</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          39 :     } else if (m_recv_buffer.size() == v1_prefix.size()) {</span></span>
<span id="L1072"><span class="lineNum">    1072</span>                 :             :         // Full match with the v1 prefix, so fall back to v1 behavior.</span>
<span id="L1073"><span class="lineNum">    1073</span>                 :<span class="tlaGNC">           1 :         LOCK(m_send_mutex);</span></span>
<span id="L1074"><span class="lineNum">    1074</span>                 :<span class="tlaGNC">           1 :         Span&lt;const uint8_t&gt; feedback{m_recv_buffer};</span></span>
<span id="L1075"><span class="lineNum">    1075</span>                 :             :         // Feed already received bytes to v1 transport. It should always accept these, because it's</span>
<span id="L1076"><span class="lineNum">    1076</span>                 :             :         // less than the size of a v1 header, and these are the first bytes fed to m_v1_fallback.</span>
<span id="L1077"><span class="lineNum">    1077</span>                 :<span class="tlaGNC">           1 :         bool ret = m_v1_fallback.ReceivedBytes(feedback);</span></span>
<span id="L1078"><span class="lineNum">    1078</span>                 :<span class="tlaGNC">           1 :         Assume(feedback.empty());</span></span>
<span id="L1079"><span class="lineNum">    1079</span>                 :<span class="tlaGNC">           1 :         Assume(ret);</span></span>
<span id="L1080"><span class="lineNum">    1080</span>                 :<span class="tlaGNC">           1 :         SetReceiveState(RecvState::V1);</span></span>
<span id="L1081"><span class="lineNum">    1081</span>                 :<span class="tlaGNC">           1 :         SetSendState(SendState::V1);</span></span>
<span id="L1082"><span class="lineNum">    1082</span>                 :             :         // Reset v2 transport buffers to save memory.</span>
<span id="L1083"><span class="lineNum">    1083</span>                 :<span class="tlaGNC">           1 :         ClearShrink(m_recv_buffer);</span></span>
<span id="L1084"><span class="lineNum">    1084</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :         ClearShrink(m_send_buffer);</span></span>
<span id="L1085"><span class="lineNum">    1085</span>                 :<span class="tlaGNC">           1 :     } else {</span></span>
<span id="L1086"><span class="lineNum">    1086</span>                 :             :         // We have not received enough to distinguish v1 from v2 yet. Wait until more bytes come.</span>
<span id="L1087"><span class="lineNum">    1087</span>                 :             :     }</span>
<span id="L1088"><span class="lineNum">    1088</span>                 :<span class="tlaGNC">          39 : }</span></span>
<span id="L1089"><span class="lineNum">    1089</span>                 :             : </span>
<span id="L1090"><span class="lineNum">    1090</span>                 :<span class="tlaGNC">         150 : bool V2Transport::ProcessReceivedKeyBytes() noexcept</span></span>
<span id="L1091"><span class="lineNum">    1091</span>                 :             : {</span>
<span id="L1092"><span class="lineNum">    1092</span>                 :<span class="tlaGNC">         150 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L1093"><span class="lineNum">    1093</span>                 :<span class="tlaGNC">         150 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1094"><span class="lineNum">    1094</span>                 :<span class="tlaGNC">         150 :     Assume(m_recv_state == RecvState::KEY);</span></span>
<span id="L1095"><span class="lineNum">    1095</span>                 :<span class="tlaGNC">         150 :     Assume(m_recv_buffer.size() &lt;= EllSwiftPubKey::size());</span></span>
<span id="L1096"><span class="lineNum">    1096</span>                 :             : </span>
<span id="L1097"><span class="lineNum">    1097</span>                 :             :     // As a special exception, if bytes 4-16 of the key on a responder connection match the</span>
<span id="L1098"><span class="lineNum">    1098</span>                 :             :     // corresponding bytes of a V1 version message, but bytes 0-4 don't match the network magic</span>
<span id="L1099"><span class="lineNum">    1099</span>                 :             :     // (if they did, we'd have switched to V1 state already), assume this is a peer from</span>
<span id="L1100"><span class="lineNum">    1100</span>                 :             :     // another network, and disconnect them. They will almost certainly disconnect us too when</span>
<span id="L1101"><span class="lineNum">    1101</span>                 :             :     // they receive our uniformly random key and garbage, but detecting this case specially</span>
<span id="L1102"><span class="lineNum">    1102</span>                 :             :     // means we can log it.</span>
<span id="L1103"><span class="lineNum">    1103</span>                 :<span class="tlaGNC">         150 :     static constexpr std::array&lt;uint8_t, 12&gt; MATCH = {'v', 'e', 'r', 's', 'i', 'o', 'n', 0, 0, 0, 0, 0};</span></span>
<span id="L1104"><span class="lineNum">    1104</span>                 :<span class="tlaGNC">         150 :     static constexpr size_t OFFSET = std::tuple_size_v&lt;MessageStartChars&gt;;</span></span>
<span id="L1105"><span class="lineNum">    1105</span>   [<span class="tlaGBC" title="Branch 0 was taken 94 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 56 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 92 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 2 times"> + </span>]:<span class="tlaGNC">         150 :     if (!m_initiating &amp;&amp; m_recv_buffer.size() &gt;= OFFSET + MATCH.size()) {</span></span>
<span id="L1106"><span class="lineNum">    1106</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 91 times"> + </span>]:<span class="tlaGNC">          92 :         if (std::equal(MATCH.begin(), MATCH.end(), m_recv_buffer.begin() + OFFSET)) {</span></span>
<span id="L1107"><span class="lineNum">    1107</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :             LogDebug(BCLog::NET, &quot;V2 transport error: V1 peer with wrong MessageStart %s\n&quot;,</span></span>
<span id="L1108"><span class="lineNum">    1108</span>                 :             :                      HexStr(Span(m_recv_buffer).first(OFFSET)));</span>
<span id="L1109"><span class="lineNum">    1109</span>                 :<span class="tlaGNC">           1 :             return false;</span></span>
<span id="L1110"><span class="lineNum">    1110</span>                 :             :         }</span>
<span id="L1111"><span class="lineNum">    1111</span>                 :             :     }</span>
<span id="L1112"><span class="lineNum">    1112</span>                 :             : </span>
<span id="L1113"><span class="lineNum">    1113</span>         [<span class="tlaGBC" title="Branch 0 was taken 73 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 76 times"> + </span>]:<span class="tlaGNC">         149 :     if (m_recv_buffer.size() == EllSwiftPubKey::size()) {</span></span>
<span id="L1114"><span class="lineNum">    1114</span>                 :             :         // Other side's key has been fully received, and can now be Diffie-Hellman combined with</span>
<span id="L1115"><span class="lineNum">    1115</span>                 :             :         // our key to initialize the encryption ciphers.</span>
<span id="L1116"><span class="lineNum">    1116</span>                 :             : </span>
<span id="L1117"><span class="lineNum">    1117</span>                 :             :         // Initialize the ciphers.</span>
<span id="L1118"><span class="lineNum">    1118</span>                 :<span class="tlaGNC">          73 :         EllSwiftPubKey ellswift(MakeByteSpan(m_recv_buffer));</span></span>
<span id="L1119"><span class="lineNum">    1119</span>                 :<span class="tlaGNC">          73 :         LOCK(m_send_mutex);</span></span>
<span id="L1120"><span class="lineNum">    1120</span>                 :<span class="tlaGNC">          73 :         m_cipher.Initialize(ellswift, m_initiating);</span></span>
<span id="L1121"><span class="lineNum">    1121</span>                 :             : </span>
<span id="L1122"><span class="lineNum">    1122</span>                 :             :         // Switch receiver state to GARB_GARBTERM.</span>
<span id="L1123"><span class="lineNum">    1123</span>                 :<span class="tlaGNC">          73 :         SetReceiveState(RecvState::GARB_GARBTERM);</span></span>
<span id="L1124"><span class="lineNum">    1124</span>         [<span class="tlaGBC" title="Branch 0 was taken 73 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          73 :         m_recv_buffer.clear();</span></span>
<span id="L1125"><span class="lineNum">    1125</span>                 :             : </span>
<span id="L1126"><span class="lineNum">    1126</span>                 :             :         // Switch sender state to READY.</span>
<span id="L1127"><span class="lineNum">    1127</span>                 :<span class="tlaGNC">          73 :         SetSendState(SendState::READY);</span></span>
<span id="L1128"><span class="lineNum">    1128</span>                 :             : </span>
<span id="L1129"><span class="lineNum">    1129</span>                 :             :         // Append the garbage terminator to the send buffer.</span>
<span id="L1130"><span class="lineNum">    1130</span>                 :<span class="tlaGNC">          73 :         m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::GARBAGE_TERMINATOR_LEN);</span></span>
<span id="L1131"><span class="lineNum">    1131</span>                 :<span class="tlaGNC">         146 :         std::copy(m_cipher.GetSendGarbageTerminator().begin(),</span></span>
<span id="L1132"><span class="lineNum">    1132</span>                 :<span class="tlaGNC">          73 :                   m_cipher.GetSendGarbageTerminator().end(),</span></span>
<span id="L1133"><span class="lineNum">    1133</span>                 :<span class="tlaGNC">          73 :                   MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());</span></span>
<span id="L1134"><span class="lineNum">    1134</span>                 :             : </span>
<span id="L1135"><span class="lineNum">    1135</span>                 :             :         // Construct version packet in the send buffer, with the sent garbage data as AAD.</span>
<span id="L1136"><span class="lineNum">    1136</span>                 :<span class="tlaGNC">          73 :         m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + VERSION_CONTENTS.size());</span></span>
<span id="L1137"><span class="lineNum">    1137</span>                 :<span class="tlaGNC">          73 :         m_cipher.Encrypt(</span></span>
<span id="L1138"><span class="lineNum">    1138</span>                 :             :             /*contents=*/VERSION_CONTENTS,</span>
<span id="L1139"><span class="lineNum">    1139</span>                 :<span class="tlaGNC">          73 :             /*aad=*/MakeByteSpan(m_send_garbage),</span></span>
<span id="L1140"><span class="lineNum">    1140</span>                 :             :             /*ignore=*/false,</span>
<span id="L1141"><span class="lineNum">    1141</span>                 :<span class="tlaGNC">          73 :             /*output=*/MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + VERSION_CONTENTS.size()));</span></span>
<span id="L1142"><span class="lineNum">    1142</span>                 :             :         // We no longer need the garbage.</span>
<span id="L1143"><span class="lineNum">    1143</span>         [<span class="tlaGBC" title="Branch 0 was taken 73 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          73 :         ClearShrink(m_send_garbage);</span></span>
<span id="L1144"><span class="lineNum">    1144</span>                 :<span class="tlaGNC">          73 :     } else {</span></span>
<span id="L1145"><span class="lineNum">    1145</span>                 :             :         // We still have to receive more key bytes.</span>
<span id="L1146"><span class="lineNum">    1146</span>                 :             :     }</span>
<span id="L1147"><span class="lineNum">    1147</span>                 :             :     return true;</span>
<span id="L1148"><span class="lineNum">    1148</span>                 :             : }</span>
<span id="L1149"><span class="lineNum">    1149</span>                 :             : </span>
<span id="L1150"><span class="lineNum">    1150</span>                 :<span class="tlaGNC">      136925 : bool V2Transport::ProcessReceivedGarbageBytes() noexcept</span></span>
<span id="L1151"><span class="lineNum">    1151</span>                 :             : {</span>
<span id="L1152"><span class="lineNum">    1152</span>                 :<span class="tlaGNC">      136925 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L1153"><span class="lineNum">    1153</span>                 :<span class="tlaGNC">      136925 :     Assume(m_recv_state == RecvState::GARB_GARBTERM);</span></span>
<span id="L1154"><span class="lineNum">    1154</span>                 :<span class="tlaGNC">      136925 :     Assume(m_recv_buffer.size() &lt;= MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);</span></span>
<span id="L1155"><span class="lineNum">    1155</span>         [<span class="tlaGBC" title="Branch 0 was taken 135830 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1095 times"> + </span>]:<span class="tlaGNC">      136925 :     if (m_recv_buffer.size() &gt;= BIP324Cipher::GARBAGE_TERMINATOR_LEN) {</span></span>
<span id="L1156"><span class="lineNum">    1156</span>         [<span class="tlaGBC" title="Branch 0 was taken 71 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 135759 times"> + </span>]:<span class="tlaGNC">      271660 :         if (std::ranges::equal(MakeByteSpan(m_recv_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN), m_cipher.GetReceiveGarbageTerminator())) {</span></span>
<span id="L1157"><span class="lineNum">    1157</span>                 :             :             // Garbage terminator received. Store garbage to authenticate it as AAD later.</span>
<span id="L1158"><span class="lineNum">    1158</span>                 :<span class="tlaGNC">          71 :             m_recv_aad = std::move(m_recv_buffer);</span></span>
<span id="L1159"><span class="lineNum">    1159</span>                 :<span class="tlaGNC">          71 :             m_recv_aad.resize(m_recv_aad.size() - BIP324Cipher::GARBAGE_TERMINATOR_LEN);</span></span>
<span id="L1160"><span class="lineNum">    1160</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 71 times"> + </span>]:<span class="tlaGNC">          71 :             m_recv_buffer.clear();</span></span>
<span id="L1161"><span class="lineNum">    1161</span>                 :<span class="tlaGNC">          71 :             SetReceiveState(RecvState::VERSION);</span></span>
<span id="L1162"><span class="lineNum">    1162</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 135757 times"> + </span>]:<span class="tlaGNC">      135759 :         } else if (m_recv_buffer.size() == MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN) {</span></span>
<span id="L1163"><span class="lineNum">    1163</span>                 :             :             // We've reached the maximum length for garbage + garbage terminator, and the</span>
<span id="L1164"><span class="lineNum">    1164</span>                 :             :             // terminator still does not match. Abort.</span>
<span id="L1165"><span class="lineNum">    1165</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :             LogDebug(BCLog::NET, &quot;V2 transport error: missing garbage terminator, peer=%d\n&quot;, m_nodeid);</span></span>
<span id="L1166"><span class="lineNum">    1166</span>                 :<span class="tlaGNC">           2 :             return false;</span></span>
<span id="L1167"><span class="lineNum">    1167</span>                 :             :         } else {</span>
<span id="L1168"><span class="lineNum">    1168</span>                 :             :             // We still need to receive more garbage and/or garbage terminator bytes.</span>
<span id="L1169"><span class="lineNum">    1169</span>                 :             :         }</span>
<span id="L1170"><span class="lineNum">    1170</span>                 :             :     } else {</span>
<span id="L1171"><span class="lineNum">    1171</span>                 :             :         // We have less than GARBAGE_TERMINATOR_LEN (16) bytes, so we certainly need to receive</span>
<span id="L1172"><span class="lineNum">    1172</span>                 :             :         // more first.</span>
<span id="L1173"><span class="lineNum">    1173</span>                 :             :     }</span>
<span id="L1174"><span class="lineNum">    1174</span>                 :             :     return true;</span>
<span id="L1175"><span class="lineNum">    1175</span>                 :             : }</span>
<span id="L1176"><span class="lineNum">    1176</span>                 :             : </span>
<span id="L1177"><span class="lineNum">    1177</span>                 :<span class="tlaGNC">      102324 : bool V2Transport::ProcessReceivedPacketBytes() noexcept</span></span>
<span id="L1178"><span class="lineNum">    1178</span>                 :             : {</span>
<span id="L1179"><span class="lineNum">    1179</span>                 :<span class="tlaGNC">      102324 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L1180"><span class="lineNum">    1180</span>                 :<span class="tlaGNC">      102324 :     Assume(m_recv_state == RecvState::VERSION || m_recv_state == RecvState::APP);</span></span>
<span id="L1181"><span class="lineNum">    1181</span>                 :             : </span>
<span id="L1182"><span class="lineNum">    1182</span>                 :             :     // The maximum permitted contents length for a packet, consisting of:</span>
<span id="L1183"><span class="lineNum">    1183</span>                 :             :     // - 0x00 byte: indicating long message type encoding</span>
<span id="L1184"><span class="lineNum">    1184</span>                 :             :     // - 12 bytes of message type</span>
<span id="L1185"><span class="lineNum">    1185</span>                 :             :     // - payload</span>
<span id="L1186"><span class="lineNum">    1186</span>                 :<span class="tlaGNC">      102324 :     static constexpr size_t MAX_CONTENTS_LEN =</span></span>
<span id="L1187"><span class="lineNum">    1187</span>                 :             :         1 + CMessageHeader::COMMAND_SIZE +</span>
<span id="L1188"><span class="lineNum">    1188</span>                 :             :         std::min&lt;size_t&gt;(MAX_SIZE, MAX_PROTOCOL_MESSAGE_LENGTH);</span>
<span id="L1189"><span class="lineNum">    1189</span>                 :             : </span>
<span id="L1190"><span class="lineNum">    1190</span>         [<span class="tlaGBC" title="Branch 0 was taken 50447 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 51877 times"> + </span>]:<span class="tlaGNC">      102324 :     if (m_recv_buffer.size() == BIP324Cipher::LENGTH_LEN) {</span></span>
<span id="L1191"><span class="lineNum">    1191</span>                 :             :         // Length descriptor received.</span>
<span id="L1192"><span class="lineNum">    1192</span>                 :<span class="tlaGNC">       50447 :         m_recv_len = m_cipher.DecryptLength(MakeByteSpan(m_recv_buffer));</span></span>
<span id="L1193"><span class="lineNum">    1193</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 50437 times"> + </span>]:<span class="tlaGNC">       50447 :         if (m_recv_len &gt; MAX_CONTENTS_LEN) {</span></span>
<span id="L1194"><span class="lineNum">    1194</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          10 :             LogDebug(BCLog::NET, &quot;V2 transport error: packet too large (%u bytes), peer=%d\n&quot;, m_recv_len, m_nodeid);</span></span>
<span id="L1195"><span class="lineNum">    1195</span>                 :<span class="tlaGNC">          10 :             return false;</span></span>
<span id="L1196"><span class="lineNum">    1196</span>                 :             :         }</span>
<span id="L1197"><span class="lineNum">    1197</span>   [<span class="tlaGBC" title="Branch 0 was taken 51862 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 15 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 50437 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 1425 times"> + </span>]:<span class="tlaGNC">       51877 :     } else if (m_recv_buffer.size() &gt; BIP324Cipher::LENGTH_LEN &amp;&amp; m_recv_buffer.size() == m_recv_len + BIP324Cipher::EXPANSION) {</span></span>
<span id="L1198"><span class="lineNum">    1198</span>                 :             :         // Ciphertext received, decrypt it into m_recv_decode_buffer.</span>
<span id="L1199"><span class="lineNum">    1199</span>                 :             :         // Note that it is impossible to reach this branch without hitting the branch above first,</span>
<span id="L1200"><span class="lineNum">    1200</span>                 :             :         // as GetMaxBytesToProcess only allows up to LENGTH_LEN into the buffer before that point.</span>
<span id="L1201"><span class="lineNum">    1201</span>                 :<span class="tlaGNC">       50437 :         m_recv_decode_buffer.resize(m_recv_len);</span></span>
<span id="L1202"><span class="lineNum">    1202</span>                 :<span class="tlaGNC">       50437 :         bool ignore{false};</span></span>
<span id="L1203"><span class="lineNum">    1203</span>                 :<span class="tlaGNC">      100874 :         bool ret = m_cipher.Decrypt(</span></span>
<span id="L1204"><span class="lineNum">    1204</span>                 :<span class="tlaGNC">       50437 :             /*input=*/MakeByteSpan(m_recv_buffer).subspan(BIP324Cipher::LENGTH_LEN),</span></span>
<span id="L1205"><span class="lineNum">    1205</span>                 :<span class="tlaGNC">       50437 :             /*aad=*/MakeByteSpan(m_recv_aad),</span></span>
<span id="L1206"><span class="lineNum">    1206</span>                 :             :             /*ignore=*/ignore,</span>
<span id="L1207"><span class="lineNum">    1207</span>                 :             :             /*contents=*/MakeWritableByteSpan(m_recv_decode_buffer));</span>
<span id="L1208"><span class="lineNum">    1208</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 50427 times"> + </span>]:<span class="tlaGNC">       50437 :         if (!ret) {</span></span>
<span id="L1209"><span class="lineNum">    1209</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          10 :             LogDebug(BCLog::NET, &quot;V2 transport error: packet decryption failure (%u bytes), peer=%d\n&quot;, m_recv_len, m_nodeid);</span></span>
<span id="L1210"><span class="lineNum">    1210</span>                 :<span class="tlaGNC">          10 :             return false;</span></span>
<span id="L1211"><span class="lineNum">    1211</span>                 :             :         }</span>
<span id="L1212"><span class="lineNum">    1212</span>                 :             :         // We have decrypted a valid packet with the AAD we expected, so clear the expected AAD.</span>
<span id="L1213"><span class="lineNum">    1213</span>                 :<span class="tlaGNC">       50427 :         ClearShrink(m_recv_aad);</span></span>
<span id="L1214"><span class="lineNum">    1214</span>                 :             :         // Feed the last 4 bytes of the Poly1305 authentication tag (and its timing) into our RNG.</span>
<span id="L1215"><span class="lineNum">    1215</span>                 :<span class="tlaGNC">       50427 :         RandAddEvent(ReadLE32(m_recv_buffer.data() + m_recv_buffer.size() - 4));</span></span>
<span id="L1216"><span class="lineNum">    1216</span>                 :             : </span>
<span id="L1217"><span class="lineNum">    1217</span>                 :             :         // At this point we have a valid packet decrypted into m_recv_decode_buffer. If it's not a</span>
<span id="L1218"><span class="lineNum">    1218</span>                 :             :         // decoy, which we simply ignore, use the current state to decide what to do with it.</span>
<span id="L1219"><span class="lineNum">    1219</span>         [<span class="tlaGBC" title="Branch 0 was taken 323 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 50104 times"> + </span>]:<span class="tlaGNC">       50427 :         if (!ignore) {</span></span>
<span id="L1220"><span class="lineNum">    1220</span>      [<span class="tlaGBC" title="Branch 0 was taken 71 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 252 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span>]:<span class="tlaGNC">         323 :             switch (m_recv_state) {</span></span>
<span id="L1221"><span class="lineNum">    1221</span>                 :<span class="tlaGNC">          71 :             case RecvState::VERSION:</span></span>
<span id="L1222"><span class="lineNum">    1222</span>                 :             :                 // Version message received; transition to application phase. The contents is</span>
<span id="L1223"><span class="lineNum">    1223</span>                 :             :                 // ignored, but can be used for future extensions.</span>
<span id="L1224"><span class="lineNum">    1224</span>                 :<span class="tlaGNC">          71 :                 SetReceiveState(RecvState::APP);</span></span>
<span id="L1225"><span class="lineNum">    1225</span>                 :<span class="tlaGNC">          71 :                 break;</span></span>
<span id="L1226"><span class="lineNum">    1226</span>                 :<span class="tlaGNC">         252 :             case RecvState::APP:</span></span>
<span id="L1227"><span class="lineNum">    1227</span>                 :             :                 // Application message decrypted correctly. It can be extracted using GetMessage().</span>
<span id="L1228"><span class="lineNum">    1228</span>                 :<span class="tlaGNC">         252 :                 SetReceiveState(RecvState::APP_READY);</span></span>
<span id="L1229"><span class="lineNum">    1229</span>                 :<span class="tlaGNC">         252 :                 break;</span></span>
<span id="L1230"><span class="lineNum">    1230</span>                 :<span class="tlaUNC tlaBgUNC">           0 :             default:</span></span>
<span id="L1231"><span class="lineNum">    1231</span>                 :             :                 // Any other state is invalid (this function should not have been called).</span>
<span id="L1232"><span class="lineNum">    1232</span>                 :<span class="tlaUNC">           0 :                 Assume(false);</span></span>
<span id="L1233"><span class="lineNum">    1233</span>                 :             :             }</span>
<span id="L1234"><span class="lineNum">    1234</span>                 :             :         }</span>
<span id="L1235"><span class="lineNum">    1235</span>                 :             :         // Wipe the receive buffer where the next packet will be received into.</span>
<span id="L1236"><span class="lineNum">    1236</span>                 :<span class="tlaGNC tlaBgGNC">       50427 :         ClearShrink(m_recv_buffer);</span></span>
<span id="L1237"><span class="lineNum">    1237</span>                 :             :         // In all but APP_READY state, we can wipe the decoded contents.</span>
<span id="L1238"><span class="lineNum">    1238</span>         [<span class="tlaGBC" title="Branch 0 was taken 50175 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 252 times"> + </span>]:<span class="tlaGNC">       50427 :         if (m_recv_state != RecvState::APP_READY) ClearShrink(m_recv_decode_buffer);</span></span>
<span id="L1239"><span class="lineNum">    1239</span>                 :             :     } else {</span>
<span id="L1240"><span class="lineNum">    1240</span>                 :             :         // We either have less than 3 bytes, so we don't know the packet's length yet, or more</span>
<span id="L1241"><span class="lineNum">    1241</span>                 :             :         // than 3 bytes but less than the packet's full ciphertext. Wait until those arrive.</span>
<span id="L1242"><span class="lineNum">    1242</span>                 :             :     }</span>
<span id="L1243"><span class="lineNum">    1243</span>                 :             :     return true;</span>
<span id="L1244"><span class="lineNum">    1244</span>                 :             : }</span>
<span id="L1245"><span class="lineNum">    1245</span>                 :             : </span>
<span id="L1246"><span class="lineNum">    1246</span>                 :<span class="tlaGNC">      239715 : size_t V2Transport::GetMaxBytesToProcess() noexcept</span></span>
<span id="L1247"><span class="lineNum">    1247</span>                 :             : {</span>
<span id="L1248"><span class="lineNum">    1248</span>                 :<span class="tlaGNC">      239715 :     AssertLockHeld(m_recv_mutex);</span></span>
<span id="L1249"><span class="lineNum">    1249</span>   [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 150 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 102324 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 277 times"> + </span> :<span class="tlaGNC">      239715 :     switch (m_recv_state) {</span></span>
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 136925 times"> + </span>]
<span id="L1250"><span class="lineNum">    1250</span>                 :<span class="tlaGNC">          39 :     case RecvState::KEY_MAYBE_V1:</span></span>
<span id="L1251"><span class="lineNum">    1251</span>                 :             :         // During the KEY_MAYBE_V1 state we do not allow more than the length of v1 prefix into the</span>
<span id="L1252"><span class="lineNum">    1252</span>                 :             :         // receive buffer.</span>
<span id="L1253"><span class="lineNum">    1253</span>                 :<span class="tlaGNC">          39 :         Assume(m_recv_buffer.size() &lt;= V1_PREFIX_LEN);</span></span>
<span id="L1254"><span class="lineNum">    1254</span>                 :             :         // As long as we're not sure if this is a v1 or v2 connection, don't receive more than what</span>
<span id="L1255"><span class="lineNum">    1255</span>                 :             :         // is strictly necessary to distinguish the two (16 bytes). If we permitted more than</span>
<span id="L1256"><span class="lineNum">    1256</span>                 :             :         // the v1 header size (24 bytes), we may not be able to feed the already-received bytes</span>
<span id="L1257"><span class="lineNum">    1257</span>                 :             :         // back into the m_v1_fallback V1 transport.</span>
<span id="L1258"><span class="lineNum">    1258</span>                 :<span class="tlaGNC">          39 :         return V1_PREFIX_LEN - m_recv_buffer.size();</span></span>
<span id="L1259"><span class="lineNum">    1259</span>                 :<span class="tlaGNC">         150 :     case RecvState::KEY:</span></span>
<span id="L1260"><span class="lineNum">    1260</span>                 :             :         // During the KEY state, we only allow the 64-byte key into the receive buffer.</span>
<span id="L1261"><span class="lineNum">    1261</span>                 :<span class="tlaGNC">         150 :         Assume(m_recv_buffer.size() &lt;= EllSwiftPubKey::size());</span></span>
<span id="L1262"><span class="lineNum">    1262</span>                 :             :         // As long as we have not received the other side's public key, don't receive more than</span>
<span id="L1263"><span class="lineNum">    1263</span>                 :             :         // that (64 bytes), as garbage follows, and locating the garbage terminator requires the</span>
<span id="L1264"><span class="lineNum">    1264</span>                 :             :         // key exchange first.</span>
<span id="L1265"><span class="lineNum">    1265</span>                 :<span class="tlaGNC">         150 :         return EllSwiftPubKey::size() - m_recv_buffer.size();</span></span>
<span id="L1266"><span class="lineNum">    1266</span>                 :             :     case RecvState::GARB_GARBTERM:</span>
<span id="L1267"><span class="lineNum">    1267</span>                 :             :         // Process garbage bytes one by one (because terminator may appear anywhere).</span>
<span id="L1268"><span class="lineNum">    1268</span>                 :             :         return 1;</span>
<span id="L1269"><span class="lineNum">    1269</span>                 :<span class="tlaGNC">      102324 :     case RecvState::VERSION:</span></span>
<span id="L1270"><span class="lineNum">    1270</span>                 :<span class="tlaGNC">      102324 :     case RecvState::APP:</span></span>
<span id="L1271"><span class="lineNum">    1271</span>                 :             :         // These three states all involve decoding a packet. Process the length descriptor first,</span>
<span id="L1272"><span class="lineNum">    1272</span>                 :             :         // so that we know where the current packet ends (and we don't process bytes from the next</span>
<span id="L1273"><span class="lineNum">    1273</span>                 :             :         // packet or decoy yet). Then, process the ciphertext bytes of the current packet.</span>
<span id="L1274"><span class="lineNum">    1274</span>         [<span class="tlaGBC" title="Branch 0 was taken 50462 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 51862 times"> + </span>]:<span class="tlaGNC">      102324 :         if (m_recv_buffer.size() &lt; BIP324Cipher::LENGTH_LEN) {</span></span>
<span id="L1275"><span class="lineNum">    1275</span>                 :<span class="tlaGNC">       50462 :             return BIP324Cipher::LENGTH_LEN - m_recv_buffer.size();</span></span>
<span id="L1276"><span class="lineNum">    1276</span>                 :             :         } else {</span>
<span id="L1277"><span class="lineNum">    1277</span>                 :             :             // Note that BIP324Cipher::EXPANSION is the total difference between contents size</span>
<span id="L1278"><span class="lineNum">    1278</span>                 :             :             // and encoded packet size, which includes the 3 bytes due to the packet length.</span>
<span id="L1279"><span class="lineNum">    1279</span>                 :             :             // When transitioning from receiving the packet length to receiving its ciphertext,</span>
<span id="L1280"><span class="lineNum">    1280</span>                 :             :             // the encrypted packet length is left in the receive buffer.</span>
<span id="L1281"><span class="lineNum">    1281</span>                 :<span class="tlaGNC">       51862 :             return BIP324Cipher::EXPANSION + m_recv_len - m_recv_buffer.size();</span></span>
<span id="L1282"><span class="lineNum">    1282</span>                 :             :         }</span>
<span id="L1283"><span class="lineNum">    1283</span>                 :<span class="tlaGNC">         277 :     case RecvState::APP_READY:</span></span>
<span id="L1284"><span class="lineNum">    1284</span>                 :             :         // No bytes can be processed until GetMessage() is called.</span>
<span id="L1285"><span class="lineNum">    1285</span>                 :<span class="tlaGNC">         277 :         return 0;</span></span>
<span id="L1286"><span class="lineNum">    1286</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     case RecvState::V1:</span></span>
<span id="L1287"><span class="lineNum">    1287</span>                 :             :         // Not allowed (must be dealt with by the caller).</span>
<span id="L1288"><span class="lineNum">    1288</span>                 :<span class="tlaUNC">           0 :         Assume(false);</span></span>
<span id="L1289"><span class="lineNum">    1289</span>                 :<span class="tlaUNC">           0 :         return 0;</span></span>
<span id="L1290"><span class="lineNum">    1290</span>                 :             :     }</span>
<span id="L1291"><span class="lineNum">    1291</span>                 :<span class="tlaUNC">           0 :     Assume(false); // unreachable</span></span>
<span id="L1292"><span class="lineNum">    1292</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L1293"><span class="lineNum">    1293</span>                 :             : }</span>
<span id="L1294"><span class="lineNum">    1294</span>                 :             : </span>
<span id="L1295"><span class="lineNum">    1295</span>                 :<span class="tlaGNC tlaBgGNC">        2279 : bool V2Transport::ReceivedBytes(Span&lt;const uint8_t&gt;&amp; msg_bytes) noexcept</span></span>
<span id="L1296"><span class="lineNum">    1296</span>                 :             : {</span>
<span id="L1297"><span class="lineNum">    1297</span>                 :<span class="tlaGNC">        2279 :     AssertLockNotHeld(m_recv_mutex);</span></span>
<span id="L1298"><span class="lineNum">    1298</span>                 :             :     /** How many bytes to allocate in the receive buffer at most above what is received so far. */</span>
<span id="L1299"><span class="lineNum">    1299</span>                 :<span class="tlaGNC">        2279 :     static constexpr size_t MAX_RESERVE_AHEAD = 256 * 1024;</span></span>
<span id="L1300"><span class="lineNum">    1300</span>                 :             : </span>
<span id="L1301"><span class="lineNum">    1301</span>                 :<span class="tlaGNC">        2279 :     LOCK(m_recv_mutex);</span></span>
<span id="L1302"><span class="lineNum">    1302</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2277 times"> + </span>]:<span class="tlaGNC">        2279 :     if (m_recv_state == RecvState::V1) return m_v1_fallback.ReceivedBytes(msg_bytes);</span></span>
<span id="L1303"><span class="lineNum">    1303</span>                 :             : </span>
<span id="L1304"><span class="lineNum">    1304</span>                 :             :     // Process the provided bytes in msg_bytes in a loop. In each iteration a nonzero number of</span>
<span id="L1305"><span class="lineNum">    1305</span>                 :             :     // bytes (decided by GetMaxBytesToProcess) are taken from the beginning om msg_bytes, and</span>
<span id="L1306"><span class="lineNum">    1306</span>                 :             :     // appended to m_recv_buffer. Then, depending on the receiver state, one of the</span>
<span id="L1307"><span class="lineNum">    1307</span>                 :             :     // ProcessReceived*Bytes functions is called to process the bytes in that buffer.</span>
<span id="L1308"><span class="lineNum">    1308</span>         [<span class="tlaGBC" title="Branch 0 was taken 239715 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1976 times"> + </span>]:<span class="tlaGNC">      241691 :     while (!msg_bytes.empty()) {</span></span>
<span id="L1309"><span class="lineNum">    1309</span>                 :             :         // Decide how many bytes to copy from msg_bytes to m_recv_buffer.</span>
<span id="L1310"><span class="lineNum">    1310</span>                 :<span class="tlaGNC">      239715 :         size_t max_read = GetMaxBytesToProcess();</span></span>
<span id="L1311"><span class="lineNum">    1311</span>                 :             : </span>
<span id="L1312"><span class="lineNum">    1312</span>                 :             :         // Reserve space in the buffer if there is not enough.</span>
<span id="L1313"><span class="lineNum">    1313</span>   [<span class="tlaGBC" title="Branch 0 was taken 1989 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 237726 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 101015 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 138700 times"> + </span>]:<span class="tlaGNC">      241704 :         if (m_recv_buffer.size() + std::min(msg_bytes.size(), max_read) &gt; m_recv_buffer.capacity()) {</span></span>
<span id="L1314"><span class="lineNum">    1314</span>   [<span class="tlaGBC" title="Branch 0 was taken 75 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 100940 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">      101015 :             switch (m_recv_state) {</span></span>
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 4 was not taken"> - </span>]
<span id="L1315"><span class="lineNum">    1315</span>                 :<span class="tlaGNC">          75 :             case RecvState::KEY_MAYBE_V1:</span></span>
<span id="L1316"><span class="lineNum">    1316</span>                 :<span class="tlaGNC">          75 :             case RecvState::KEY:</span></span>
<span id="L1317"><span class="lineNum">    1317</span>                 :<span class="tlaGNC">          75 :             case RecvState::GARB_GARBTERM:</span></span>
<span id="L1318"><span class="lineNum">    1318</span>                 :             :                 // During the initial states (key/garbage), allocate once to fit the maximum (4111</span>
<span id="L1319"><span class="lineNum">    1319</span>                 :             :                 // bytes).</span>
<span id="L1320"><span class="lineNum">    1320</span>                 :<span class="tlaGNC">          75 :                 m_recv_buffer.reserve(MAX_GARBAGE_LEN + BIP324Cipher::GARBAGE_TERMINATOR_LEN);</span></span>
<span id="L1321"><span class="lineNum">    1321</span>                 :<span class="tlaGNC">          75 :                 break;</span></span>
<span id="L1322"><span class="lineNum">    1322</span>                 :<span class="tlaGNC">      100940 :             case RecvState::VERSION:</span></span>
<span id="L1323"><span class="lineNum">    1323</span>                 :<span class="tlaGNC">      100940 :             case RecvState::APP: {</span></span>
<span id="L1324"><span class="lineNum">    1324</span>                 :             :                 // During states where a packet is being received, as much as is expected but never</span>
<span id="L1325"><span class="lineNum">    1325</span>                 :             :                 // more than MAX_RESERVE_AHEAD bytes in addition to what is received so far.</span>
<span id="L1326"><span class="lineNum">    1326</span>                 :             :                 // This means attackers that want to cause us to waste allocated memory are limited</span>
<span id="L1327"><span class="lineNum">    1327</span>                 :             :                 // to MAX_RESERVE_AHEAD above the largest allowed message contents size, and to</span>
<span id="L1328"><span class="lineNum">    1328</span>                 :             :                 // MAX_RESERVE_AHEAD more than they've actually sent us.</span>
<span id="L1329"><span class="lineNum">    1329</span>         [<span class="tlaGBC" title="Branch 0 was taken 100884 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 56 times"> + </span>]:<span class="tlaGNC">      100940 :                 size_t alloc_add = std::min(max_read, msg_bytes.size() + MAX_RESERVE_AHEAD);</span></span>
<span id="L1330"><span class="lineNum">    1330</span>                 :<span class="tlaGNC">      100940 :                 m_recv_buffer.reserve(m_recv_buffer.size() + alloc_add);</span></span>
<span id="L1331"><span class="lineNum">    1331</span>                 :<span class="tlaGNC">      100940 :                 break;</span></span>
<span id="L1332"><span class="lineNum">    1332</span>                 :             :             }</span>
<span id="L1333"><span class="lineNum">    1333</span>                 :<span class="tlaUNC tlaBgUNC">           0 :             case RecvState::APP_READY:</span></span>
<span id="L1334"><span class="lineNum">    1334</span>                 :             :                 // The buffer is empty in this state.</span>
<span id="L1335"><span class="lineNum">    1335</span>                 :<span class="tlaUNC">           0 :                 Assume(m_recv_buffer.empty());</span></span>
<span id="L1336"><span class="lineNum">    1336</span>                 :<span class="tlaUNC">           0 :                 break;</span></span>
<span id="L1337"><span class="lineNum">    1337</span>                 :<span class="tlaUNC">           0 :             case RecvState::V1:</span></span>
<span id="L1338"><span class="lineNum">    1338</span>                 :             :                 // Should have bailed out above.</span>
<span id="L1339"><span class="lineNum">    1339</span>                 :<span class="tlaUNC">           0 :                 Assume(false);</span></span>
<span id="L1340"><span class="lineNum">    1340</span>                 :<span class="tlaUNC">           0 :                 break;</span></span>
<span id="L1341"><span class="lineNum">    1341</span>                 :             :             }</span>
<span id="L1342"><span class="lineNum">    1342</span>                 :             :         }</span>
<span id="L1343"><span class="lineNum">    1343</span>                 :             : </span>
<span id="L1344"><span class="lineNum">    1344</span>                 :             :         // Can't read more than provided input.</span>
<span id="L1345"><span class="lineNum">    1345</span>         [<span class="tlaGBC" title="Branch 0 was taken 1989 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 237726 times"> + </span>]:<span class="tlaGNC tlaBgGNC">      239715 :         max_read = std::min(msg_bytes.size(), max_read);</span></span>
<span id="L1346"><span class="lineNum">    1346</span>                 :             :         // Copy data to buffer.</span>
<span id="L1347"><span class="lineNum">    1347</span>                 :<span class="tlaGNC">      239715 :         m_recv_buffer.insert(m_recv_buffer.end(), UCharCast(msg_bytes.data()), UCharCast(msg_bytes.data() + max_read));</span></span>
<span id="L1348"><span class="lineNum">    1348</span>   [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 150 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 136925 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 102324 times"> + </span> :<span class="tlaGNC">      239715 :         msg_bytes = msg_bytes.subspan(max_read);</span></span>
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 277 times"> + </span>]
<span id="L1349"><span class="lineNum">    1349</span>                 :             : </span>
<span id="L1350"><span class="lineNum">    1350</span>                 :             :         // Process data in the buffer.</span>
<span id="L1351"><span class="lineNum">    1351</span>   [<span class="tlaGBC" title="Branch 0 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 150 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 136925 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 102324 times"> + </span> :<span class="tlaGNC">      239715 :         switch (m_recv_state) {</span></span>
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 277 times"> + </span>]
<span id="L1352"><span class="lineNum">    1352</span>                 :<span class="tlaGNC">          39 :         case RecvState::KEY_MAYBE_V1:</span></span>
<span id="L1353"><span class="lineNum">    1353</span>                 :<span class="tlaGNC">          39 :             ProcessReceivedMaybeV1Bytes();</span></span>
<span id="L1354"><span class="lineNum">    1354</span>         [<span class="tlaGBC" title="Branch 0 was taken 38 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">          39 :             if (m_recv_state == RecvState::V1) return true;</span></span>
<span id="L1355"><span class="lineNum">    1355</span>                 :             :             break;</span>
<span id="L1356"><span class="lineNum">    1356</span>                 :             : </span>
<span id="L1357"><span class="lineNum">    1357</span>                 :<span class="tlaGNC">         150 :         case RecvState::KEY:</span></span>
<span id="L1358"><span class="lineNum">    1358</span>         [<span class="tlaGBC" title="Branch 0 was taken 149 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">         150 :             if (!ProcessReceivedKeyBytes()) return false;</span></span>
<span id="L1359"><span class="lineNum">    1359</span>                 :             :             break;</span>
<span id="L1360"><span class="lineNum">    1360</span>                 :             : </span>
<span id="L1361"><span class="lineNum">    1361</span>                 :<span class="tlaGNC">      136925 :         case RecvState::GARB_GARBTERM:</span></span>
<span id="L1362"><span class="lineNum">    1362</span>         [<span class="tlaGBC" title="Branch 0 was taken 136923 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">      136925 :             if (!ProcessReceivedGarbageBytes()) return false;</span></span>
<span id="L1363"><span class="lineNum">    1363</span>                 :             :             break;</span>
<span id="L1364"><span class="lineNum">    1364</span>                 :             : </span>
<span id="L1365"><span class="lineNum">    1365</span>                 :<span class="tlaGNC">      102324 :         case RecvState::VERSION:</span></span>
<span id="L1366"><span class="lineNum">    1366</span>                 :<span class="tlaGNC">      102324 :         case RecvState::APP:</span></span>
<span id="L1367"><span class="lineNum">    1367</span>         [<span class="tlaGBC" title="Branch 0 was taken 102304 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 20 times"> + </span>]:<span class="tlaGNC">      102324 :             if (!ProcessReceivedPacketBytes()) return false;</span></span>
<span id="L1368"><span class="lineNum">    1368</span>                 :             :             break;</span>
<span id="L1369"><span class="lineNum">    1369</span>                 :             : </span>
<span id="L1370"><span class="lineNum">    1370</span>                 :             :         case RecvState::APP_READY:</span>
<span id="L1371"><span class="lineNum">    1371</span>                 :             :             return true;</span>
<span id="L1372"><span class="lineNum">    1372</span>                 :             : </span>
<span id="L1373"><span class="lineNum">    1373</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         case RecvState::V1:</span></span>
<span id="L1374"><span class="lineNum">    1374</span>                 :             :             // We should have bailed out before.</span>
<span id="L1375"><span class="lineNum">    1375</span>                 :<span class="tlaUNC">           0 :             Assume(false);</span></span>
<span id="L1376"><span class="lineNum">    1376</span>                 :<span class="tlaUNC">           0 :             break;</span></span>
<span id="L1377"><span class="lineNum">    1377</span>                 :             :         }</span>
<span id="L1378"><span class="lineNum">    1378</span>                 :             :         // Make sure we have made progress before continuing.</span>
<span id="L1379"><span class="lineNum">    1379</span>                 :<span class="tlaGNC tlaBgGNC">      239414 :         Assume(max_read &gt; 0);</span></span>
<span id="L1380"><span class="lineNum">    1380</span>                 :             :     }</span>
<span id="L1381"><span class="lineNum">    1381</span>                 :             : </span>
<span id="L1382"><span class="lineNum">    1382</span>                 :             :     return true;</span>
<span id="L1383"><span class="lineNum">    1383</span>                 :<span class="tlaGNC">        2279 : }</span></span>
<span id="L1384"><span class="lineNum">    1384</span>                 :             : </span>
<span id="L1385"><span class="lineNum">    1385</span>                 :<span class="tlaGNC">         252 : std::optional&lt;std::string&gt; V2Transport::GetMessageType(Span&lt;const uint8_t&gt;&amp; contents) noexcept</span></span>
<span id="L1386"><span class="lineNum">    1386</span>                 :             : {</span>
<span id="L1387"><span class="lineNum">    1387</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 252 times"> + </span>]:<span class="tlaGNC">         252 :     if (contents.size() == 0) return std::nullopt; // Empty contents</span></span>
<span id="L1388"><span class="lineNum">    1388</span>         [<span class="tlaGBC" title="Branch 0 was taken 132 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 120 times"> + </span>]:<span class="tlaGNC">         252 :     uint8_t first_byte = contents[0];</span></span>
<span id="L1389"><span class="lineNum">    1389</span>         [<span class="tlaGBC" title="Branch 0 was taken 132 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 120 times"> + </span>]:<span class="tlaGNC">         252 :     contents = contents.subspan(1); // Strip first byte.</span></span>
<span id="L1390"><span class="lineNum">    1390</span>                 :             : </span>
<span id="L1391"><span class="lineNum">    1391</span>         [<span class="tlaGBC" title="Branch 0 was taken 132 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 120 times"> + </span>]:<span class="tlaGNC">         252 :     if (first_byte != 0) {</span></span>
<span id="L1392"><span class="lineNum">    1392</span>                 :             :         // Short (1 byte) encoding.</span>
<span id="L1393"><span class="lineNum">    1393</span>         [<span class="tlaGBC" title="Branch 0 was taken 131 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 1 time"> + </span>]:<span class="tlaGNC">         132 :         if (first_byte &lt; std::size(V2_MESSAGE_IDS)) {</span></span>
<span id="L1394"><span class="lineNum">    1394</span>                 :             :             // Valid short message id.</span>
<span id="L1395"><span class="lineNum">    1395</span>                 :<span class="tlaGNC">         131 :             return V2_MESSAGE_IDS[first_byte];</span></span>
<span id="L1396"><span class="lineNum">    1396</span>                 :             :         } else {</span>
<span id="L1397"><span class="lineNum">    1397</span>                 :             :             // Unknown short message id.</span>
<span id="L1398"><span class="lineNum">    1398</span>                 :<span class="tlaGNC">           1 :             return std::nullopt;</span></span>
<span id="L1399"><span class="lineNum">    1399</span>                 :             :         }</span>
<span id="L1400"><span class="lineNum">    1400</span>                 :             :     }</span>
<span id="L1401"><span class="lineNum">    1401</span>                 :             : </span>
<span id="L1402"><span class="lineNum">    1402</span>         [<span class="tlaGBC" title="Branch 0 was taken 110 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC">         120 :     if (contents.size() &lt; CMessageHeader::COMMAND_SIZE) {</span></span>
<span id="L1403"><span class="lineNum">    1403</span>                 :<span class="tlaGNC">          10 :         return std::nullopt; // Long encoding needs 12 message type bytes.</span></span>
<span id="L1404"><span class="lineNum">    1404</span>                 :             :     }</span>
<span id="L1405"><span class="lineNum">    1405</span>                 :             : </span>
<span id="L1406"><span class="lineNum">    1406</span>                 :             :     size_t msg_type_len{0};</span>
<span id="L1407"><span class="lineNum">    1407</span>   [<span class="tlaGBC" title="Branch 0 was taken 830 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 110 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 720 times"> + </span>]:<span class="tlaGNC">         830 :     while (msg_type_len &lt; CMessageHeader::COMMAND_SIZE &amp;&amp; contents[msg_type_len] != 0) {</span></span>
<span id="L1408"><span class="lineNum">    1408</span>                 :             :         // Verify that message type bytes before the first 0x00 are in range.</span>
<span id="L1409"><span class="lineNum">    1409</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 720 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 720 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         720 :         if (contents[msg_type_len] &lt; ' ' || contents[msg_type_len] &gt; 0x7F) {</span></span>
<span id="L1410"><span class="lineNum">    1410</span>                 :<span class="tlaUNC tlaBgUNC">           0 :             return {};</span></span>
<span id="L1411"><span class="lineNum">    1411</span>                 :             :         }</span>
<span id="L1412"><span class="lineNum">    1412</span>                 :<span class="tlaGNC tlaBgGNC">         720 :         ++msg_type_len;</span></span>
<span id="L1413"><span class="lineNum">    1413</span>                 :             :     }</span>
<span id="L1414"><span class="lineNum">    1414</span>                 :<span class="tlaGNC">         110 :     std::string ret{reinterpret_cast&lt;const char*&gt;(contents.data()), msg_type_len};</span></span>
<span id="L1415"><span class="lineNum">    1415</span>         [<span class="tlaGBC" title="Branch 0 was taken 550 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 60 times"> + </span>]:<span class="tlaGNC">         610 :     while (msg_type_len &lt; CMessageHeader::COMMAND_SIZE) {</span></span>
<span id="L1416"><span class="lineNum">    1416</span>                 :             :         // Verify that message type bytes after the first 0x00 are also 0x00.</span>
<span id="L1417"><span class="lineNum">    1417</span>         [<span class="tlaGBC" title="Branch 0 was taken 50 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 500 times"> + </span>]:<span class="tlaGNC">         550 :         if (contents[msg_type_len] != 0) return {};</span></span>
<span id="L1418"><span class="lineNum">    1418</span>                 :<span class="tlaGNC">         500 :         ++msg_type_len;</span></span>
<span id="L1419"><span class="lineNum">    1419</span>                 :             :     }</span>
<span id="L1420"><span class="lineNum">    1420</span>                 :             :     // Strip message type bytes of contents.</span>
<span id="L1421"><span class="lineNum">    1421</span>                 :<span class="tlaGNC">          60 :     contents = contents.subspan(CMessageHeader::COMMAND_SIZE);</span></span>
<span id="L1422"><span class="lineNum">    1422</span>                 :<span class="tlaGNC">          60 :     return ret;</span></span>
<span id="L1423"><span class="lineNum">    1423</span>                 :<span class="tlaGNC">         110 : }</span></span>
<span id="L1424"><span class="lineNum">    1424</span>                 :             : </span>
<span id="L1425"><span class="lineNum">    1425</span>                 :<span class="tlaGNC">         252 : CNetMessage V2Transport::GetReceivedMessage(std::chrono::microseconds time, bool&amp; reject_message) noexcept</span></span>
<span id="L1426"><span class="lineNum">    1426</span>                 :             : {</span>
<span id="L1427"><span class="lineNum">    1427</span>                 :<span class="tlaGNC">         252 :     AssertLockNotHeld(m_recv_mutex);</span></span>
<span id="L1428"><span class="lineNum">    1428</span>                 :<span class="tlaGNC">         252 :     LOCK(m_recv_mutex);</span></span>
<span id="L1429"><span class="lineNum">    1429</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 252 times"> + </span>]:<span class="tlaGNC">         252 :     if (m_recv_state == RecvState::V1) return m_v1_fallback.GetReceivedMessage(time, reject_message);</span></span>
<span id="L1430"><span class="lineNum">    1430</span>                 :             : </span>
<span id="L1431"><span class="lineNum">    1431</span>                 :<span class="tlaGNC">         252 :     Assume(m_recv_state == RecvState::APP_READY);</span></span>
<span id="L1432"><span class="lineNum">    1432</span>                 :<span class="tlaGNC">         252 :     Span&lt;const uint8_t&gt; contents{m_recv_decode_buffer};</span></span>
<span id="L1433"><span class="lineNum">    1433</span>                 :<span class="tlaGNC">         252 :     auto msg_type = GetMessageType(contents);</span></span>
<span id="L1434"><span class="lineNum">    1434</span>                 :<span class="tlaGNC">         252 :     CNetMessage msg{DataStream{}};</span></span>
<span id="L1435"><span class="lineNum">    1435</span>                 :             :     // Note that BIP324Cipher::EXPANSION also includes the length descriptor size.</span>
<span id="L1436"><span class="lineNum">    1436</span>         [<span class="tlaGBC" title="Branch 0 was taken 191 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 61 times"> + </span>]:<span class="tlaGNC">         252 :     msg.m_raw_message_size = m_recv_decode_buffer.size() + BIP324Cipher::EXPANSION;</span></span>
<span id="L1437"><span class="lineNum">    1437</span>         [<span class="tlaGBC" title="Branch 0 was taken 191 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 61 times"> + </span>]:<span class="tlaGNC">         252 :     if (msg_type) {</span></span>
<span id="L1438"><span class="lineNum">    1438</span>                 :<span class="tlaGNC">         191 :         reject_message = false;</span></span>
<span id="L1439"><span class="lineNum">    1439</span>                 :<span class="tlaGNC">         191 :         msg.m_type = std::move(*msg_type);</span></span>
<span id="L1440"><span class="lineNum">    1440</span>                 :<span class="tlaGNC">         191 :         msg.m_time = time;</span></span>
<span id="L1441"><span class="lineNum">    1441</span>                 :<span class="tlaGNC">         191 :         msg.m_message_size = contents.size();</span></span>
<span id="L1442"><span class="lineNum">    1442</span>                 :<span class="tlaGNC">         191 :         msg.m_recv.resize(contents.size());</span></span>
<span id="L1443"><span class="lineNum">    1443</span>                 :<span class="tlaGNC">         191 :         std::copy(contents.begin(), contents.end(), UCharCast(msg.m_recv.data()));</span></span>
<span id="L1444"><span class="lineNum">    1444</span>                 :             :     } else {</span>
<span id="L1445"><span class="lineNum">    1445</span>         [<span class="tlaGBC" title="Branch 0 was taken 61 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          61 :         LogDebug(BCLog::NET, &quot;V2 transport error: invalid message type (%u bytes contents), peer=%d\n&quot;, m_recv_decode_buffer.size(), m_nodeid);</span></span>
<span id="L1446"><span class="lineNum">    1446</span>                 :<span class="tlaGNC">          61 :         reject_message = true;</span></span>
<span id="L1447"><span class="lineNum">    1447</span>                 :             :     }</span>
<span id="L1448"><span class="lineNum">    1448</span>                 :<span class="tlaGNC">         252 :     ClearShrink(m_recv_decode_buffer);</span></span>
<span id="L1449"><span class="lineNum">    1449</span>                 :<span class="tlaGNC">         252 :     SetReceiveState(RecvState::APP);</span></span>
<span id="L1450"><span class="lineNum">    1450</span>                 :             : </span>
<span id="L1451"><span class="lineNum">    1451</span>                 :<span class="tlaGNC">         252 :     return msg;</span></span>
<span id="L1452"><span class="lineNum">    1452</span>                 :<span class="tlaGNC">         252 : }</span></span>
<span id="L1453"><span class="lineNum">    1453</span>                 :             : </span>
<span id="L1454"><span class="lineNum">    1454</span>                 :<span class="tlaGNC">          51 : bool V2Transport::SetMessageToSend(CSerializedNetMsg&amp; msg) noexcept</span></span>
<span id="L1455"><span class="lineNum">    1455</span>                 :             : {</span>
<span id="L1456"><span class="lineNum">    1456</span>                 :<span class="tlaGNC">          51 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1457"><span class="lineNum">    1457</span>                 :<span class="tlaGNC">          51 :     LOCK(m_send_mutex);</span></span>
<span id="L1458"><span class="lineNum">    1458</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 51 times"> + </span>]:<span class="tlaGNC">          51 :     if (m_send_state == SendState::V1) return m_v1_fallback.SetMessageToSend(msg);</span></span>
<span id="L1459"><span class="lineNum">    1459</span>                 :             :     // We only allow adding a new message to be sent when in the READY state (so the packet cipher</span>
<span id="L1460"><span class="lineNum">    1460</span>                 :             :     // is available) and the send buffer is empty. This limits the number of messages in the send</span>
<span id="L1461"><span class="lineNum">    1461</span>                 :             :     // buffer to just one, and leaves the responsibility for queueing them up to the caller.</span>
<span id="L1462"><span class="lineNum">    1462</span>   [<span class="tlaGBC" title="Branch 0 was taken 51 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 51 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          51 :     if (!(m_send_state == SendState::READY &amp;&amp; m_send_buffer.empty())) return false;</span></span>
<span id="L1463"><span class="lineNum">    1463</span>                 :             :     // Construct contents (encoding message type + payload).</span>
<span id="L1464"><span class="lineNum">    1464</span>                 :<span class="tlaGNC">          51 :     std::vector&lt;uint8_t&gt; contents;</span></span>
<span id="L1465"><span class="lineNum">    1465</span>                 :<span class="tlaGNC">          51 :     auto short_message_id = V2_MESSAGE_MAP(msg.m_type);</span></span>
<span id="L1466"><span class="lineNum">    1466</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 50 times"> + </span>]:<span class="tlaGNC">          51 :     if (short_message_id) {</span></span>
<span id="L1467"><span class="lineNum">    1467</span>                 :<span class="tlaGNC">           1 :         contents.resize(1 + msg.data.size());</span></span>
<span id="L1468"><span class="lineNum">    1468</span>                 :<span class="tlaGNC">           1 :         contents[0] = *short_message_id;</span></span>
<span id="L1469"><span class="lineNum">    1469</span>                 :<span class="tlaGNC">           1 :         std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1);</span></span>
<span id="L1470"><span class="lineNum">    1470</span>                 :             :     } else {</span>
<span id="L1471"><span class="lineNum">    1471</span>                 :             :         // Initialize with zeroes, and then write the message type string starting at offset 1.</span>
<span id="L1472"><span class="lineNum">    1472</span>                 :             :         // This means contents[0] and the unused positions in contents[1..13] remain 0x00.</span>
<span id="L1473"><span class="lineNum">    1473</span>                 :<span class="tlaGNC">          50 :         contents.resize(1 + CMessageHeader::COMMAND_SIZE + msg.data.size(), 0);</span></span>
<span id="L1474"><span class="lineNum">    1474</span>                 :<span class="tlaGNC">          50 :         std::copy(msg.m_type.begin(), msg.m_type.end(), contents.data() + 1);</span></span>
<span id="L1475"><span class="lineNum">    1475</span>                 :<span class="tlaGNC">          50 :         std::copy(msg.data.begin(), msg.data.end(), contents.begin() + 1 + CMessageHeader::COMMAND_SIZE);</span></span>
<span id="L1476"><span class="lineNum">    1476</span>                 :             :     }</span>
<span id="L1477"><span class="lineNum">    1477</span>                 :             :     // Construct ciphertext in send buffer.</span>
<span id="L1478"><span class="lineNum">    1478</span>                 :<span class="tlaGNC">          51 :     m_send_buffer.resize(contents.size() + BIP324Cipher::EXPANSION);</span></span>
<span id="L1479"><span class="lineNum">    1479</span>                 :<span class="tlaGNC">          51 :     m_cipher.Encrypt(MakeByteSpan(contents), {}, false, MakeWritableByteSpan(m_send_buffer));</span></span>
<span id="L1480"><span class="lineNum">    1480</span>                 :<span class="tlaGNC">          51 :     m_send_type = msg.m_type;</span></span>
<span id="L1481"><span class="lineNum">    1481</span>                 :             :     // Release memory</span>
<span id="L1482"><span class="lineNum">    1482</span>                 :<span class="tlaGNC">          51 :     ClearShrink(msg.data);</span></span>
<span id="L1483"><span class="lineNum">    1483</span>                 :<span class="tlaGNC">          51 :     return true;</span></span>
<span id="L1484"><span class="lineNum">    1484</span>                 :<span class="tlaGNC">          51 : }</span></span>
<span id="L1485"><span class="lineNum">    1485</span>                 :             : </span>
<span id="L1486"><span class="lineNum">    1486</span>                 :<span class="tlaGNC">        3002 : Transport::BytesToSend V2Transport::GetBytesToSend(bool have_next_message) const noexcept</span></span>
<span id="L1487"><span class="lineNum">    1487</span>                 :             : {</span>
<span id="L1488"><span class="lineNum">    1488</span>                 :<span class="tlaGNC">        3002 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1489"><span class="lineNum">    1489</span>                 :<span class="tlaGNC">        3002 :     LOCK(m_send_mutex);</span></span>
<span id="L1490"><span class="lineNum">    1490</span>         [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2998 times"> + </span>]:<span class="tlaGNC">        3002 :     if (m_send_state == SendState::V1) return m_v1_fallback.GetBytesToSend(have_next_message);</span></span>
<span id="L1491"><span class="lineNum">    1491</span>                 :             : </span>
<span id="L1492"><span class="lineNum">    1492</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2998 times"> + </span>]:<span class="tlaGNC">        2998 :     if (m_send_state == SendState::MAYBE_V1) Assume(m_send_buffer.empty());</span></span>
<span id="L1493"><span class="lineNum">    1493</span>                 :<span class="tlaGNC">        2998 :     Assume(m_send_pos &lt;= m_send_buffer.size());</span></span>
<span id="L1494"><span class="lineNum">    1494</span>                 :<span class="tlaGNC">        2998 :     return {</span></span>
<span id="L1495"><span class="lineNum">    1495</span>         [<span class="tlaGBC" title="Branch 0 was taken 45 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2953 times"> + </span>]:<span class="tlaGNC">        2998 :         Span{m_send_buffer}.subspan(m_send_pos),</span></span>
<span id="L1496"><span class="lineNum">    1496</span>                 :             :         // We only have more to send after the current m_send_buffer if there is a (next)</span>
<span id="L1497"><span class="lineNum">    1497</span>                 :             :         // message to be sent, and we're capable of sending packets. */</span>
<span id="L1498"><span class="lineNum">    1498</span>   [<span class="tlaGBC" title="Branch 0 was taken 45 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2953 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 45 times"> + </span>]:<span class="tlaGNC">        2998 :         have_next_message &amp;&amp; m_send_state == SendState::READY,</span></span>
<span id="L1499"><span class="lineNum">    1499</span>                 :<span class="tlaGNC">        2998 :         m_send_type</span></span>
<span id="L1500"><span class="lineNum">    1500</span>                 :<span class="tlaGNC">        2998 :     };</span></span>
<span id="L1501"><span class="lineNum">    1501</span>                 :<span class="tlaGNC">        3002 : }</span></span>
<span id="L1502"><span class="lineNum">    1502</span>                 :             : </span>
<span id="L1503"><span class="lineNum">    1503</span>                 :<span class="tlaGNC">         962 : void V2Transport::MarkBytesSent(size_t bytes_sent) noexcept</span></span>
<span id="L1504"><span class="lineNum">    1504</span>                 :             : {</span>
<span id="L1505"><span class="lineNum">    1505</span>                 :<span class="tlaGNC">         962 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1506"><span class="lineNum">    1506</span>                 :<span class="tlaGNC">         962 :     LOCK(m_send_mutex);</span></span>
<span id="L1507"><span class="lineNum">    1507</span>   [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 962 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         962 :     if (m_send_state == SendState::V1) return m_v1_fallback.MarkBytesSent(bytes_sent);</span></span>
<span id="L1508"><span class="lineNum">    1508</span>                 :             : </span>
<span id="L1509"><span class="lineNum">    1509</span>   [<span class="tlaGBC" title="Branch 0 was taken 297 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 665 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 46 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 251 times"> + </span> :<span class="tlaGNC">         962 :     if (m_send_state == SendState::AWAITING_KEY &amp;&amp; m_send_pos == 0 &amp;&amp; bytes_sent &gt; 0) {</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 46 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L1510"><span class="lineNum">    1510</span>         [<span class="tlaGBC" title="Branch 0 was taken 46 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          46 :         LogDebug(BCLog::NET, &quot;start sending v2 handshake to peer=%d\n&quot;, m_nodeid);</span></span>
<span id="L1511"><span class="lineNum">    1511</span>                 :             :     }</span>
<span id="L1512"><span class="lineNum">    1512</span>                 :             : </span>
<span id="L1513"><span class="lineNum">    1513</span>                 :<span class="tlaGNC">         962 :     m_send_pos += bytes_sent;</span></span>
<span id="L1514"><span class="lineNum">    1514</span>                 :<span class="tlaGNC">         962 :     Assume(m_send_pos &lt;= m_send_buffer.size());</span></span>
<span id="L1515"><span class="lineNum">    1515</span>         [<span class="tlaGBC" title="Branch 0 was taken 870 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 92 times"> + </span>]:<span class="tlaGNC">         962 :     if (m_send_pos &gt;= CMessageHeader::HEADER_SIZE) {</span></span>
<span id="L1516"><span class="lineNum">    1516</span>                 :<span class="tlaGNC">         870 :         m_sent_v1_header_worth = true;</span></span>
<span id="L1517"><span class="lineNum">    1517</span>                 :             :     }</span>
<span id="L1518"><span class="lineNum">    1518</span>                 :             :     // Wipe the buffer when everything is sent.</span>
<span id="L1519"><span class="lineNum">    1519</span>         [<span class="tlaGBC" title="Branch 0 was taken 152 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 810 times"> + </span>]:<span class="tlaGNC">         962 :     if (m_send_pos == m_send_buffer.size()) {</span></span>
<span id="L1520"><span class="lineNum">    1520</span>                 :<span class="tlaGNC">         152 :         m_send_pos = 0;</span></span>
<span id="L1521"><span class="lineNum">    1521</span>                 :<span class="tlaGNC">         152 :         ClearShrink(m_send_buffer);</span></span>
<span id="L1522"><span class="lineNum">    1522</span>                 :             :     }</span>
<span id="L1523"><span class="lineNum">    1523</span>                 :<span class="tlaGNC">         962 : }</span></span>
<span id="L1524"><span class="lineNum">    1524</span>                 :             : </span>
<span id="L1525"><span class="lineNum">    1525</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool V2Transport::ShouldReconnectV1() const noexcept</span></span>
<span id="L1526"><span class="lineNum">    1526</span>                 :             : {</span>
<span id="L1527"><span class="lineNum">    1527</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1528"><span class="lineNum">    1528</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_recv_mutex);</span></span>
<span id="L1529"><span class="lineNum">    1529</span>                 :             :     // Only outgoing connections need reconnection.</span>
<span id="L1530"><span class="lineNum">    1530</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!m_initiating) return false;</span></span>
<span id="L1531"><span class="lineNum">    1531</span>                 :             : </span>
<span id="L1532"><span class="lineNum">    1532</span>                 :<span class="tlaUNC">           0 :     LOCK(m_recv_mutex);</span></span>
<span id="L1533"><span class="lineNum">    1533</span>                 :             :     // We only reconnect in the very first state and when the receive buffer is empty. Together</span>
<span id="L1534"><span class="lineNum">    1534</span>                 :             :     // these conditions imply nothing has been received so far.</span>
<span id="L1535"><span class="lineNum">    1535</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_recv_state != RecvState::KEY) return false;</span></span>
<span id="L1536"><span class="lineNum">    1536</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!m_recv_buffer.empty()) return false;</span></span>
<span id="L1537"><span class="lineNum">    1537</span>                 :             :     // Check if we've sent enough for the other side to disconnect us (if it was V1).</span>
<span id="L1538"><span class="lineNum">    1538</span>                 :<span class="tlaUNC">           0 :     LOCK(m_send_mutex);</span></span>
<span id="L1539"><span class="lineNum">    1539</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return m_sent_v1_header_worth;</span></span>
<span id="L1540"><span class="lineNum">    1540</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1541"><span class="lineNum">    1541</span>                 :             : </span>
<span id="L1542"><span class="lineNum">    1542</span>                 :<span class="tlaUNC">           0 : size_t V2Transport::GetSendMemoryUsage() const noexcept</span></span>
<span id="L1543"><span class="lineNum">    1543</span>                 :             : {</span>
<span id="L1544"><span class="lineNum">    1544</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_send_mutex);</span></span>
<span id="L1545"><span class="lineNum">    1545</span>                 :<span class="tlaUNC">           0 :     LOCK(m_send_mutex);</span></span>
<span id="L1546"><span class="lineNum">    1546</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_send_state == SendState::V1) return m_v1_fallback.GetSendMemoryUsage();</span></span>
<span id="L1547"><span class="lineNum">    1547</span>                 :             : </span>
<span id="L1548"><span class="lineNum">    1548</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return sizeof(m_send_buffer) + memusage::DynamicUsage(m_send_buffer);</span></span>
<span id="L1549"><span class="lineNum">    1549</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1550"><span class="lineNum">    1550</span>                 :             : </span>
<span id="L1551"><span class="lineNum">    1551</span>                 :<span class="tlaGNC tlaBgGNC">          71 : Transport::Info V2Transport::GetInfo() const noexcept</span></span>
<span id="L1552"><span class="lineNum">    1552</span>                 :             : {</span>
<span id="L1553"><span class="lineNum">    1553</span>                 :<span class="tlaGNC">          71 :     AssertLockNotHeld(m_recv_mutex);</span></span>
<span id="L1554"><span class="lineNum">    1554</span>                 :<span class="tlaGNC">          71 :     LOCK(m_recv_mutex);</span></span>
<span id="L1555"><span class="lineNum">    1555</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 71 times"> + </span>]:<span class="tlaGNC">          71 :     if (m_recv_state == RecvState::V1) return m_v1_fallback.GetInfo();</span></span>
<span id="L1556"><span class="lineNum">    1556</span>                 :             : </span>
<span id="L1557"><span class="lineNum">    1557</span>         [<span class="tlaGBC" title="Branch 0 was taken 71 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          71 :     Transport::Info info;</span></span>
<span id="L1558"><span class="lineNum">    1558</span>                 :             : </span>
<span id="L1559"><span class="lineNum">    1559</span>                 :             :     // Do not report v2 and session ID until the version packet has been received</span>
<span id="L1560"><span class="lineNum">    1560</span>                 :             :     // and verified (confirming that the other side very likely has the same keys as us).</span>
<span id="L1561"><span class="lineNum">    1561</span>         [<span class="tlaGBC" title="Branch 0 was taken 71 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          71 :     if (m_recv_state != RecvState::KEY_MAYBE_V1 &amp;&amp; m_recv_state != RecvState::KEY &amp;&amp;</span></span>
<span id="L1562"><span class="lineNum">    1562</span>                 :             :         m_recv_state != RecvState::GARB_GARBTERM &amp;&amp; m_recv_state != RecvState::VERSION) {</span>
<span id="L1563"><span class="lineNum">    1563</span>                 :<span class="tlaGNC">          71 :         info.transport_type = TransportProtocolType::V2;</span></span>
<span id="L1564"><span class="lineNum">    1564</span>                 :<span class="tlaGNC">          71 :         info.session_id = uint256(MakeUCharSpan(m_cipher.GetSessionID()));</span></span>
<span id="L1565"><span class="lineNum">    1565</span>                 :             :     } else {</span>
<span id="L1566"><span class="lineNum">    1566</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         info.transport_type = TransportProtocolType::DETECTING;</span></span>
<span id="L1567"><span class="lineNum">    1567</span>                 :             :     }</span>
<span id="L1568"><span class="lineNum">    1568</span>                 :             : </span>
<span id="L1569"><span class="lineNum">    1569</span>                 :<span class="tlaGNC tlaBgGNC">          71 :     return info;</span></span>
<span id="L1570"><span class="lineNum">    1570</span>                 :<span class="tlaGNC">          71 : }</span></span>
<span id="L1571"><span class="lineNum">    1571</span>                 :             : </span>
<span id="L1572"><span class="lineNum">    1572</span>                 :<span class="tlaGNC">           6 : std::pair&lt;size_t, bool&gt; CConnman::SocketSendData(CNode&amp; node) const</span></span>
<span id="L1573"><span class="lineNum">    1573</span>                 :             : {</span>
<span id="L1574"><span class="lineNum">    1574</span>                 :<span class="tlaGNC">           6 :     auto it = node.vSendMsg.begin();</span></span>
<span id="L1575"><span class="lineNum">    1575</span>                 :<span class="tlaGNC">           6 :     size_t nSentSize = 0;</span></span>
<span id="L1576"><span class="lineNum">    1576</span>                 :<span class="tlaGNC">           6 :     bool data_left{false}; //!&lt; second return value (whether unsent data remains)</span></span>
<span id="L1577"><span class="lineNum">    1577</span>                 :<span class="tlaGNC">           6 :     std::optional&lt;bool&gt; expected_more;</span></span>
<span id="L1578"><span class="lineNum">    1578</span>                 :             : </span>
<span id="L1579"><span class="lineNum">    1579</span>                 :<span class="tlaGNC">           6 :     while (true) {</span></span>
<span id="L1580"><span class="lineNum">    1580</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :         if (it != node.vSendMsg.end()) {</span></span>
<span id="L1581"><span class="lineNum">    1581</span>                 :             :             // If possible, move one message from the send queue to the transport. This fails when</span>
<span id="L1582"><span class="lineNum">    1582</span>                 :             :             // there is an existing message still being sent, or (for v2 transports) when the</span>
<span id="L1583"><span class="lineNum">    1583</span>                 :             :             // handshake has not yet completed.</span>
<span id="L1584"><span class="lineNum">    1584</span>                 :<span class="tlaGNC">           6 :             size_t memusage = it-&gt;GetMemoryUsage();</span></span>
<span id="L1585"><span class="lineNum">    1585</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :             if (node.m_transport-&gt;SetMessageToSend(*it)) {</span></span>
<span id="L1586"><span class="lineNum">    1586</span>                 :             :                 // Update memory usage of send buffer (as *it will be deleted).</span>
<span id="L1587"><span class="lineNum">    1587</span>                 :<span class="tlaGNC">           6 :                 node.m_send_memusage -= memusage;</span></span>
<span id="L1588"><span class="lineNum">    1588</span>                 :<span class="tlaGNC">           6 :                 ++it;</span></span>
<span id="L1589"><span class="lineNum">    1589</span>                 :             :             }</span>
<span id="L1590"><span class="lineNum">    1590</span>                 :             :         }</span>
<span id="L1591"><span class="lineNum">    1591</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           6 :         const auto&amp; [data, more, msg_type] = node.m_transport-&gt;GetBytesToSend(it != node.vSendMsg.end());</span></span>
<span id="L1592"><span class="lineNum">    1592</span>                 :             :         // We rely on the 'more' value returned by GetBytesToSend to correctly predict whether more</span>
<span id="L1593"><span class="lineNum">    1593</span>                 :             :         // bytes are still to be sent, to correctly set the MSG_MORE flag. As a sanity check,</span>
<span id="L1594"><span class="lineNum">    1594</span>                 :             :         // verify that the previously returned 'more' was correct.</span>
<span id="L1595"><span class="lineNum">    1595</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           6 :         if (expected_more.has_value()) Assume(!data.empty() == *expected_more);</span></span>
<span id="L1596"><span class="lineNum">    1596</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :         expected_more = more;</span></span>
<span id="L1597"><span class="lineNum">    1597</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :         data_left = !data.empty(); // will be overwritten on next loop if all of data gets sent</span></span>
<span id="L1598"><span class="lineNum">    1598</span>                 :<span class="tlaGNC">           6 :         int nBytes = 0;</span></span>
<span id="L1599"><span class="lineNum">    1599</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :         if (!data.empty()) {</span></span>
<span id="L1600"><span class="lineNum">    1600</span>                 :<span class="tlaGNC">           6 :             LOCK(node.m_sock_mutex);</span></span>
<span id="L1601"><span class="lineNum">    1601</span>                 :             :             // There is no socket in case we've already disconnected, or in test cases without</span>
<span id="L1602"><span class="lineNum">    1602</span>                 :             :             // real connections. In these cases, we bail out immediately and just leave things</span>
<span id="L1603"><span class="lineNum">    1603</span>                 :             :             // in the send queue and transport.</span>
<span id="L1604"><span class="lineNum">    1604</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           6 :             if (!node.m_sock) {</span></span>
<span id="L1605"><span class="lineNum">    1605</span>                 :             :                 break;</span>
<span id="L1606"><span class="lineNum">    1606</span>                 :             :             }</span>
<span id="L1607"><span class="lineNum">    1607</span>                 :<span class="tlaUNC tlaBgUNC">           0 :             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;</span></span>
<span id="L1608"><span class="lineNum">    1608</span>                 :             : #ifdef MSG_MORE</span>
<span id="L1609"><span class="lineNum">    1609</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (more) {</span></span>
<span id="L1610"><span class="lineNum">    1610</span>                 :<span class="tlaUNC">           0 :                 flags |= MSG_MORE;</span></span>
<span id="L1611"><span class="lineNum">    1611</span>                 :             :             }</span>
<span id="L1612"><span class="lineNum">    1612</span>                 :             : #endif</span>
<span id="L1613"><span class="lineNum">    1613</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             nBytes = node.m_sock-&gt;Send(reinterpret_cast&lt;const char*&gt;(data.data()), data.size(), flags);</span></span>
<span id="L1614"><span class="lineNum">    1614</span>                 :<span class="tlaGNC tlaBgGNC">           6 :         }</span></span>
<span id="L1615"><span class="lineNum">    1615</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         if (nBytes &gt; 0) {</span></span>
<span id="L1616"><span class="lineNum">    1616</span>                 :<span class="tlaUNC">           0 :             node.m_last_send = GetTime&lt;std::chrono::seconds&gt;();</span></span>
<span id="L1617"><span class="lineNum">    1617</span>                 :<span class="tlaUNC">           0 :             node.nSendBytes += nBytes;</span></span>
<span id="L1618"><span class="lineNum">    1618</span>                 :             :             // Notify transport that bytes have been processed.</span>
<span id="L1619"><span class="lineNum">    1619</span>                 :<span class="tlaUNC">           0 :             node.m_transport-&gt;MarkBytesSent(nBytes);</span></span>
<span id="L1620"><span class="lineNum">    1620</span>                 :             :             // Update statistics per message type.</span>
<span id="L1621"><span class="lineNum">    1621</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!msg_type.empty()) { // don't report v2 handshake bytes for now</span></span>
<span id="L1622"><span class="lineNum">    1622</span>                 :<span class="tlaUNC">           0 :                 node.AccountForSentBytes(msg_type, nBytes);</span></span>
<span id="L1623"><span class="lineNum">    1623</span>                 :             :             }</span>
<span id="L1624"><span class="lineNum">    1624</span>                 :<span class="tlaUNC">           0 :             nSentSize += nBytes;</span></span>
<span id="L1625"><span class="lineNum">    1625</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if ((size_t)nBytes != data.size()) {</span></span>
<span id="L1626"><span class="lineNum">    1626</span>                 :             :                 // could not send full message; stop sending more</span>
<span id="L1627"><span class="lineNum">    1627</span>                 :             :                 break;</span>
<span id="L1628"><span class="lineNum">    1628</span>                 :             :             }</span>
<span id="L1629"><span class="lineNum">    1629</span>                 :             :         } else {</span>
<span id="L1630"><span class="lineNum">    1630</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (nBytes &lt; 0) {</span></span>
<span id="L1631"><span class="lineNum">    1631</span>                 :             :                 // error</span>
<span id="L1632"><span class="lineNum">    1632</span>                 :<span class="tlaUNC">           0 :                 int nErr = WSAGetLastError();</span></span>
<span id="L1633"><span class="lineNum">    1633</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (nErr != WSAEWOULDBLOCK &amp;&amp; nErr != WSAEMSGSIZE &amp;&amp; nErr != WSAEINTR &amp;&amp; nErr != WSAEINPROGRESS) {</span></span>
<span id="L1634"><span class="lineNum">    1634</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     LogDebug(BCLog::NET, &quot;socket send error for peer=%d: %s\n&quot;, node.GetId(), NetworkErrorString(nErr));</span></span>
<span id="L1635"><span class="lineNum">    1635</span>                 :<span class="tlaUNC">           0 :                     node.CloseSocketDisconnect();</span></span>
<span id="L1636"><span class="lineNum">    1636</span>                 :             :                 }</span>
<span id="L1637"><span class="lineNum">    1637</span>                 :             :             }</span>
<span id="L1638"><span class="lineNum">    1638</span>                 :             :             break;</span>
<span id="L1639"><span class="lineNum">    1639</span>                 :             :         }</span>
<span id="L1640"><span class="lineNum">    1640</span>                 :             :     }</span>
<span id="L1641"><span class="lineNum">    1641</span>                 :             : </span>
<span id="L1642"><span class="lineNum">    1642</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC tlaBgGNC">           6 :     node.fPauseSend = node.m_send_memusage + node.m_transport-&gt;GetSendMemoryUsage() &gt; nSendBufferMaxSize;</span></span>
<span id="L1643"><span class="lineNum">    1643</span>                 :             : </span>
<span id="L1644"><span class="lineNum">    1644</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :     if (it == node.vSendMsg.end()) {</span></span>
<span id="L1645"><span class="lineNum">    1645</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           6 :         assert(node.m_send_memusage == 0);</span></span>
<span id="L1646"><span class="lineNum">    1646</span>                 :             :     }</span>
<span id="L1647"><span class="lineNum">    1647</span>                 :<span class="tlaGNC">           6 :     node.vSendMsg.erase(node.vSendMsg.begin(), it);</span></span>
<span id="L1648"><span class="lineNum">    1648</span>                 :<span class="tlaGNC">           6 :     return {nSentSize, data_left};</span></span>
<span id="L1649"><span class="lineNum">    1649</span>                 :             : }</span>
<span id="L1650"><span class="lineNum">    1650</span>                 :             : </span>
<span id="L1651"><span class="lineNum">    1651</span>                 :             : /** Try to find a connection to evict when the node is full.</span>
<span id="L1652"><span class="lineNum">    1652</span>                 :             :  *  Extreme care must be taken to avoid opening the node to attacker</span>
<span id="L1653"><span class="lineNum">    1653</span>                 :             :  *   triggered network partitioning.</span>
<span id="L1654"><span class="lineNum">    1654</span>                 :             :  *  The strategy used here is to protect a small number of peers</span>
<span id="L1655"><span class="lineNum">    1655</span>                 :             :  *   for each of several distinct characteristics which are difficult</span>
<span id="L1656"><span class="lineNum">    1656</span>                 :             :  *   to forge.  In order to partition a node the attacker must be</span>
<span id="L1657"><span class="lineNum">    1657</span>                 :             :  *   simultaneously better at all of them than honest peers.</span>
<span id="L1658"><span class="lineNum">    1658</span>                 :             :  */</span>
<span id="L1659"><span class="lineNum">    1659</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::AttemptToEvictConnection()</span></span>
<span id="L1660"><span class="lineNum">    1660</span>                 :             : {</span>
<span id="L1661"><span class="lineNum">    1661</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;NodeEvictionCandidate&gt; vEvictionCandidates;</span></span>
<span id="L1662"><span class="lineNum">    1662</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1663"><span class="lineNum">    1663</span>                 :             : </span>
<span id="L1664"><span class="lineNum">    1664</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L1665"><span class="lineNum">    1665</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (const CNode* node : m_nodes) {</span></span>
<span id="L1666"><span class="lineNum">    1666</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (node-&gt;fDisconnect)</span></span>
<span id="L1667"><span class="lineNum">    1667</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L1668"><span class="lineNum">    1668</span>                 :<span class="tlaUNC">           0 :             NodeEvictionCandidate candidate{</span></span>
<span id="L1669"><span class="lineNum">    1669</span>                 :<span class="tlaUNC">           0 :                 .id = node-&gt;GetId(),</span></span>
<span id="L1670"><span class="lineNum">    1670</span>                 :             :                 .m_connected = node-&gt;m_connected,</span>
<span id="L1671"><span class="lineNum">    1671</span>                 :<span class="tlaUNC">           0 :                 .m_min_ping_time = node-&gt;m_min_ping_time,</span></span>
<span id="L1672"><span class="lineNum">    1672</span>                 :<span class="tlaUNC">           0 :                 .m_last_block_time = node-&gt;m_last_block_time,</span></span>
<span id="L1673"><span class="lineNum">    1673</span>                 :<span class="tlaUNC">           0 :                 .m_last_tx_time = node-&gt;m_last_tx_time,</span></span>
<span id="L1674"><span class="lineNum">    1674</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 .fRelevantServices = node-&gt;m_has_all_wanted_services,</span></span>
<span id="L1675"><span class="lineNum">    1675</span>                 :<span class="tlaUNC">           0 :                 .m_relay_txs = node-&gt;m_relays_txs.load(),</span></span>
<span id="L1676"><span class="lineNum">    1676</span>                 :<span class="tlaUNC">           0 :                 .fBloomFilter = node-&gt;m_bloom_filter_loaded.load(),</span></span>
<span id="L1677"><span class="lineNum">    1677</span>                 :<span class="tlaUNC">           0 :                 .nKeyedNetGroup = node-&gt;nKeyedNetGroup,</span></span>
<span id="L1678"><span class="lineNum">    1678</span>                 :<span class="tlaUNC">           0 :                 .prefer_evict = node-&gt;m_prefer_evict,</span></span>
<span id="L1679"><span class="lineNum">    1679</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 .m_is_local = node-&gt;addr.IsLocal(),</span></span>
<span id="L1680"><span class="lineNum">    1680</span>                 :<span class="tlaUNC">           0 :                 .m_network = node-&gt;ConnectedThroughNetwork(),</span></span>
<span id="L1681"><span class="lineNum">    1681</span>                 :<span class="tlaUNC">           0 :                 .m_noban = node-&gt;HasPermission(NetPermissionFlags::NoBan),</span></span>
<span id="L1682"><span class="lineNum">    1682</span>                 :<span class="tlaUNC">           0 :                 .m_conn_type = node-&gt;m_conn_type,</span></span>
<span id="L1683"><span class="lineNum">    1683</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             };</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L1684"><span class="lineNum">    1684</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             vEvictionCandidates.push_back(candidate);</span></span>
<span id="L1685"><span class="lineNum">    1685</span>                 :             :         }</span>
<span id="L1686"><span class="lineNum">    1686</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1687"><span class="lineNum">    1687</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const std::optional&lt;NodeId&gt; node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));</span></span>
<span id="L1688"><span class="lineNum">    1688</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!node_id_to_evict) {</span></span>
<span id="L1689"><span class="lineNum">    1689</span>                 :             :         return false;</span>
<span id="L1690"><span class="lineNum">    1690</span>                 :             :     }</span>
<span id="L1691"><span class="lineNum">    1691</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L1692"><span class="lineNum">    1692</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (CNode* pnode : m_nodes) {</span></span>
<span id="L1693"><span class="lineNum">    1693</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (pnode-&gt;GetId() == *node_id_to_evict) {</span></span>
<span id="L1694"><span class="lineNum">    1694</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             LogDebug(BCLog::NET, &quot;selected %s connection for eviction peer=%d; disconnecting\n&quot;, pnode-&gt;ConnectionTypeAsString(), pnode-&gt;GetId());</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L1695"><span class="lineNum">    1695</span>                 :<span class="tlaUNC">           0 :             pnode-&gt;fDisconnect = true;</span></span>
<span id="L1696"><span class="lineNum">    1696</span>                 :<span class="tlaUNC">           0 :             return true;</span></span>
<span id="L1697"><span class="lineNum">    1697</span>                 :             :         }</span>
<span id="L1698"><span class="lineNum">    1698</span>                 :             :     }</span>
<span id="L1699"><span class="lineNum">    1699</span>                 :             :     return false;</span>
<span id="L1700"><span class="lineNum">    1700</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1701"><span class="lineNum">    1701</span>                 :             : </span>
<span id="L1702"><span class="lineNum">    1702</span>                 :<span class="tlaUNC">           0 : void CConnman::AcceptConnection(const ListenSocket&amp; hListenSocket) {</span></span>
<span id="L1703"><span class="lineNum">    1703</span>                 :<span class="tlaUNC">           0 :     struct sockaddr_storage sockaddr;</span></span>
<span id="L1704"><span class="lineNum">    1704</span>                 :<span class="tlaUNC">           0 :     socklen_t len = sizeof(sockaddr);</span></span>
<span id="L1705"><span class="lineNum">    1705</span>                 :<span class="tlaUNC">           0 :     auto sock = hListenSocket.sock-&gt;Accept((struct sockaddr*)&amp;sockaddr, &amp;len);</span></span>
<span id="L1706"><span class="lineNum">    1706</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     CAddress addr;</span></span>
<span id="L1707"><span class="lineNum">    1707</span>                 :             : </span>
<span id="L1708"><span class="lineNum">    1708</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!sock) {</span></span>
<span id="L1709"><span class="lineNum">    1709</span>                 :<span class="tlaUNC">           0 :         const int nErr = WSAGetLastError();</span></span>
<span id="L1710"><span class="lineNum">    1710</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (nErr != WSAEWOULDBLOCK) {</span></span>
<span id="L1711"><span class="lineNum">    1711</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogPrintf(&quot;socket error accept failed: %s\n&quot;, NetworkErrorString(nErr));</span></span>
<span id="L1712"><span class="lineNum">    1712</span>                 :             :         }</span>
<span id="L1713"><span class="lineNum">    1713</span>                 :<span class="tlaUNC">           0 :         return;</span></span>
<span id="L1714"><span class="lineNum">    1714</span>                 :             :     }</span>
<span id="L1715"><span class="lineNum">    1715</span>                 :             : </span>
<span id="L1716"><span class="lineNum">    1716</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!addr.SetSockAddr((const struct sockaddr*)&amp;sockaddr)) {</span></span>
<span id="L1717"><span class="lineNum">    1717</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogPrintLevel(BCLog::NET, BCLog::Level::Warning, &quot;Unknown socket family\n&quot;);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L1718"><span class="lineNum">    1718</span>                 :             :     } else {</span>
<span id="L1719"><span class="lineNum">    1719</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};</span></span>
<span id="L1720"><span class="lineNum">    1720</span>                 :             :     }</span>
<span id="L1721"><span class="lineNum">    1721</span>                 :             : </span>
<span id="L1722"><span class="lineNum">    1722</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock)), NODE_NONE};</span></span>
<span id="L1723"><span class="lineNum">    1723</span>                 :             : </span>
<span id="L1724"><span class="lineNum">    1724</span>                 :<span class="tlaUNC">           0 :     NetPermissionFlags permission_flags = NetPermissionFlags::None;</span></span>
<span id="L1725"><span class="lineNum">    1725</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     hListenSocket.AddSocketPermissionFlags(permission_flags);</span></span>
<span id="L1726"><span class="lineNum">    1726</span>                 :             : </span>
<span id="L1727"><span class="lineNum">    1727</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     CreateNodeFromAcceptedSocket(std::move(sock), permission_flags, addr_bind, addr);</span></span>
<span id="L1728"><span class="lineNum">    1728</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1729"><span class="lineNum">    1729</span>                 :             : </span>
<span id="L1730"><span class="lineNum">    1730</span>                 :<span class="tlaUNC">           0 : void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr&lt;Sock&gt;&amp;&amp; sock,</span></span>
<span id="L1731"><span class="lineNum">    1731</span>                 :             :                                             NetPermissionFlags permission_flags,</span>
<span id="L1732"><span class="lineNum">    1732</span>                 :             :                                             const CAddress&amp; addr_bind,</span>
<span id="L1733"><span class="lineNum">    1733</span>                 :             :                                             const CAddress&amp; addr)</span>
<span id="L1734"><span class="lineNum">    1734</span>                 :             : {</span>
<span id="L1735"><span class="lineNum">    1735</span>                 :<span class="tlaUNC">           0 :     int nInbound = 0;</span></span>
<span id="L1736"><span class="lineNum">    1736</span>                 :             : </span>
<span id="L1737"><span class="lineNum">    1737</span>                 :<span class="tlaUNC">           0 :     AddWhitelistPermissionFlags(permission_flags, addr, vWhitelistedRangeIncoming);</span></span>
<span id="L1738"><span class="lineNum">    1738</span>                 :             : </span>
<span id="L1739"><span class="lineNum">    1739</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1740"><span class="lineNum">    1740</span>                 :<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L1741"><span class="lineNum">    1741</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (const CNode* pnode : m_nodes) {</span></span>
<span id="L1742"><span class="lineNum">    1742</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (pnode-&gt;IsInboundConn()) nInbound++;</span></span>
<span id="L1743"><span class="lineNum">    1743</span>                 :             :         }</span>
<span id="L1744"><span class="lineNum">    1744</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1745"><span class="lineNum">    1745</span>                 :             : </span>
<span id="L1746"><span class="lineNum">    1746</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!fNetworkActive) {</span></span>
<span id="L1747"><span class="lineNum">    1747</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;connection from %s dropped: not accepting new connections\n&quot;, addr.ToStringAddrPort());</span></span>
<span id="L1748"><span class="lineNum">    1748</span>                 :<span class="tlaUNC">           0 :         return;</span></span>
<span id="L1749"><span class="lineNum">    1749</span>                 :             :     }</span>
<span id="L1750"><span class="lineNum">    1750</span>                 :             : </span>
<span id="L1751"><span class="lineNum">    1751</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!sock-&gt;IsSelectable()) {</span></span>
<span id="L1752"><span class="lineNum">    1752</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;connection from %s dropped: non-selectable socket\n&quot;, addr.ToStringAddrPort());</span></span>
<span id="L1753"><span class="lineNum">    1753</span>                 :<span class="tlaUNC">           0 :         return;</span></span>
<span id="L1754"><span class="lineNum">    1754</span>                 :             :     }</span>
<span id="L1755"><span class="lineNum">    1755</span>                 :             : </span>
<span id="L1756"><span class="lineNum">    1756</span>                 :             :     // According to the internet TCP_NODELAY is not carried into accepted sockets</span>
<span id="L1757"><span class="lineNum">    1757</span>                 :             :     // on all platforms.  Set it again here just to be sure.</span>
<span id="L1758"><span class="lineNum">    1758</span>                 :<span class="tlaUNC">           0 :     const int on{1};</span></span>
<span id="L1759"><span class="lineNum">    1759</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (sock-&gt;SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &amp;on, sizeof(on)) == SOCKET_ERROR) {</span></span>
<span id="L1760"><span class="lineNum">    1760</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;connection from %s: unable to set TCP_NODELAY, continuing anyway\n&quot;,</span></span>
<span id="L1761"><span class="lineNum">    1761</span>                 :             :                  addr.ToStringAddrPort());</span>
<span id="L1762"><span class="lineNum">    1762</span>                 :             :     }</span>
<span id="L1763"><span class="lineNum">    1763</span>                 :             : </span>
<span id="L1764"><span class="lineNum">    1764</span>                 :             :     // Don't accept connections from banned peers.</span>
<span id="L1765"><span class="lineNum">    1765</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     bool banned = m_banman &amp;&amp; m_banman-&gt;IsBanned(addr);</span></span>
<span id="L1766"><span class="lineNum">    1766</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan) &amp;&amp; banned)</span></span>
<span id="L1767"><span class="lineNum">    1767</span>                 :             :     {</span>
<span id="L1768"><span class="lineNum">    1768</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;connection from %s dropped (banned)\n&quot;, addr.ToStringAddrPort());</span></span>
<span id="L1769"><span class="lineNum">    1769</span>                 :<span class="tlaUNC">           0 :         return;</span></span>
<span id="L1770"><span class="lineNum">    1770</span>                 :             :     }</span>
<span id="L1771"><span class="lineNum">    1771</span>                 :             : </span>
<span id="L1772"><span class="lineNum">    1772</span>                 :             :     // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.</span>
<span id="L1773"><span class="lineNum">    1773</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     bool discouraged = m_banman &amp;&amp; m_banman-&gt;IsDiscouraged(addr);</span></span>
<span id="L1774"><span class="lineNum">    1774</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     if (!NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan) &amp;&amp; nInbound + 1 &gt;= m_max_inbound &amp;&amp; discouraged)</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L1775"><span class="lineNum">    1775</span>                 :             :     {</span>
<span id="L1776"><span class="lineNum">    1776</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;connection from %s dropped (discouraged)\n&quot;, addr.ToStringAddrPort());</span></span>
<span id="L1777"><span class="lineNum">    1777</span>                 :<span class="tlaUNC">           0 :         return;</span></span>
<span id="L1778"><span class="lineNum">    1778</span>                 :             :     }</span>
<span id="L1779"><span class="lineNum">    1779</span>                 :             : </span>
<span id="L1780"><span class="lineNum">    1780</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nInbound &gt;= m_max_inbound)</span></span>
<span id="L1781"><span class="lineNum">    1781</span>                 :             :     {</span>
<span id="L1782"><span class="lineNum">    1782</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!AttemptToEvictConnection()) {</span></span>
<span id="L1783"><span class="lineNum">    1783</span>                 :             :             // No connection to evict, disconnect the new connection</span>
<span id="L1784"><span class="lineNum">    1784</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogDebug(BCLog::NET, &quot;failed to find an eviction candidate - connection dropped (full)\n&quot;);</span></span>
<span id="L1785"><span class="lineNum">    1785</span>                 :<span class="tlaUNC">           0 :             return;</span></span>
<span id="L1786"><span class="lineNum">    1786</span>                 :             :         }</span>
<span id="L1787"><span class="lineNum">    1787</span>                 :             :     }</span>
<span id="L1788"><span class="lineNum">    1788</span>                 :             : </span>
<span id="L1789"><span class="lineNum">    1789</span>                 :<span class="tlaUNC">           0 :     NodeId id = GetNewNodeId();</span></span>
<span id="L1790"><span class="lineNum">    1790</span>                 :<span class="tlaUNC">           0 :     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();</span></span>
<span id="L1791"><span class="lineNum">    1791</span>                 :             : </span>
<span id="L1792"><span class="lineNum">    1792</span>                 :<span class="tlaUNC">           0 :     const bool inbound_onion = std::find(m_onion_binds.begin(), m_onion_binds.end(), addr_bind) != m_onion_binds.end();</span></span>
<span id="L1793"><span class="lineNum">    1793</span>                 :             :     // The V2Transport transparently falls back to V1 behavior when an incoming V1 connection is</span>
<span id="L1794"><span class="lineNum">    1794</span>                 :             :     // detected, so use it whenever we signal NODE_P2P_V2.</span>
<span id="L1795"><span class="lineNum">    1795</span>                 :<span class="tlaUNC">           0 :     ServiceFlags local_services = GetLocalServices();</span></span>
<span id="L1796"><span class="lineNum">    1796</span>                 :<span class="tlaUNC">           0 :     const bool use_v2transport(local_services &amp; NODE_P2P_V2);</span></span>
<span id="L1797"><span class="lineNum">    1797</span>                 :             : </span>
<span id="L1798"><span class="lineNum">    1798</span>                 :<span class="tlaUNC">           0 :     CNode* pnode = new CNode(id,</span></span>
<span id="L1799"><span class="lineNum">    1799</span>                 :             :                              std::move(sock),</span>
<span id="L1800"><span class="lineNum">    1800</span>                 :             :                              addr,</span>
<span id="L1801"><span class="lineNum">    1801</span>                 :             :                              CalculateKeyedNetGroup(addr),</span>
<span id="L1802"><span class="lineNum">    1802</span>                 :             :                              nonce,</span>
<span id="L1803"><span class="lineNum">    1803</span>                 :             :                              addr_bind,</span>
<span id="L1804"><span class="lineNum">    1804</span>                 :             :                              /*addrNameIn=*/&quot;&quot;,</span>
<span id="L1805"><span class="lineNum">    1805</span>                 :             :                              ConnectionType::INBOUND,</span>
<span id="L1806"><span class="lineNum">    1806</span>                 :             :                              inbound_onion,</span>
<span id="L1807"><span class="lineNum">    1807</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                              CNodeOptions{</span></span>
<span id="L1808"><span class="lineNum">    1808</span>                 :             :                                  .permission_flags = permission_flags,</span>
<span id="L1809"><span class="lineNum">    1809</span>                 :             :                                  .prefer_evict = discouraged,</span>
<span id="L1810"><span class="lineNum">    1810</span>                 :<span class="tlaUNC">           0 :                                  .recv_flood_size = nReceiveFloodSize,</span></span>
<span id="L1811"><span class="lineNum">    1811</span>                 :             :                                  .use_v2transport = use_v2transport,</span>
<span id="L1812"><span class="lineNum">    1812</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                              });</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L1813"><span class="lineNum">    1813</span>                 :<span class="tlaUNC">           0 :     pnode-&gt;AddRef();</span></span>
<span id="L1814"><span class="lineNum">    1814</span>                 :<span class="tlaUNC">           0 :     m_msgproc-&gt;InitializeNode(*pnode, local_services);</span></span>
<span id="L1815"><span class="lineNum">    1815</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1816"><span class="lineNum">    1816</span>                 :<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L1817"><span class="lineNum">    1817</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         m_nodes.push_back(pnode);</span></span>
<span id="L1818"><span class="lineNum">    1818</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1819"><span class="lineNum">    1819</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     LogDebug(BCLog::NET, &quot;connection from %s accepted\n&quot;, addr.ToStringAddrPort());</span></span>
<span id="L1820"><span class="lineNum">    1820</span>                 :             : </span>
<span id="L1821"><span class="lineNum">    1821</span>                 :             :     // We received a new connection, harvest entropy from the time (and our peer count)</span>
<span id="L1822"><span class="lineNum">    1822</span>                 :<span class="tlaUNC">           0 :     RandAddEvent((uint32_t)id);</span></span>
<span id="L1823"><span class="lineNum">    1823</span>                 :             : }</span>
<span id="L1824"><span class="lineNum">    1824</span>                 :             : </span>
<span id="L1825"><span class="lineNum">    1825</span>                 :<span class="tlaUNC">           0 : bool CConnman::AddConnection(const std::string&amp; address, ConnectionType conn_type, bool use_v2transport = false)</span></span>
<span id="L1826"><span class="lineNum">    1826</span>                 :             : {</span>
<span id="L1827"><span class="lineNum">    1827</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L1828"><span class="lineNum">    1828</span>                 :<span class="tlaUNC">           0 :     std::optional&lt;int&gt; max_connections;</span></span>
<span id="L1829"><span class="lineNum">    1829</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     switch (conn_type) {</span></span>
<span id="L1830"><span class="lineNum">    1830</span>                 :             :     case ConnectionType::INBOUND:</span>
<span id="L1831"><span class="lineNum">    1831</span>                 :             :     case ConnectionType::MANUAL:</span>
<span id="L1832"><span class="lineNum">    1832</span>                 :             :         return false;</span>
<span id="L1833"><span class="lineNum">    1833</span>                 :<span class="tlaUNC">           0 :     case ConnectionType::OUTBOUND_FULL_RELAY:</span></span>
<span id="L1834"><span class="lineNum">    1834</span>                 :<span class="tlaUNC">           0 :         max_connections = m_max_outbound_full_relay;</span></span>
<span id="L1835"><span class="lineNum">    1835</span>                 :<span class="tlaUNC">           0 :         break;</span></span>
<span id="L1836"><span class="lineNum">    1836</span>                 :<span class="tlaUNC">           0 :     case ConnectionType::BLOCK_RELAY:</span></span>
<span id="L1837"><span class="lineNum">    1837</span>                 :<span class="tlaUNC">           0 :         max_connections = m_max_outbound_block_relay;</span></span>
<span id="L1838"><span class="lineNum">    1838</span>                 :<span class="tlaUNC">           0 :         break;</span></span>
<span id="L1839"><span class="lineNum">    1839</span>                 :             :     // no limit for ADDR_FETCH because -seednode has no limit either</span>
<span id="L1840"><span class="lineNum">    1840</span>                 :             :     case ConnectionType::ADDR_FETCH:</span>
<span id="L1841"><span class="lineNum">    1841</span>                 :             :         break;</span>
<span id="L1842"><span class="lineNum">    1842</span>                 :             :     // no limit for FEELER connections since they're short-lived</span>
<span id="L1843"><span class="lineNum">    1843</span>                 :             :     case ConnectionType::FEELER:</span>
<span id="L1844"><span class="lineNum">    1844</span>                 :             :         break;</span>
<span id="L1845"><span class="lineNum">    1845</span>                 :             :     } // no default case, so the compiler can warn about missing cases</span>
<span id="L1846"><span class="lineNum">    1846</span>                 :             : </span>
<span id="L1847"><span class="lineNum">    1847</span>                 :             :     // Count existing connections</span>
<span id="L1848"><span class="lineNum">    1848</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     int existing_connections = WITH_LOCK(m_nodes_mutex,</span></span>
<span id="L1849"><span class="lineNum">    1849</span>                 :             :                                          return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node-&gt;m_conn_type == conn_type; }););</span>
<span id="L1850"><span class="lineNum">    1850</span>                 :             : </span>
<span id="L1851"><span class="lineNum">    1851</span>                 :             :     // Max connections of specified type already exist</span>
<span id="L1852"><span class="lineNum">    1852</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (max_connections != std::nullopt &amp;&amp; existing_connections &gt;= max_connections) return false;</span></span>
<span id="L1853"><span class="lineNum">    1853</span>                 :             : </span>
<span id="L1854"><span class="lineNum">    1854</span>                 :             :     // Max total outbound connections already exist</span>
<span id="L1855"><span class="lineNum">    1855</span>                 :<span class="tlaUNC">           0 :     CSemaphoreGrant grant(*semOutbound, true);</span></span>
<span id="L1856"><span class="lineNum">    1856</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!grant) return false;</span></span>
<span id="L1857"><span class="lineNum">    1857</span>                 :             : </span>
<span id="L1858"><span class="lineNum">    1858</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     OpenNetworkConnection(CAddress(), false, std::move(grant), address.c_str(), conn_type, /*use_v2transport=*/use_v2transport);</span></span>
<span id="L1859"><span class="lineNum">    1859</span>                 :<span class="tlaUNC">           0 :     return true;</span></span>
<span id="L1860"><span class="lineNum">    1860</span>                 :             : }</span>
<span id="L1861"><span class="lineNum">    1861</span>                 :             : </span>
<span id="L1862"><span class="lineNum">    1862</span>                 :<span class="tlaUNC">           0 : void CConnman::DisconnectNodes()</span></span>
<span id="L1863"><span class="lineNum">    1863</span>                 :             : {</span>
<span id="L1864"><span class="lineNum">    1864</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_nodes_mutex);</span></span>
<span id="L1865"><span class="lineNum">    1865</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_reconnections_mutex);</span></span>
<span id="L1866"><span class="lineNum">    1866</span>                 :             : </span>
<span id="L1867"><span class="lineNum">    1867</span>                 :             :     // Use a temporary variable to accumulate desired reconnections, so we don't need</span>
<span id="L1868"><span class="lineNum">    1868</span>                 :             :     // m_reconnections_mutex while holding m_nodes_mutex.</span>
<span id="L1869"><span class="lineNum">    1869</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     decltype(m_reconnections) reconnections_to_add;</span></span>
<span id="L1870"><span class="lineNum">    1870</span>                 :             : </span>
<span id="L1871"><span class="lineNum">    1871</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1872"><span class="lineNum">    1872</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L1873"><span class="lineNum">    1873</span>                 :             : </span>
<span id="L1874"><span class="lineNum">    1874</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!fNetworkActive) {</span></span>
<span id="L1875"><span class="lineNum">    1875</span>                 :             :             // Disconnect any connected nodes</span>
<span id="L1876"><span class="lineNum">    1876</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (CNode* pnode : m_nodes) {</span></span>
<span id="L1877"><span class="lineNum">    1877</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!pnode-&gt;fDisconnect) {</span></span>
<span id="L1878"><span class="lineNum">    1878</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                     LogDebug(BCLog::NET, &quot;Network not active, dropping peer=%d\n&quot;, pnode-&gt;GetId());</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L1879"><span class="lineNum">    1879</span>                 :<span class="tlaUNC">           0 :                     pnode-&gt;fDisconnect = true;</span></span>
<span id="L1880"><span class="lineNum">    1880</span>                 :             :                 }</span>
<span id="L1881"><span class="lineNum">    1881</span>                 :             :             }</span>
<span id="L1882"><span class="lineNum">    1882</span>                 :             :         }</span>
<span id="L1883"><span class="lineNum">    1883</span>                 :             : </span>
<span id="L1884"><span class="lineNum">    1884</span>                 :             :         // Disconnect unused nodes</span>
<span id="L1885"><span class="lineNum">    1885</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         std::vector&lt;CNode*&gt; nodes_copy = m_nodes;</span></span>
<span id="L1886"><span class="lineNum">    1886</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (CNode* pnode : nodes_copy)</span></span>
<span id="L1887"><span class="lineNum">    1887</span>                 :             :         {</span>
<span id="L1888"><span class="lineNum">    1888</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (pnode-&gt;fDisconnect)</span></span>
<span id="L1889"><span class="lineNum">    1889</span>                 :             :             {</span>
<span id="L1890"><span class="lineNum">    1890</span>                 :             :                 // remove from m_nodes</span>
<span id="L1891"><span class="lineNum">    1891</span>                 :<span class="tlaUNC">           0 :                 m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());</span></span>
<span id="L1892"><span class="lineNum">    1892</span>                 :             : </span>
<span id="L1893"><span class="lineNum">    1893</span>                 :             :                 // Add to reconnection list if appropriate. We don't reconnect right here, because</span>
<span id="L1894"><span class="lineNum">    1894</span>                 :             :                 // the creation of a connection is a blocking operation (up to several seconds),</span>
<span id="L1895"><span class="lineNum">    1895</span>                 :             :                 // and we don't want to hold up the socket handler thread for that long.</span>
<span id="L1896"><span class="lineNum">    1896</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (pnode-&gt;m_transport-&gt;ShouldReconnectV1()) {</span></span>
<span id="L1897"><span class="lineNum">    1897</span>                 :<span class="tlaUNC">           0 :                     reconnections_to_add.push_back({</span></span>
<span id="L1898"><span class="lineNum">    1898</span>                 :<span class="tlaUNC">           0 :                         .addr_connect = pnode-&gt;addr,</span></span>
<span id="L1899"><span class="lineNum">    1899</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         .grant = std::move(pnode-&gt;grantOutbound),</span></span>
<span id="L1900"><span class="lineNum">    1900</span>                 :<span class="tlaUNC">           0 :                         .destination = pnode-&gt;m_dest,</span></span>
<span id="L1901"><span class="lineNum">    1901</span>                 :<span class="tlaUNC">           0 :                         .conn_type = pnode-&gt;m_conn_type,</span></span>
<span id="L1902"><span class="lineNum">    1902</span>                 :             :                         .use_v2transport = false});</span>
<span id="L1903"><span class="lineNum">    1903</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                     LogDebug(BCLog::NET, &quot;retrying with v1 transport protocol for peer=%d\n&quot;, pnode-&gt;GetId());</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L1904"><span class="lineNum">    1904</span>                 :             :                 }</span>
<span id="L1905"><span class="lineNum">    1905</span>                 :             : </span>
<span id="L1906"><span class="lineNum">    1906</span>                 :             :                 // release outbound grant (if any)</span>
<span id="L1907"><span class="lineNum">    1907</span>                 :<span class="tlaUNC">           0 :                 pnode-&gt;grantOutbound.Release();</span></span>
<span id="L1908"><span class="lineNum">    1908</span>                 :             : </span>
<span id="L1909"><span class="lineNum">    1909</span>                 :             :                 // close socket and cleanup</span>
<span id="L1910"><span class="lineNum">    1910</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 pnode-&gt;CloseSocketDisconnect();</span></span>
<span id="L1911"><span class="lineNum">    1911</span>                 :             : </span>
<span id="L1912"><span class="lineNum">    1912</span>                 :             :                 // update connection count by network</span>
<span id="L1913"><span class="lineNum">    1913</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (pnode-&gt;IsManualOrFullOutboundConn()) --m_network_conn_counts[pnode-&gt;addr.GetNetwork()];</span></span>
<span id="L1914"><span class="lineNum">    1914</span>                 :             : </span>
<span id="L1915"><span class="lineNum">    1915</span>                 :             :                 // hold in disconnected pool until all refs are released</span>
<span id="L1916"><span class="lineNum">    1916</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 pnode-&gt;Release();</span></span>
<span id="L1917"><span class="lineNum">    1917</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 m_nodes_disconnected.push_back(pnode);</span></span>
<span id="L1918"><span class="lineNum">    1918</span>                 :             :             }</span>
<span id="L1919"><span class="lineNum">    1919</span>                 :             :         }</span>
<span id="L1920"><span class="lineNum">    1920</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     }</span></span>
<span id="L1921"><span class="lineNum">    1921</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1922"><span class="lineNum">    1922</span>                 :             :         // Delete disconnected nodes</span>
<span id="L1923"><span class="lineNum">    1923</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         std::list&lt;CNode*&gt; nodes_disconnected_copy = m_nodes_disconnected;</span></span>
<span id="L1924"><span class="lineNum">    1924</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (CNode* pnode : nodes_disconnected_copy)</span></span>
<span id="L1925"><span class="lineNum">    1925</span>                 :             :         {</span>
<span id="L1926"><span class="lineNum">    1926</span>                 :             :             // Destroy the object only after other threads have stopped using it.</span>
<span id="L1927"><span class="lineNum">    1927</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (pnode-&gt;GetRefCount() &lt;= 0) {</span></span>
<span id="L1928"><span class="lineNum">    1928</span>                 :<span class="tlaUNC">           0 :                 m_nodes_disconnected.remove(pnode);</span></span>
<span id="L1929"><span class="lineNum">    1929</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 DeleteNode(pnode);</span></span>
<span id="L1930"><span class="lineNum">    1930</span>                 :             :             }</span>
<span id="L1931"><span class="lineNum">    1931</span>                 :             :         }</span>
<span id="L1932"><span class="lineNum">    1932</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1933"><span class="lineNum">    1933</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1934"><span class="lineNum">    1934</span>                 :             :         // Move entries from reconnections_to_add to m_reconnections.</span>
<span id="L1935"><span class="lineNum">    1935</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LOCK(m_reconnections_mutex);</span></span>
<span id="L1936"><span class="lineNum">    1936</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         m_reconnections.splice(m_reconnections.end(), std::move(reconnections_to_add));</span></span>
<span id="L1937"><span class="lineNum">    1937</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1938"><span class="lineNum">    1938</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 : }</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L1939"><span class="lineNum">    1939</span>                 :             : </span>
<span id="L1940"><span class="lineNum">    1940</span>                 :<span class="tlaUNC">           0 : void CConnman::NotifyNumConnectionsChanged()</span></span>
<span id="L1941"><span class="lineNum">    1941</span>                 :             : {</span>
<span id="L1942"><span class="lineNum">    1942</span>                 :<span class="tlaUNC">           0 :     size_t nodes_size;</span></span>
<span id="L1943"><span class="lineNum">    1943</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L1944"><span class="lineNum">    1944</span>                 :<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L1945"><span class="lineNum">    1945</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         nodes_size = m_nodes.size();</span></span>
<span id="L1946"><span class="lineNum">    1946</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1947"><span class="lineNum">    1947</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if(nodes_size != nPrevNodeCount) {</span></span>
<span id="L1948"><span class="lineNum">    1948</span>                 :<span class="tlaUNC">           0 :         nPrevNodeCount = nodes_size;</span></span>
<span id="L1949"><span class="lineNum">    1949</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (m_client_interface) {</span></span>
<span id="L1950"><span class="lineNum">    1950</span>                 :<span class="tlaUNC">           0 :             m_client_interface-&gt;NotifyNumConnectionsChanged(nodes_size);</span></span>
<span id="L1951"><span class="lineNum">    1951</span>                 :             :         }</span>
<span id="L1952"><span class="lineNum">    1952</span>                 :             :     }</span>
<span id="L1953"><span class="lineNum">    1953</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1954"><span class="lineNum">    1954</span>                 :             : </span>
<span id="L1955"><span class="lineNum">    1955</span>                 :<span class="tlaGNC tlaBgGNC">           6 : bool CConnman::ShouldRunInactivityChecks(const CNode&amp; node, std::chrono::seconds now) const</span></span>
<span id="L1956"><span class="lineNum">    1956</span>                 :             : {</span>
<span id="L1957"><span class="lineNum">    1957</span>                 :<span class="tlaGNC">           6 :     return node.m_connected + m_peer_connect_timeout &lt; now;</span></span>
<span id="L1958"><span class="lineNum">    1958</span>                 :             : }</span>
<span id="L1959"><span class="lineNum">    1959</span>                 :             : </span>
<span id="L1960"><span class="lineNum">    1960</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::InactivityCheck(const CNode&amp; node) const</span></span>
<span id="L1961"><span class="lineNum">    1961</span>                 :             : {</span>
<span id="L1962"><span class="lineNum">    1962</span>                 :             :     // Tests that see disconnects after using mocktime can start nodes with a</span>
<span id="L1963"><span class="lineNum">    1963</span>                 :             :     // large timeout. For example, -peertimeout=999999999.</span>
<span id="L1964"><span class="lineNum">    1964</span>                 :<span class="tlaUNC">           0 :     const auto now{GetTime&lt;std::chrono::seconds&gt;()};</span></span>
<span id="L1965"><span class="lineNum">    1965</span>                 :<span class="tlaUNC">           0 :     const auto last_send{node.m_last_send.load()};</span></span>
<span id="L1966"><span class="lineNum">    1966</span>                 :<span class="tlaUNC">           0 :     const auto last_recv{node.m_last_recv.load()};</span></span>
<span id="L1967"><span class="lineNum">    1967</span>                 :             : </span>
<span id="L1968"><span class="lineNum">    1968</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!ShouldRunInactivityChecks(node, now)) return false;</span></span>
<span id="L1969"><span class="lineNum">    1969</span>                 :             : </span>
<span id="L1970"><span class="lineNum">    1970</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (last_recv.count() == 0 || last_send.count() == 0) {</span></span>
<span id="L1971"><span class="lineNum">    1971</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;socket no message in first %i seconds, %d %d peer=%d\n&quot;, count_seconds(m_peer_connect_timeout), last_recv.count() != 0, last_send.count() != 0, node.GetId());</span></span>
<span id="L1972"><span class="lineNum">    1972</span>                 :<span class="tlaUNC">           0 :         return true;</span></span>
<span id="L1973"><span class="lineNum">    1973</span>                 :             :     }</span>
<span id="L1974"><span class="lineNum">    1974</span>                 :             : </span>
<span id="L1975"><span class="lineNum">    1975</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (now &gt; last_send + TIMEOUT_INTERVAL) {</span></span>
<span id="L1976"><span class="lineNum">    1976</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;socket sending timeout: %is peer=%d\n&quot;, count_seconds(now - last_send), node.GetId());</span></span>
<span id="L1977"><span class="lineNum">    1977</span>                 :<span class="tlaUNC">           0 :         return true;</span></span>
<span id="L1978"><span class="lineNum">    1978</span>                 :             :     }</span>
<span id="L1979"><span class="lineNum">    1979</span>                 :             : </span>
<span id="L1980"><span class="lineNum">    1980</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (now &gt; last_recv + TIMEOUT_INTERVAL) {</span></span>
<span id="L1981"><span class="lineNum">    1981</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;socket receive timeout: %is peer=%d\n&quot;, count_seconds(now - last_recv), node.GetId());</span></span>
<span id="L1982"><span class="lineNum">    1982</span>                 :<span class="tlaUNC">           0 :         return true;</span></span>
<span id="L1983"><span class="lineNum">    1983</span>                 :             :     }</span>
<span id="L1984"><span class="lineNum">    1984</span>                 :             : </span>
<span id="L1985"><span class="lineNum">    1985</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!node.fSuccessfullyConnected) {</span></span>
<span id="L1986"><span class="lineNum">    1986</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (node.m_transport-&gt;GetInfo().transport_type == TransportProtocolType::DETECTING) {</span></span>
<span id="L1987"><span class="lineNum">    1987</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogDebug(BCLog::NET, &quot;V2 handshake timeout peer=%d\n&quot;, node.GetId());</span></span>
<span id="L1988"><span class="lineNum">    1988</span>                 :             :         } else {</span>
<span id="L1989"><span class="lineNum">    1989</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogDebug(BCLog::NET, &quot;version handshake timeout peer=%d\n&quot;, node.GetId());</span></span>
<span id="L1990"><span class="lineNum">    1990</span>                 :             :         }</span>
<span id="L1991"><span class="lineNum">    1991</span>                 :<span class="tlaUNC">           0 :         return true;</span></span>
<span id="L1992"><span class="lineNum">    1992</span>                 :             :     }</span>
<span id="L1993"><span class="lineNum">    1993</span>                 :             : </span>
<span id="L1994"><span class="lineNum">    1994</span>                 :             :     return false;</span>
<span id="L1995"><span class="lineNum">    1995</span>                 :             : }</span>
<span id="L1996"><span class="lineNum">    1996</span>                 :             : </span>
<span id="L1997"><span class="lineNum">    1997</span>                 :<span class="tlaUNC">           0 : Sock::EventsPerSock CConnman::GenerateWaitSockets(Span&lt;CNode* const&gt; nodes)</span></span>
<span id="L1998"><span class="lineNum">    1998</span>                 :             : {</span>
<span id="L1999"><span class="lineNum">    1999</span>                 :<span class="tlaUNC">           0 :     Sock::EventsPerSock events_per_sock;</span></span>
<span id="L2000"><span class="lineNum">    2000</span>                 :             : </span>
<span id="L2001"><span class="lineNum">    2001</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const ListenSocket&amp; hListenSocket : vhListenSocket) {</span></span>
<span id="L2002"><span class="lineNum">    2002</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV});</span></span>
<span id="L2003"><span class="lineNum">    2003</span>                 :             :     }</span>
<span id="L2004"><span class="lineNum">    2004</span>                 :             : </span>
<span id="L2005"><span class="lineNum">    2005</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (CNode* pnode : nodes) {</span></span>
<span id="L2006"><span class="lineNum">    2006</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         bool select_recv = !pnode-&gt;fPauseRecv;</span></span>
<span id="L2007"><span class="lineNum">    2007</span>                 :<span class="tlaUNC">           0 :         bool select_send;</span></span>
<span id="L2008"><span class="lineNum">    2008</span>                 :<span class="tlaUNC">           0 :         {</span></span>
<span id="L2009"><span class="lineNum">    2009</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LOCK(pnode-&gt;cs_vSend);</span></span>
<span id="L2010"><span class="lineNum">    2010</span>                 :             :             // Sending is possible if either there are bytes to send right now, or if there will be</span>
<span id="L2011"><span class="lineNum">    2011</span>                 :             :             // once a potential message from vSendMsg is handed to the transport. GetBytesToSend</span>
<span id="L2012"><span class="lineNum">    2012</span>                 :             :             // determines both of these in a single call.</span>
<span id="L2013"><span class="lineNum">    2013</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             const auto&amp; [to_send, more, _msg_type] = pnode-&gt;m_transport-&gt;GetBytesToSend(!pnode-&gt;vSendMsg.empty());</span></span>
<span id="L2014"><span class="lineNum">    2014</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             select_send = !to_send.empty() || more;</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2015"><span class="lineNum">    2015</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L2016"><span class="lineNum">    2016</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!select_recv &amp;&amp; !select_send) continue;</span></span>
<span id="L2017"><span class="lineNum">    2017</span>                 :             : </span>
<span id="L2018"><span class="lineNum">    2018</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LOCK(pnode-&gt;m_sock_mutex);</span></span>
<span id="L2019"><span class="lineNum">    2019</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (pnode-&gt;m_sock) {</span></span>
<span id="L2020"><span class="lineNum">    2020</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);</span></span>
<span id="L2021"><span class="lineNum">    2021</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             events_per_sock.emplace(pnode-&gt;m_sock, Sock::Events{event});</span></span>
<span id="L2022"><span class="lineNum">    2022</span>                 :             :         }</span>
<span id="L2023"><span class="lineNum">    2023</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2024"><span class="lineNum">    2024</span>                 :             : </span>
<span id="L2025"><span class="lineNum">    2025</span>                 :<span class="tlaUNC">           0 :     return events_per_sock;</span></span>
<span id="L2026"><span class="lineNum">    2026</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2027"><span class="lineNum">    2027</span>                 :             : </span>
<span id="L2028"><span class="lineNum">    2028</span>                 :<span class="tlaUNC">           0 : void CConnman::SocketHandler()</span></span>
<span id="L2029"><span class="lineNum">    2029</span>                 :             : {</span>
<span id="L2030"><span class="lineNum">    2030</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L2031"><span class="lineNum">    2031</span>                 :             : </span>
<span id="L2032"><span class="lineNum">    2032</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     Sock::EventsPerSock events_per_sock;</span></span>
<span id="L2033"><span class="lineNum">    2033</span>                 :             : </span>
<span id="L2034"><span class="lineNum">    2034</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L2035"><span class="lineNum">    2035</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const NodesSnapshot snap{*this, /*shuffle=*/false};</span></span>
<span id="L2036"><span class="lineNum">    2036</span>                 :             : </span>
<span id="L2037"><span class="lineNum">    2037</span>                 :<span class="tlaUNC">           0 :         const auto timeout = std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS);</span></span>
<span id="L2038"><span class="lineNum">    2038</span>                 :             : </span>
<span id="L2039"><span class="lineNum">    2039</span>                 :             :         // Check for the readiness of the already connected sockets and the</span>
<span id="L2040"><span class="lineNum">    2040</span>                 :             :         // listening sockets in one call (&quot;readiness&quot; as in poll(2) or</span>
<span id="L2041"><span class="lineNum">    2041</span>                 :             :         // select(2)). If none are ready, wait for a short while and return</span>
<span id="L2042"><span class="lineNum">    2042</span>                 :             :         // empty sets.</span>
<span id="L2043"><span class="lineNum">    2043</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         events_per_sock = GenerateWaitSockets(snap.Nodes());</span></span>
<span id="L2044"><span class="lineNum">    2044</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         if (events_per_sock.empty() || !events_per_sock.begin()-&gt;first-&gt;WaitMany(timeout, events_per_sock)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2045"><span class="lineNum">    2045</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             interruptNet.sleep_for(timeout);</span></span>
<span id="L2046"><span class="lineNum">    2046</span>                 :             :         }</span>
<span id="L2047"><span class="lineNum">    2047</span>                 :             : </span>
<span id="L2048"><span class="lineNum">    2048</span>                 :             :         // Service (send/receive) each of the already connected nodes.</span>
<span id="L2049"><span class="lineNum">    2049</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         SocketHandlerConnected(snap.Nodes(), events_per_sock);</span></span>
<span id="L2050"><span class="lineNum">    2050</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2051"><span class="lineNum">    2051</span>                 :             : </span>
<span id="L2052"><span class="lineNum">    2052</span>                 :             :     // Accept new connections from listening sockets.</span>
<span id="L2053"><span class="lineNum">    2053</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     SocketHandlerListening(events_per_sock);</span></span>
<span id="L2054"><span class="lineNum">    2054</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2055"><span class="lineNum">    2055</span>                 :             : </span>
<span id="L2056"><span class="lineNum">    2056</span>                 :<span class="tlaUNC">           0 : void CConnman::SocketHandlerConnected(const std::vector&lt;CNode*&gt;&amp; nodes,</span></span>
<span id="L2057"><span class="lineNum">    2057</span>                 :             :                                       const Sock::EventsPerSock&amp; events_per_sock)</span>
<span id="L2058"><span class="lineNum">    2058</span>                 :             : {</span>
<span id="L2059"><span class="lineNum">    2059</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L2060"><span class="lineNum">    2060</span>                 :             : </span>
<span id="L2061"><span class="lineNum">    2061</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (CNode* pnode : nodes) {</span></span>
<span id="L2062"><span class="lineNum">    2062</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (interruptNet)</span></span>
<span id="L2063"><span class="lineNum">    2063</span>                 :             :             return;</span>
<span id="L2064"><span class="lineNum">    2064</span>                 :             : </span>
<span id="L2065"><span class="lineNum">    2065</span>                 :             :         //</span>
<span id="L2066"><span class="lineNum">    2066</span>                 :             :         // Receive</span>
<span id="L2067"><span class="lineNum">    2067</span>                 :             :         //</span>
<span id="L2068"><span class="lineNum">    2068</span>                 :<span class="tlaUNC">           0 :         bool recvSet = false;</span></span>
<span id="L2069"><span class="lineNum">    2069</span>                 :<span class="tlaUNC">           0 :         bool sendSet = false;</span></span>
<span id="L2070"><span class="lineNum">    2070</span>                 :<span class="tlaUNC">           0 :         bool errorSet = false;</span></span>
<span id="L2071"><span class="lineNum">    2071</span>                 :<span class="tlaUNC">           0 :         {</span></span>
<span id="L2072"><span class="lineNum">    2072</span>                 :<span class="tlaUNC">           0 :             LOCK(pnode-&gt;m_sock_mutex);</span></span>
<span id="L2073"><span class="lineNum">    2073</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!pnode-&gt;m_sock) {</span></span>
<span id="L2074"><span class="lineNum">    2074</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2075"><span class="lineNum">    2075</span>                 :             :             }</span>
<span id="L2076"><span class="lineNum">    2076</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             const auto it = events_per_sock.find(pnode-&gt;m_sock);</span></span>
<span id="L2077"><span class="lineNum">    2077</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (it != events_per_sock.end()) {</span></span>
<span id="L2078"><span class="lineNum">    2078</span>                 :<span class="tlaUNC">           0 :                 recvSet = it-&gt;second.occurred &amp; Sock::RECV;</span></span>
<span id="L2079"><span class="lineNum">    2079</span>                 :<span class="tlaUNC">           0 :                 sendSet = it-&gt;second.occurred &amp; Sock::SEND;</span></span>
<span id="L2080"><span class="lineNum">    2080</span>                 :<span class="tlaUNC">           0 :                 errorSet = it-&gt;second.occurred &amp; Sock::ERR;</span></span>
<span id="L2081"><span class="lineNum">    2081</span>                 :             :             }</span>
<span id="L2082"><span class="lineNum">    2082</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L2083"><span class="lineNum">    2083</span>                 :             : </span>
<span id="L2084"><span class="lineNum">    2084</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (sendSet) {</span></span>
<span id="L2085"><span class="lineNum">    2085</span>                 :             :             // Send data</span>
<span id="L2086"><span class="lineNum">    2086</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             auto [bytes_sent, data_left] = WITH_LOCK(pnode-&gt;cs_vSend, return SocketSendData(*pnode));</span></span>
<span id="L2087"><span class="lineNum">    2087</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (bytes_sent) {</span></span>
<span id="L2088"><span class="lineNum">    2088</span>                 :<span class="tlaUNC">           0 :                 RecordBytesSent(bytes_sent);</span></span>
<span id="L2089"><span class="lineNum">    2089</span>                 :             : </span>
<span id="L2090"><span class="lineNum">    2090</span>                 :             :                 // If both receiving and (non-optimistic) sending were possible, we first attempt</span>
<span id="L2091"><span class="lineNum">    2091</span>                 :             :                 // sending. If that succeeds, but does not fully drain the send queue, do not</span>
<span id="L2092"><span class="lineNum">    2092</span>                 :             :                 // attempt to receive. This avoids needlessly queueing data if the remote peer</span>
<span id="L2093"><span class="lineNum">    2093</span>                 :             :                 // is slow at receiving data, by means of TCP flow control. We only do this when</span>
<span id="L2094"><span class="lineNum">    2094</span>                 :             :                 // sending actually succeeded to make sure progress is always made; otherwise a</span>
<span id="L2095"><span class="lineNum">    2095</span>                 :             :                 // deadlock would be possible when both sides have data to send, but neither is</span>
<span id="L2096"><span class="lineNum">    2096</span>                 :             :                 // receiving.</span>
<span id="L2097"><span class="lineNum">    2097</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (data_left) recvSet = false;</span></span>
<span id="L2098"><span class="lineNum">    2098</span>                 :             :             }</span>
<span id="L2099"><span class="lineNum">    2099</span>                 :             :         }</span>
<span id="L2100"><span class="lineNum">    2100</span>                 :             : </span>
<span id="L2101"><span class="lineNum">    2101</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (recvSet || errorSet)</span></span>
<span id="L2102"><span class="lineNum">    2102</span>                 :             :         {</span>
<span id="L2103"><span class="lineNum">    2103</span>                 :             :             // typical socket buffer is 8K-64K</span>
<span id="L2104"><span class="lineNum">    2104</span>                 :<span class="tlaUNC">           0 :             uint8_t pchBuf[0x10000];</span></span>
<span id="L2105"><span class="lineNum">    2105</span>                 :<span class="tlaUNC">           0 :             int nBytes = 0;</span></span>
<span id="L2106"><span class="lineNum">    2106</span>                 :<span class="tlaUNC">           0 :             {</span></span>
<span id="L2107"><span class="lineNum">    2107</span>                 :<span class="tlaUNC">           0 :                 LOCK(pnode-&gt;m_sock_mutex);</span></span>
<span id="L2108"><span class="lineNum">    2108</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!pnode-&gt;m_sock) {</span></span>
<span id="L2109"><span class="lineNum">    2109</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     continue;</span></span>
<span id="L2110"><span class="lineNum">    2110</span>                 :             :                 }</span>
<span id="L2111"><span class="lineNum">    2111</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 nBytes = pnode-&gt;m_sock-&gt;Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT);</span></span>
<span id="L2112"><span class="lineNum">    2112</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L2113"><span class="lineNum">    2113</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (nBytes &gt; 0)</span></span>
<span id="L2114"><span class="lineNum">    2114</span>                 :             :             {</span>
<span id="L2115"><span class="lineNum">    2115</span>                 :<span class="tlaUNC">           0 :                 bool notify = false;</span></span>
<span id="L2116"><span class="lineNum">    2116</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!pnode-&gt;ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)) {</span></span>
<span id="L2117"><span class="lineNum">    2117</span>                 :<span class="tlaUNC">           0 :                     pnode-&gt;CloseSocketDisconnect();</span></span>
<span id="L2118"><span class="lineNum">    2118</span>                 :             :                 }</span>
<span id="L2119"><span class="lineNum">    2119</span>                 :<span class="tlaUNC">           0 :                 RecordBytesRecv(nBytes);</span></span>
<span id="L2120"><span class="lineNum">    2120</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (notify) {</span></span>
<span id="L2121"><span class="lineNum">    2121</span>                 :<span class="tlaUNC">           0 :                     pnode-&gt;MarkReceivedMsgsForProcessing();</span></span>
<span id="L2122"><span class="lineNum">    2122</span>                 :<span class="tlaUNC">           0 :                     WakeMessageHandler();</span></span>
<span id="L2123"><span class="lineNum">    2123</span>                 :             :                 }</span>
<span id="L2124"><span class="lineNum">    2124</span>                 :             :             }</span>
<span id="L2125"><span class="lineNum">    2125</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             else if (nBytes == 0)</span></span>
<span id="L2126"><span class="lineNum">    2126</span>                 :             :             {</span>
<span id="L2127"><span class="lineNum">    2127</span>                 :             :                 // socket closed gracefully</span>
<span id="L2128"><span class="lineNum">    2128</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!pnode-&gt;fDisconnect) {</span></span>
<span id="L2129"><span class="lineNum">    2129</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     LogDebug(BCLog::NET, &quot;socket closed for peer=%d\n&quot;, pnode-&gt;GetId());</span></span>
<span id="L2130"><span class="lineNum">    2130</span>                 :             :                 }</span>
<span id="L2131"><span class="lineNum">    2131</span>                 :<span class="tlaUNC">           0 :                 pnode-&gt;CloseSocketDisconnect();</span></span>
<span id="L2132"><span class="lineNum">    2132</span>                 :             :             }</span>
<span id="L2133"><span class="lineNum">    2133</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             else if (nBytes &lt; 0)</span></span>
<span id="L2134"><span class="lineNum">    2134</span>                 :             :             {</span>
<span id="L2135"><span class="lineNum">    2135</span>                 :             :                 // error</span>
<span id="L2136"><span class="lineNum">    2136</span>                 :<span class="tlaUNC">           0 :                 int nErr = WSAGetLastError();</span></span>
<span id="L2137"><span class="lineNum">    2137</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (nErr != WSAEWOULDBLOCK &amp;&amp; nErr != WSAEMSGSIZE &amp;&amp; nErr != WSAEINTR &amp;&amp; nErr != WSAEINPROGRESS)</span></span>
<span id="L2138"><span class="lineNum">    2138</span>                 :             :                 {</span>
<span id="L2139"><span class="lineNum">    2139</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     if (!pnode-&gt;fDisconnect) {</span></span>
<span id="L2140"><span class="lineNum">    2140</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         LogDebug(BCLog::NET, &quot;socket recv error for peer=%d: %s\n&quot;, pnode-&gt;GetId(), NetworkErrorString(nErr));</span></span>
<span id="L2141"><span class="lineNum">    2141</span>                 :             :                     }</span>
<span id="L2142"><span class="lineNum">    2142</span>                 :<span class="tlaUNC">           0 :                     pnode-&gt;CloseSocketDisconnect();</span></span>
<span id="L2143"><span class="lineNum">    2143</span>                 :             :                 }</span>
<span id="L2144"><span class="lineNum">    2144</span>                 :             :             }</span>
<span id="L2145"><span class="lineNum">    2145</span>                 :             :         }</span>
<span id="L2146"><span class="lineNum">    2146</span>                 :             : </span>
<span id="L2147"><span class="lineNum">    2147</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (InactivityCheck(*pnode)) pnode-&gt;fDisconnect = true;</span></span>
<span id="L2148"><span class="lineNum">    2148</span>                 :             :     }</span>
<span id="L2149"><span class="lineNum">    2149</span>                 :             : }</span>
<span id="L2150"><span class="lineNum">    2150</span>                 :             : </span>
<span id="L2151"><span class="lineNum">    2151</span>                 :<span class="tlaUNC">           0 : void CConnman::SocketHandlerListening(const Sock::EventsPerSock&amp; events_per_sock)</span></span>
<span id="L2152"><span class="lineNum">    2152</span>                 :             : {</span>
<span id="L2153"><span class="lineNum">    2153</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const ListenSocket&amp; listen_socket : vhListenSocket) {</span></span>
<span id="L2154"><span class="lineNum">    2154</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (interruptNet) {</span></span>
<span id="L2155"><span class="lineNum">    2155</span>                 :             :             return;</span>
<span id="L2156"><span class="lineNum">    2156</span>                 :             :         }</span>
<span id="L2157"><span class="lineNum">    2157</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const auto it = events_per_sock.find(listen_socket.sock);</span></span>
<span id="L2158"><span class="lineNum">    2158</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (it != events_per_sock.end() &amp;&amp; it-&gt;second.occurred &amp; Sock::RECV) {</span></span>
<span id="L2159"><span class="lineNum">    2159</span>                 :<span class="tlaUNC">           0 :             AcceptConnection(listen_socket);</span></span>
<span id="L2160"><span class="lineNum">    2160</span>                 :             :         }</span>
<span id="L2161"><span class="lineNum">    2161</span>                 :             :     }</span>
<span id="L2162"><span class="lineNum">    2162</span>                 :             : }</span>
<span id="L2163"><span class="lineNum">    2163</span>                 :             : </span>
<span id="L2164"><span class="lineNum">    2164</span>                 :<span class="tlaUNC">           0 : void CConnman::ThreadSocketHandler()</span></span>
<span id="L2165"><span class="lineNum">    2165</span>                 :             : {</span>
<span id="L2166"><span class="lineNum">    2166</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L2167"><span class="lineNum">    2167</span>                 :             : </span>
<span id="L2168"><span class="lineNum">    2168</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     while (!interruptNet)</span></span>
<span id="L2169"><span class="lineNum">    2169</span>                 :             :     {</span>
<span id="L2170"><span class="lineNum">    2170</span>                 :<span class="tlaUNC">           0 :         DisconnectNodes();</span></span>
<span id="L2171"><span class="lineNum">    2171</span>                 :<span class="tlaUNC">           0 :         NotifyNumConnectionsChanged();</span></span>
<span id="L2172"><span class="lineNum">    2172</span>                 :<span class="tlaUNC">           0 :         SocketHandler();</span></span>
<span id="L2173"><span class="lineNum">    2173</span>                 :             :     }</span>
<span id="L2174"><span class="lineNum">    2174</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2175"><span class="lineNum">    2175</span>                 :             : </span>
<span id="L2176"><span class="lineNum">    2176</span>                 :<span class="tlaGNC tlaBgGNC">           1 : void CConnman::WakeMessageHandler()</span></span>
<span id="L2177"><span class="lineNum">    2177</span>                 :             : {</span>
<span id="L2178"><span class="lineNum">    2178</span>                 :<span class="tlaGNC">           1 :     {</span></span>
<span id="L2179"><span class="lineNum">    2179</span>                 :<span class="tlaGNC">           1 :         LOCK(mutexMsgProc);</span></span>
<span id="L2180"><span class="lineNum">    2180</span>         [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           1 :         fMsgProcWake = true;</span></span>
<span id="L2181"><span class="lineNum">    2181</span>                 :<span class="tlaGNC">           1 :     }</span></span>
<span id="L2182"><span class="lineNum">    2182</span>                 :<span class="tlaGNC">           1 :     condMsgProc.notify_one();</span></span>
<span id="L2183"><span class="lineNum">    2183</span>                 :<span class="tlaGNC">           1 : }</span></span>
<span id="L2184"><span class="lineNum">    2184</span>                 :             : </span>
<span id="L2185"><span class="lineNum">    2185</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CConnman::ThreadDNSAddressSeed()</span></span>
<span id="L2186"><span class="lineNum">    2186</span>                 :             : {</span>
<span id="L2187"><span class="lineNum">    2187</span>                 :<span class="tlaUNC">           0 :     int outbound_connection_count = 0;</span></span>
<span id="L2188"><span class="lineNum">    2188</span>                 :             : </span>
<span id="L2189"><span class="lineNum">    2189</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (gArgs.IsArgSet(&quot;-seednode&quot;)) {</span></span>
<span id="L2190"><span class="lineNum">    2190</span>                 :<span class="tlaUNC">           0 :         auto start = NodeClock::now();</span></span>
<span id="L2191"><span class="lineNum">    2191</span>                 :<span class="tlaUNC">           0 :         constexpr std::chrono::seconds SEEDNODE_TIMEOUT = 30s;</span></span>
<span id="L2192"><span class="lineNum">    2192</span>                 :<span class="tlaUNC">           0 :         LogPrintf(&quot;-seednode enabled. Trying the provided seeds for %d seconds before defaulting to the dnsseeds.\n&quot;, SEEDNODE_TIMEOUT.count());</span></span>
<span id="L2193"><span class="lineNum">    2193</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         while (!interruptNet) {</span></span>
<span id="L2194"><span class="lineNum">    2194</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))</span></span>
<span id="L2195"><span class="lineNum">    2195</span>                 :             :                 return;</span>
<span id="L2196"><span class="lineNum">    2196</span>                 :             : </span>
<span id="L2197"><span class="lineNum">    2197</span>                 :             :             // Abort if we have spent enough time without reaching our target.</span>
<span id="L2198"><span class="lineNum">    2198</span>                 :             :             // Giving seed nodes 30 seconds so this does not become a race against fixedseeds (which triggers after 1 min)</span>
<span id="L2199"><span class="lineNum">    2199</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (NodeClock::now() &gt; start + SEEDNODE_TIMEOUT) {</span></span>
<span id="L2200"><span class="lineNum">    2200</span>                 :<span class="tlaUNC">           0 :                 LogPrintf(&quot;Couldn't connect to enough peers via seed nodes. Handing fetch logic to the DNS seeds.\n&quot;);</span></span>
<span id="L2201"><span class="lineNum">    2201</span>                 :<span class="tlaUNC">           0 :                 break;</span></span>
<span id="L2202"><span class="lineNum">    2202</span>                 :             :             }</span>
<span id="L2203"><span class="lineNum">    2203</span>                 :             : </span>
<span id="L2204"><span class="lineNum">    2204</span>                 :<span class="tlaUNC">           0 :             outbound_connection_count = GetFullOutboundConnCount();</span></span>
<span id="L2205"><span class="lineNum">    2205</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (outbound_connection_count &gt;= SEED_OUTBOUND_CONNECTION_THRESHOLD) {</span></span>
<span id="L2206"><span class="lineNum">    2206</span>                 :<span class="tlaUNC">           0 :                 LogPrintf(&quot;P2P peers available. Finished fetching data from seed nodes.\n&quot;);</span></span>
<span id="L2207"><span class="lineNum">    2207</span>                 :<span class="tlaUNC">           0 :                 break;</span></span>
<span id="L2208"><span class="lineNum">    2208</span>                 :             :             }</span>
<span id="L2209"><span class="lineNum">    2209</span>                 :             :         }</span>
<span id="L2210"><span class="lineNum">    2210</span>                 :             :     }</span>
<span id="L2211"><span class="lineNum">    2211</span>                 :             : </span>
<span id="L2212"><span class="lineNum">    2212</span>                 :<span class="tlaUNC">           0 :     FastRandomContext rng;</span></span>
<span id="L2213"><span class="lineNum">    2213</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::vector&lt;std::string&gt; seeds = m_params.DNSSeeds();</span></span>
<span id="L2214"><span class="lineNum">    2214</span>                 :<span class="tlaUNC">           0 :     std::shuffle(seeds.begin(), seeds.end(), rng);</span></span>
<span id="L2215"><span class="lineNum">    2215</span>                 :<span class="tlaUNC">           0 :     int seeds_right_now = 0; // Number of seeds left before testing if we have enough connections</span></span>
<span id="L2216"><span class="lineNum">    2216</span>                 :             : </span>
<span id="L2217"><span class="lineNum">    2217</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     if (gArgs.GetBoolArg(&quot;-forcednsseed&quot;, DEFAULT_FORCEDNSSEED)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2218"><span class="lineNum">    2218</span>                 :             :         // When -forcednsseed is provided, query all.</span>
<span id="L2219"><span class="lineNum">    2219</span>                 :<span class="tlaUNC">           0 :         seeds_right_now = seeds.size();</span></span>
<span id="L2220"><span class="lineNum">    2220</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     } else if (addrman.Size() == 0) {</span></span>
<span id="L2221"><span class="lineNum">    2221</span>                 :             :         // If we have no known peers, query all.</span>
<span id="L2222"><span class="lineNum">    2222</span>                 :             :         // This will occur on the first run, or if peers.dat has been</span>
<span id="L2223"><span class="lineNum">    2223</span>                 :             :         // deleted.</span>
<span id="L2224"><span class="lineNum">    2224</span>                 :<span class="tlaUNC">           0 :         seeds_right_now = seeds.size();</span></span>
<span id="L2225"><span class="lineNum">    2225</span>                 :             :     }</span>
<span id="L2226"><span class="lineNum">    2226</span>                 :             : </span>
<span id="L2227"><span class="lineNum">    2227</span>                 :             :     // Proceed with dnsseeds if seednodes hasn't reached the target or if forcednsseed is set</span>
<span id="L2228"><span class="lineNum">    2228</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (outbound_connection_count &lt; SEED_OUTBOUND_CONNECTION_THRESHOLD || seeds_right_now) {</span></span>
<span id="L2229"><span class="lineNum">    2229</span>                 :             :         // goal: only query DNS seed if address need is acute</span>
<span id="L2230"><span class="lineNum">    2230</span>                 :             :         // * If we have a reasonable number of peers in addrman, spend</span>
<span id="L2231"><span class="lineNum">    2231</span>                 :             :         //   some time trying them first. This improves user privacy by</span>
<span id="L2232"><span class="lineNum">    2232</span>                 :             :         //   creating fewer identifying DNS requests, reduces trust by</span>
<span id="L2233"><span class="lineNum">    2233</span>                 :             :         //   giving seeds less influence on the network topology, and</span>
<span id="L2234"><span class="lineNum">    2234</span>                 :             :         //   reduces traffic to the seeds.</span>
<span id="L2235"><span class="lineNum">    2235</span>                 :             :         // * When querying DNS seeds query a few at once, this ensures</span>
<span id="L2236"><span class="lineNum">    2236</span>                 :             :         //   that we don't give DNS seeds the ability to eclipse nodes</span>
<span id="L2237"><span class="lineNum">    2237</span>                 :             :         //   that query them.</span>
<span id="L2238"><span class="lineNum">    2238</span>                 :             :         // * If we continue having problems, eventually query all the</span>
<span id="L2239"><span class="lineNum">    2239</span>                 :             :         //   DNS seeds, and if that fails too, also try the fixed seeds.</span>
<span id="L2240"><span class="lineNum">    2240</span>                 :             :         //   (done in ThreadOpenConnections)</span>
<span id="L2241"><span class="lineNum">    2241</span>                 :<span class="tlaUNC">           0 :         int found = 0;</span></span>
<span id="L2242"><span class="lineNum">    2242</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const std::chrono::seconds seeds_wait_time = (addrman.Size() &gt;= DNSSEEDS_DELAY_PEER_THRESHOLD ? DNSSEEDS_DELAY_MANY_PEERS : DNSSEEDS_DELAY_FEW_PEERS);</span></span>
<span id="L2243"><span class="lineNum">    2243</span>                 :             : </span>
<span id="L2244"><span class="lineNum">    2244</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (const std::string&amp; seed : seeds) {</span></span>
<span id="L2245"><span class="lineNum">    2245</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (seeds_right_now == 0) {</span></span>
<span id="L2246"><span class="lineNum">    2246</span>                 :<span class="tlaUNC">           0 :                 seeds_right_now += DNSSEEDS_TO_QUERY_AT_ONCE;</span></span>
<span id="L2247"><span class="lineNum">    2247</span>                 :             : </span>
<span id="L2248"><span class="lineNum">    2248</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (addrman.Size() &gt; 0) {</span></span>
<span id="L2249"><span class="lineNum">    2249</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     LogPrintf(&quot;Waiting %d seconds before querying DNS seeds.\n&quot;, seeds_wait_time.count());</span></span>
<span id="L2250"><span class="lineNum">    2250</span>                 :<span class="tlaUNC">           0 :                     std::chrono::seconds to_wait = seeds_wait_time;</span></span>
<span id="L2251"><span class="lineNum">    2251</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     while (to_wait.count() &gt; 0) {</span></span>
<span id="L2252"><span class="lineNum">    2252</span>                 :             :                         // if sleeping for the MANY_PEERS interval, wake up</span>
<span id="L2253"><span class="lineNum">    2253</span>                 :             :                         // early to see if we have enough peers and can stop</span>
<span id="L2254"><span class="lineNum">    2254</span>                 :             :                         // this thread entirely freeing up its resources</span>
<span id="L2255"><span class="lineNum">    2255</span>                 :<span class="tlaUNC">           0 :                         std::chrono::seconds w = std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait);</span></span>
<span id="L2256"><span class="lineNum">    2256</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         if (!interruptNet.sleep_for(w)) return;</span></span>
<span id="L2257"><span class="lineNum">    2257</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         to_wait -= w;</span></span>
<span id="L2258"><span class="lineNum">    2258</span>                 :             : </span>
<span id="L2259"><span class="lineNum">    2259</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         if (GetFullOutboundConnCount() &gt;= SEED_OUTBOUND_CONNECTION_THRESHOLD) {</span></span>
<span id="L2260"><span class="lineNum">    2260</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                             if (found &gt; 0) {</span></span>
<span id="L2261"><span class="lineNum">    2261</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                 LogPrintf(&quot;%d addresses found from DNS seeds\n&quot;, found);</span></span>
<span id="L2262"><span class="lineNum">    2262</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                 LogPrintf(&quot;P2P peers available. Finished DNS seeding.\n&quot;);</span></span>
<span id="L2263"><span class="lineNum">    2263</span>                 :             :                             } else {</span>
<span id="L2264"><span class="lineNum">    2264</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                 LogPrintf(&quot;P2P peers available. Skipped DNS seeding.\n&quot;);</span></span>
<span id="L2265"><span class="lineNum">    2265</span>                 :             :                             }</span>
<span id="L2266"><span class="lineNum">    2266</span>                 :<span class="tlaUNC">           0 :                             return;</span></span>
<span id="L2267"><span class="lineNum">    2267</span>                 :             :                         }</span>
<span id="L2268"><span class="lineNum">    2268</span>                 :             :                     }</span>
<span id="L2269"><span class="lineNum">    2269</span>                 :             :                 }</span>
<span id="L2270"><span class="lineNum">    2270</span>                 :             :             }</span>
<span id="L2271"><span class="lineNum">    2271</span>                 :             : </span>
<span id="L2272"><span class="lineNum">    2272</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (interruptNet) return;</span></span>
<span id="L2273"><span class="lineNum">    2273</span>                 :             : </span>
<span id="L2274"><span class="lineNum">    2274</span>                 :             :             // hold off on querying seeds if P2P network deactivated</span>
<span id="L2275"><span class="lineNum">    2275</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!fNetworkActive) {</span></span>
<span id="L2276"><span class="lineNum">    2276</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 LogPrintf(&quot;Waiting for network to be reactivated before querying DNS seeds.\n&quot;);</span></span>
<span id="L2277"><span class="lineNum">    2277</span>                 :<span class="tlaUNC">           0 :                 do {</span></span>
<span id="L2278"><span class="lineNum">    2278</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     if (!interruptNet.sleep_for(std::chrono::seconds{1})) return;</span></span>
<span id="L2279"><span class="lineNum">    2279</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 } while (!fNetworkActive);</span></span>
<span id="L2280"><span class="lineNum">    2280</span>                 :             :             }</span>
<span id="L2281"><span class="lineNum">    2281</span>                 :             : </span>
<span id="L2282"><span class="lineNum">    2282</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogPrintf(&quot;Loading addresses from DNS seed %s\n&quot;, seed);</span></span>
<span id="L2283"><span class="lineNum">    2283</span>                 :             :             // If -proxy is in use, we make an ADDR_FETCH connection to the DNS resolved peer address</span>
<span id="L2284"><span class="lineNum">    2284</span>                 :             :             // for the base dns seed domain in chainparams</span>
<span id="L2285"><span class="lineNum">    2285</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (HaveNameProxy()) {</span></span>
<span id="L2286"><span class="lineNum">    2286</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 AddAddrFetch(seed);</span></span>
<span id="L2287"><span class="lineNum">    2287</span>                 :             :             } else {</span>
<span id="L2288"><span class="lineNum">    2288</span>                 :<span class="tlaUNC">           0 :                 std::vector&lt;CAddress&gt; vAdd;</span></span>
<span id="L2289"><span class="lineNum">    2289</span>                 :<span class="tlaUNC">           0 :                 constexpr ServiceFlags requiredServiceBits{SeedsServiceFlags()};</span></span>
<span id="L2290"><span class="lineNum">    2290</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 std::string host = strprintf(&quot;x%x.%s&quot;, requiredServiceBits, seed);</span></span>
<span id="L2291"><span class="lineNum">    2291</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 CNetAddr resolveSource;</span></span>
<span id="L2292"><span class="lineNum">    2292</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!resolveSource.SetInternal(host)) {</span></span>
<span id="L2293"><span class="lineNum">    2293</span>                 :<span class="tlaUNC">           0 :                     continue;</span></span>
<span id="L2294"><span class="lineNum">    2294</span>                 :             :                 }</span>
<span id="L2295"><span class="lineNum">    2295</span>                 :             :                 // Limit number of IPs learned from a single DNS seed. This limit exists to prevent the results from</span>
<span id="L2296"><span class="lineNum">    2296</span>                 :             :                 // one DNS seed from dominating AddrMan. Note that the number of results from a UDP DNS query is</span>
<span id="L2297"><span class="lineNum">    2297</span>                 :             :                 // bounded to 33 already, but it is possible for it to use TCP where a larger number of results can be</span>
<span id="L2298"><span class="lineNum">    2298</span>                 :             :                 // returned.</span>
<span id="L2299"><span class="lineNum">    2299</span>                 :<span class="tlaUNC">           0 :                 unsigned int nMaxIPs = 32;</span></span>
<span id="L2300"><span class="lineNum">    2300</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 const auto addresses{LookupHost(host, nMaxIPs, true)};</span></span>
<span id="L2301"><span class="lineNum">    2301</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!addresses.empty()) {</span></span>
<span id="L2302"><span class="lineNum">    2302</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     for (const CNetAddr&amp; ip : addresses) {</span></span>
<span id="L2303"><span class="lineNum">    2303</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         CAddress addr = CAddress(CService(ip, m_params.GetDefaultPort()), requiredServiceBits);</span></span>
<span id="L2304"><span class="lineNum">    2304</span>                 :<span class="tlaUNC">           0 :                         addr.nTime = rng.rand_uniform_delay(Now&lt;NodeSeconds&gt;() - 3 * 24h, -4 * 24h); // use a random age between 3 and 7 days old</span></span>
<span id="L2305"><span class="lineNum">    2305</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         vAdd.push_back(addr);</span></span>
<span id="L2306"><span class="lineNum">    2306</span>                 :<span class="tlaUNC">           0 :                         found++;</span></span>
<span id="L2307"><span class="lineNum">    2307</span>                 :<span class="tlaUNC">           0 :                     }</span></span>
<span id="L2308"><span class="lineNum">    2308</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     addrman.Add(vAdd, resolveSource);</span></span>
<span id="L2309"><span class="lineNum">    2309</span>                 :             :                 } else {</span>
<span id="L2310"><span class="lineNum">    2310</span>                 :             :                     // If the seed does not support a subdomain with our desired service bits,</span>
<span id="L2311"><span class="lineNum">    2311</span>                 :             :                     // we make an ADDR_FETCH connection to the DNS resolved peer address for the</span>
<span id="L2312"><span class="lineNum">    2312</span>                 :             :                     // base dns seed domain in chainparams</span>
<span id="L2313"><span class="lineNum">    2313</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     AddAddrFetch(seed);</span></span>
<span id="L2314"><span class="lineNum">    2314</span>                 :             :                 }</span>
<span id="L2315"><span class="lineNum">    2315</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L2316"><span class="lineNum">    2316</span>                 :<span class="tlaUNC">           0 :             --seeds_right_now;</span></span>
<span id="L2317"><span class="lineNum">    2317</span>                 :             :         }</span>
<span id="L2318"><span class="lineNum">    2318</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;%d addresses found from DNS seeds\n&quot;, found);</span></span>
<span id="L2319"><span class="lineNum">    2319</span>                 :             :     } else {</span>
<span id="L2320"><span class="lineNum">    2320</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;Skipping DNS seeds. Enough peers have been found\n&quot;);</span></span>
<span id="L2321"><span class="lineNum">    2321</span>                 :             :     }</span>
<span id="L2322"><span class="lineNum">    2322</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2323"><span class="lineNum">    2323</span>                 :             : </span>
<span id="L2324"><span class="lineNum">    2324</span>                 :<span class="tlaUNC">           0 : void CConnman::DumpAddresses()</span></span>
<span id="L2325"><span class="lineNum">    2325</span>                 :             : {</span>
<span id="L2326"><span class="lineNum">    2326</span>                 :<span class="tlaUNC">           0 :     const auto start{SteadyClock::now()};</span></span>
<span id="L2327"><span class="lineNum">    2327</span>                 :             : </span>
<span id="L2328"><span class="lineNum">    2328</span>                 :<span class="tlaUNC">           0 :     DumpPeerAddresses(::gArgs, addrman);</span></span>
<span id="L2329"><span class="lineNum">    2329</span>                 :             : </span>
<span id="L2330"><span class="lineNum">    2330</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     LogDebug(BCLog::NET, &quot;Flushed %d addresses to peers.dat  %dms\n&quot;,</span></span>
<span id="L2331"><span class="lineNum">    2331</span>                 :             :              addrman.Size(), Ticks&lt;std::chrono::milliseconds&gt;(SteadyClock::now() - start));</span>
<span id="L2332"><span class="lineNum">    2332</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2333"><span class="lineNum">    2333</span>                 :             : </span>
<span id="L2334"><span class="lineNum">    2334</span>                 :<span class="tlaUNC">           0 : void CConnman::ProcessAddrFetch()</span></span>
<span id="L2335"><span class="lineNum">    2335</span>                 :             : {</span>
<span id="L2336"><span class="lineNum">    2336</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L2337"><span class="lineNum">    2337</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::string strDest;</span></span>
<span id="L2338"><span class="lineNum">    2338</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L2339"><span class="lineNum">    2339</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LOCK(m_addr_fetches_mutex);</span></span>
<span id="L2340"><span class="lineNum">    2340</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (m_addr_fetches.empty())</span></span>
<span id="L2341"><span class="lineNum">    2341</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             return;</span></span>
<span id="L2342"><span class="lineNum">    2342</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         strDest = m_addr_fetches.front();</span></span>
<span id="L2343"><span class="lineNum">    2343</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         m_addr_fetches.pop_front();</span></span>
<span id="L2344"><span class="lineNum">    2344</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2345"><span class="lineNum">    2345</span>                 :             :     // Attempt v2 connection if we support v2 - we'll reconnect with v1 if our</span>
<span id="L2346"><span class="lineNum">    2346</span>                 :             :     // peer doesn't support it or immediately disconnects us for another reason.</span>
<span id="L2347"><span class="lineNum">    2347</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const bool use_v2transport(GetLocalServices() &amp; NODE_P2P_V2);</span></span>
<span id="L2348"><span class="lineNum">    2348</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     CAddress addr;</span></span>
<span id="L2349"><span class="lineNum">    2349</span>                 :<span class="tlaUNC">           0 :     CSemaphoreGrant grant(*semOutbound, /*fTry=*/true);</span></span>
<span id="L2350"><span class="lineNum">    2350</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (grant) {</span></span>
<span id="L2351"><span class="lineNum">    2351</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         OpenNetworkConnection(addr, false, std::move(grant), strDest.c_str(), ConnectionType::ADDR_FETCH, use_v2transport);</span></span>
<span id="L2352"><span class="lineNum">    2352</span>                 :             :     }</span>
<span id="L2353"><span class="lineNum">    2353</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2354"><span class="lineNum">    2354</span>                 :             : </span>
<span id="L2355"><span class="lineNum">    2355</span>                 :<span class="tlaGNC tlaBgGNC">           3 : bool CConnman::GetTryNewOutboundPeer() const</span></span>
<span id="L2356"><span class="lineNum">    2356</span>                 :             : {</span>
<span id="L2357"><span class="lineNum">    2357</span>                 :<span class="tlaGNC">           3 :     return m_try_another_outbound_peer;</span></span>
<span id="L2358"><span class="lineNum">    2358</span>                 :             : }</span>
<span id="L2359"><span class="lineNum">    2359</span>                 :             : </span>
<span id="L2360"><span class="lineNum">    2360</span>                 :<span class="tlaGNC">         173 : void CConnman::SetTryNewOutboundPeer(bool flag)</span></span>
<span id="L2361"><span class="lineNum">    2361</span>                 :             : {</span>
<span id="L2362"><span class="lineNum">    2362</span>                 :<span class="tlaGNC">         173 :     m_try_another_outbound_peer = flag;</span></span>
<span id="L2363"><span class="lineNum">    2363</span>   [<span class="tlaGBC" title="Branch 0 was taken 173 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 172 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 1 time"> + </span>]:<span class="tlaGNC">         345 :     LogDebug(BCLog::NET, &quot;setting try another outbound peer=%s\n&quot;, flag ? &quot;true&quot; : &quot;false&quot;);</span></span>
<span id="L2364"><span class="lineNum">    2364</span>                 :<span class="tlaGNC">         173 : }</span></span>
<span id="L2365"><span class="lineNum">    2365</span>                 :             : </span>
<span id="L2366"><span class="lineNum">    2366</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CConnman::StartExtraBlockRelayPeers()</span></span>
<span id="L2367"><span class="lineNum">    2367</span>                 :             : {</span>
<span id="L2368"><span class="lineNum">    2368</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     LogDebug(BCLog::NET, &quot;enabling extra block-relay-only peers\n&quot;);</span></span>
<span id="L2369"><span class="lineNum">    2369</span>                 :<span class="tlaUNC">           0 :     m_start_extra_block_relay_peers = true;</span></span>
<span id="L2370"><span class="lineNum">    2370</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2371"><span class="lineNum">    2371</span>                 :             : </span>
<span id="L2372"><span class="lineNum">    2372</span>                 :             : // Return the number of outbound connections that are full relay (not blocks only)</span>
<span id="L2373"><span class="lineNum">    2373</span>                 :<span class="tlaUNC">           0 : int CConnman::GetFullOutboundConnCount() const</span></span>
<span id="L2374"><span class="lineNum">    2374</span>                 :             : {</span>
<span id="L2375"><span class="lineNum">    2375</span>                 :<span class="tlaUNC">           0 :     int nRelevant = 0;</span></span>
<span id="L2376"><span class="lineNum">    2376</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L2377"><span class="lineNum">    2377</span>                 :<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L2378"><span class="lineNum">    2378</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (const CNode* pnode : m_nodes) {</span></span>
<span id="L2379"><span class="lineNum">    2379</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (pnode-&gt;fSuccessfullyConnected &amp;&amp; pnode-&gt;IsFullOutboundConn()) ++nRelevant;</span></span>
<span id="L2380"><span class="lineNum">    2380</span>                 :             :         }</span>
<span id="L2381"><span class="lineNum">    2381</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2382"><span class="lineNum">    2382</span>                 :<span class="tlaUNC">           0 :     return nRelevant;</span></span>
<span id="L2383"><span class="lineNum">    2383</span>                 :             : }</span>
<span id="L2384"><span class="lineNum">    2384</span>                 :             : </span>
<span id="L2385"><span class="lineNum">    2385</span>                 :             : // Return the number of peers we have over our outbound connection limit</span>
<span id="L2386"><span class="lineNum">    2386</span>                 :             : // Exclude peers that are marked for disconnect, or are going to be</span>
<span id="L2387"><span class="lineNum">    2387</span>                 :             : // disconnected soon (eg ADDR_FETCH and FEELER)</span>
<span id="L2388"><span class="lineNum">    2388</span>                 :             : // Also exclude peers that haven't finished initial connection handshake yet</span>
<span id="L2389"><span class="lineNum">    2389</span>                 :             : // (so that we don't decide we're over our desired connection limit, and then</span>
<span id="L2390"><span class="lineNum">    2390</span>                 :             : // evict some peer that has finished the handshake)</span>
<span id="L2391"><span class="lineNum">    2391</span>                 :<span class="tlaGNC tlaBgGNC">          10 : int CConnman::GetExtraFullOutboundCount() const</span></span>
<span id="L2392"><span class="lineNum">    2392</span>                 :             : {</span>
<span id="L2393"><span class="lineNum">    2393</span>                 :<span class="tlaGNC">          10 :     int full_outbound_peers = 0;</span></span>
<span id="L2394"><span class="lineNum">    2394</span>                 :<span class="tlaGNC">          10 :     {</span></span>
<span id="L2395"><span class="lineNum">    2395</span>                 :<span class="tlaGNC">          10 :         LOCK(m_nodes_mutex);</span></span>
<span id="L2396"><span class="lineNum">    2396</span>         [<span class="tlaGBC" title="Branch 0 was taken 66 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC">          76 :         for (const CNode* pnode : m_nodes) {</span></span>
<span id="L2397"><span class="lineNum">    2397</span>   [<span class="tlaGBC" title="Branch 0 was taken 66 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 63 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 3 times"> + </span> :<span class="tlaGNC">          66 :             if (pnode-&gt;fSuccessfullyConnected &amp;&amp; !pnode-&gt;fDisconnect &amp;&amp; pnode-&gt;IsFullOutboundConn()) {</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 54 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 9 times"> + </span>]
<span id="L2398"><span class="lineNum">    2398</span>                 :<span class="tlaGNC">          54 :                 ++full_outbound_peers;</span></span>
<span id="L2399"><span class="lineNum">    2399</span>                 :             :             }</span>
<span id="L2400"><span class="lineNum">    2400</span>                 :             :         }</span>
<span id="L2401"><span class="lineNum">    2401</span>                 :<span class="tlaGNC">          10 :     }</span></span>
<span id="L2402"><span class="lineNum">    2402</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 4 times"> + </span>]:<span class="tlaGNC">          10 :     return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);</span></span>
<span id="L2403"><span class="lineNum">    2403</span>                 :             : }</span>
<span id="L2404"><span class="lineNum">    2404</span>                 :             : </span>
<span id="L2405"><span class="lineNum">    2405</span>                 :<span class="tlaGNC">          10 : int CConnman::GetExtraBlockRelayCount() const</span></span>
<span id="L2406"><span class="lineNum">    2406</span>                 :             : {</span>
<span id="L2407"><span class="lineNum">    2407</span>                 :<span class="tlaGNC">          10 :     int block_relay_peers = 0;</span></span>
<span id="L2408"><span class="lineNum">    2408</span>                 :<span class="tlaGNC">          10 :     {</span></span>
<span id="L2409"><span class="lineNum">    2409</span>                 :<span class="tlaGNC">          10 :         LOCK(m_nodes_mutex);</span></span>
<span id="L2410"><span class="lineNum">    2410</span>         [<span class="tlaGBC" title="Branch 0 was taken 66 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC">          76 :         for (const CNode* pnode : m_nodes) {</span></span>
<span id="L2411"><span class="lineNum">    2411</span>   [<span class="tlaGBC" title="Branch 0 was taken 66 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 65 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 1 time"> + </span> :<span class="tlaGNC">          66 :             if (pnode-&gt;fSuccessfullyConnected &amp;&amp; !pnode-&gt;fDisconnect &amp;&amp; pnode-&gt;IsBlockOnlyConn()) {</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 11 times"> + </span><span class="tlaGBC" title="Branch 5 was taken 54 times"> + </span>]
<span id="L2412"><span class="lineNum">    2412</span>                 :<span class="tlaGNC">          11 :                 ++block_relay_peers;</span></span>
<span id="L2413"><span class="lineNum">    2413</span>                 :             :             }</span>
<span id="L2414"><span class="lineNum">    2414</span>                 :             :         }</span>
<span id="L2415"><span class="lineNum">    2415</span>                 :<span class="tlaGNC">          10 :     }</span></span>
<span id="L2416"><span class="lineNum">    2416</span>         [<span class="tlaGBC" title="Branch 0 was taken 4 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">          10 :     return std::max(block_relay_peers - m_max_outbound_block_relay, 0);</span></span>
<span id="L2417"><span class="lineNum">    2417</span>                 :             : }</span>
<span id="L2418"><span class="lineNum">    2418</span>                 :             : </span>
<span id="L2419"><span class="lineNum">    2419</span>                 :<span class="tlaUNC tlaBgUNC">           0 : std::unordered_set&lt;Network&gt; CConnman::GetReachableEmptyNetworks() const</span></span>
<span id="L2420"><span class="lineNum">    2420</span>                 :             : {</span>
<span id="L2421"><span class="lineNum">    2421</span>                 :<span class="tlaUNC">           0 :     std::unordered_set&lt;Network&gt; networks{};</span></span>
<span id="L2422"><span class="lineNum">    2422</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (int n = 0; n &lt; NET_MAX; n++) {</span></span>
<span id="L2423"><span class="lineNum">    2423</span>                 :<span class="tlaUNC">           0 :         enum Network net = (enum Network)n;</span></span>
<span id="L2424"><span class="lineNum">    2424</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (net == NET_UNROUTABLE || net == NET_INTERNAL) continue;</span></span>
<span id="L2425"><span class="lineNum">    2425</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         if (g_reachable_nets.Contains(net) &amp;&amp; addrman.Size(net, std::nullopt) == 0) {</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L2426"><span class="lineNum">    2426</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             networks.insert(net);</span></span>
<span id="L2427"><span class="lineNum">    2427</span>                 :             :         }</span>
<span id="L2428"><span class="lineNum">    2428</span>                 :             :     }</span>
<span id="L2429"><span class="lineNum">    2429</span>                 :<span class="tlaUNC">           0 :     return networks;</span></span>
<span id="L2430"><span class="lineNum">    2430</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2431"><span class="lineNum">    2431</span>                 :             : </span>
<span id="L2432"><span class="lineNum">    2432</span>                 :<span class="tlaGNC tlaBgGNC">          38 : bool CConnman::MultipleManualOrFullOutboundConns(Network net) const</span></span>
<span id="L2433"><span class="lineNum">    2433</span>                 :             : {</span>
<span id="L2434"><span class="lineNum">    2434</span>                 :<span class="tlaGNC">          38 :     AssertLockHeld(m_nodes_mutex);</span></span>
<span id="L2435"><span class="lineNum">    2435</span>                 :<span class="tlaGNC">          38 :     return m_network_conn_counts[net] &gt; 1;</span></span>
<span id="L2436"><span class="lineNum">    2436</span>                 :             : }</span>
<span id="L2437"><span class="lineNum">    2437</span>                 :             : </span>
<span id="L2438"><span class="lineNum">    2438</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::MaybePickPreferredNetwork(std::optional&lt;Network&gt;&amp; network)</span></span>
<span id="L2439"><span class="lineNum">    2439</span>                 :             : {</span>
<span id="L2440"><span class="lineNum">    2440</span>                 :<span class="tlaUNC">           0 :     std::array&lt;Network, 5&gt; nets{NET_IPV4, NET_IPV6, NET_ONION, NET_I2P, NET_CJDNS};</span></span>
<span id="L2441"><span class="lineNum">    2441</span>                 :<span class="tlaUNC">           0 :     std::shuffle(nets.begin(), nets.end(), FastRandomContext());</span></span>
<span id="L2442"><span class="lineNum">    2442</span>                 :             : </span>
<span id="L2443"><span class="lineNum">    2443</span>                 :<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L2444"><span class="lineNum">    2444</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const auto net : nets) {</span></span>
<span id="L2445"><span class="lineNum">    2445</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         if (g_reachable_nets.Contains(net) &amp;&amp; m_network_conn_counts[net] == 0 &amp;&amp; addrman.Size(net) != 0) {</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L2446"><span class="lineNum">    2446</span>                 :<span class="tlaUNC">           0 :             network = net;</span></span>
<span id="L2447"><span class="lineNum">    2447</span>                 :<span class="tlaUNC">           0 :             return true;</span></span>
<span id="L2448"><span class="lineNum">    2448</span>                 :             :         }</span>
<span id="L2449"><span class="lineNum">    2449</span>                 :             :     }</span>
<span id="L2450"><span class="lineNum">    2450</span>                 :             : </span>
<span id="L2451"><span class="lineNum">    2451</span>                 :             :     return false;</span>
<span id="L2452"><span class="lineNum">    2452</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2453"><span class="lineNum">    2453</span>                 :             : </span>
<span id="L2454"><span class="lineNum">    2454</span>                 :<span class="tlaUNC">           0 : void CConnman::ThreadOpenConnections(const std::vector&lt;std::string&gt; connect, Span&lt;const std::string&gt; seed_nodes)</span></span>
<span id="L2455"><span class="lineNum">    2455</span>                 :             : {</span>
<span id="L2456"><span class="lineNum">    2456</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L2457"><span class="lineNum">    2457</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_reconnections_mutex);</span></span>
<span id="L2458"><span class="lineNum">    2458</span>                 :<span class="tlaUNC">           0 :     FastRandomContext rng;</span></span>
<span id="L2459"><span class="lineNum">    2459</span>                 :             :     // Connect to specific addresses</span>
<span id="L2460"><span class="lineNum">    2460</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!connect.empty())</span></span>
<span id="L2461"><span class="lineNum">    2461</span>                 :             :     {</span>
<span id="L2462"><span class="lineNum">    2462</span>                 :             :         // Attempt v2 connection if we support v2 - we'll reconnect with v1 if our</span>
<span id="L2463"><span class="lineNum">    2463</span>                 :             :         // peer doesn't support it or immediately disconnects us for another reason.</span>
<span id="L2464"><span class="lineNum">    2464</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const bool use_v2transport(GetLocalServices() &amp; NODE_P2P_V2);</span></span>
<span id="L2465"><span class="lineNum">    2465</span>                 :<span class="tlaUNC">           0 :         for (int64_t nLoop = 0;; nLoop++)</span></span>
<span id="L2466"><span class="lineNum">    2466</span>                 :             :         {</span>
<span id="L2467"><span class="lineNum">    2467</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (const std::string&amp; strAddr : connect)</span></span>
<span id="L2468"><span class="lineNum">    2468</span>                 :             :             {</span>
<span id="L2469"><span class="lineNum">    2469</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 CAddress addr(CService(), NODE_NONE);</span></span>
<span id="L2470"><span class="lineNum">    2470</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 OpenNetworkConnection(addr, false, {}, strAddr.c_str(), ConnectionType::MANUAL, /*use_v2transport=*/use_v2transport);</span></span>
<span id="L2471"><span class="lineNum">    2471</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 for (int i = 0; i &lt; 10 &amp;&amp; i &lt; nLoop; i++)</span></span>
<span id="L2472"><span class="lineNum">    2472</span>                 :             :                 {</span>
<span id="L2473"><span class="lineNum">    2473</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))</span></span>
<span id="L2474"><span class="lineNum">    2474</span>                 :<span class="tlaUNC">           0 :                         return;</span></span>
<span id="L2475"><span class="lineNum">    2475</span>                 :             :                 }</span>
<span id="L2476"><span class="lineNum">    2476</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L2477"><span class="lineNum">    2477</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))</span></span>
<span id="L2478"><span class="lineNum">    2478</span>                 :             :                 return;</span>
<span id="L2479"><span class="lineNum">    2479</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             PerformReconnections();</span></span>
<span id="L2480"><span class="lineNum">    2480</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L2481"><span class="lineNum">    2481</span>                 :             :     }</span>
<span id="L2482"><span class="lineNum">    2482</span>                 :             : </span>
<span id="L2483"><span class="lineNum">    2483</span>                 :             :     // Initiate network connections</span>
<span id="L2484"><span class="lineNum">    2484</span>                 :<span class="tlaUNC">           0 :     auto start = GetTime&lt;std::chrono::microseconds&gt;();</span></span>
<span id="L2485"><span class="lineNum">    2485</span>                 :             : </span>
<span id="L2486"><span class="lineNum">    2486</span>                 :             :     // Minimum time before next feeler connection (in microseconds).</span>
<span id="L2487"><span class="lineNum">    2487</span>                 :<span class="tlaUNC">           0 :     auto next_feeler = start + rng.rand_exp_duration(FEELER_INTERVAL);</span></span>
<span id="L2488"><span class="lineNum">    2488</span>                 :<span class="tlaUNC">           0 :     auto next_extra_block_relay = start + rng.rand_exp_duration(EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);</span></span>
<span id="L2489"><span class="lineNum">    2489</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     auto next_extra_network_peer{start + rng.rand_exp_duration(EXTRA_NETWORK_PEER_INTERVAL)};</span></span>
<span id="L2490"><span class="lineNum">    2490</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const bool dnsseed = gArgs.GetBoolArg(&quot;-dnsseed&quot;, DEFAULT_DNSSEED);</span></span>
<span id="L2491"><span class="lineNum">    2491</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     bool add_fixed_seeds = gArgs.GetBoolArg(&quot;-fixedseeds&quot;, DEFAULT_FIXEDSEEDS);</span></span>
<span id="L2492"><span class="lineNum">    2492</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const bool use_seednodes{gArgs.IsArgSet(&quot;-seednode&quot;)};</span></span>
<span id="L2493"><span class="lineNum">    2493</span>                 :             : </span>
<span id="L2494"><span class="lineNum">    2494</span>                 :<span class="tlaUNC">           0 :     auto seed_node_timer = NodeClock::now();</span></span>
<span id="L2495"><span class="lineNum">    2495</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     bool add_addr_fetch{addrman.Size() == 0 &amp;&amp; !seed_nodes.empty()};</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2496"><span class="lineNum">    2496</span>                 :<span class="tlaUNC">           0 :     constexpr std::chrono::seconds ADD_NEXT_SEEDNODE = 10s;</span></span>
<span id="L2497"><span class="lineNum">    2497</span>                 :             : </span>
<span id="L2498"><span class="lineNum">    2498</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!add_fixed_seeds) {</span></span>
<span id="L2499"><span class="lineNum">    2499</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;Fixed seeds are disabled\n&quot;);</span></span>
<span id="L2500"><span class="lineNum">    2500</span>                 :             :     }</span>
<span id="L2501"><span class="lineNum">    2501</span>                 :             : </span>
<span id="L2502"><span class="lineNum">    2502</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     while (!interruptNet)</span></span>
<span id="L2503"><span class="lineNum">    2503</span>                 :             :     {</span>
<span id="L2504"><span class="lineNum">    2504</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (add_addr_fetch) {</span></span>
<span id="L2505"><span class="lineNum">    2505</span>                 :<span class="tlaUNC">           0 :             add_addr_fetch = false;</span></span>
<span id="L2506"><span class="lineNum">    2506</span>                 :<span class="tlaUNC">           0 :             const auto&amp; seed{SpanPopBack(seed_nodes)};</span></span>
<span id="L2507"><span class="lineNum">    2507</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             AddAddrFetch(seed);</span></span>
<span id="L2508"><span class="lineNum">    2508</span>                 :             : </span>
<span id="L2509"><span class="lineNum">    2509</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (addrman.Size() == 0) {</span></span>
<span id="L2510"><span class="lineNum">    2510</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 LogInfo(&quot;Empty addrman, adding seednode (%s) to addrfetch\n&quot;, seed);</span></span>
<span id="L2511"><span class="lineNum">    2511</span>                 :             :             } else {</span>
<span id="L2512"><span class="lineNum">    2512</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 LogInfo(&quot;Couldn't connect to peers from addrman after %d seconds. Adding seednode (%s) to addrfetch\n&quot;, ADD_NEXT_SEEDNODE.count(), seed);</span></span>
<span id="L2513"><span class="lineNum">    2513</span>                 :             :             }</span>
<span id="L2514"><span class="lineNum">    2514</span>                 :             :         }</span>
<span id="L2515"><span class="lineNum">    2515</span>                 :             : </span>
<span id="L2516"><span class="lineNum">    2516</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         ProcessAddrFetch();</span></span>
<span id="L2517"><span class="lineNum">    2517</span>                 :             : </span>
<span id="L2518"><span class="lineNum">    2518</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))</span></span>
<span id="L2519"><span class="lineNum">    2519</span>                 :             :             return;</span>
<span id="L2520"><span class="lineNum">    2520</span>                 :             : </span>
<span id="L2521"><span class="lineNum">    2521</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         PerformReconnections();</span></span>
<span id="L2522"><span class="lineNum">    2522</span>                 :             : </span>
<span id="L2523"><span class="lineNum">    2523</span>                 :<span class="tlaUNC">           0 :         CSemaphoreGrant grant(*semOutbound);</span></span>
<span id="L2524"><span class="lineNum">    2524</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (interruptNet)</span></span>
<span id="L2525"><span class="lineNum">    2525</span>                 :             :             return;</span>
<span id="L2526"><span class="lineNum">    2526</span>                 :             : </span>
<span id="L2527"><span class="lineNum">    2527</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const std::unordered_set&lt;Network&gt; fixed_seed_networks{GetReachableEmptyNetworks()};</span></span>
<span id="L2528"><span class="lineNum">    2528</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (add_fixed_seeds &amp;&amp; !fixed_seed_networks.empty()) {</span></span>
<span id="L2529"><span class="lineNum">    2529</span>                 :             :             // When the node starts with an empty peers.dat, there are a few other sources of peers before</span>
<span id="L2530"><span class="lineNum">    2530</span>                 :             :             // we fallback on to fixed seeds: -dnsseed, -seednode, -addnode</span>
<span id="L2531"><span class="lineNum">    2531</span>                 :             :             // If none of those are available, we fallback on to fixed seeds immediately, else we allow</span>
<span id="L2532"><span class="lineNum">    2532</span>                 :             :             // 60 seconds for any of those sources to populate addrman.</span>
<span id="L2533"><span class="lineNum">    2533</span>                 :<span class="tlaUNC">           0 :             bool add_fixed_seeds_now = false;</span></span>
<span id="L2534"><span class="lineNum">    2534</span>                 :             :             // It is cheapest to check if enough time has passed first.</span>
<span id="L2535"><span class="lineNum">    2535</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (GetTime&lt;std::chrono::seconds&gt;() &gt; start + std::chrono::minutes{1}) {</span></span>
<span id="L2536"><span class="lineNum">    2536</span>                 :<span class="tlaUNC">           0 :                 add_fixed_seeds_now = true;</span></span>
<span id="L2537"><span class="lineNum">    2537</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 LogPrintf(&quot;Adding fixed seeds as 60 seconds have passed and addrman is empty for at least one reachable network\n&quot;);</span></span>
<span id="L2538"><span class="lineNum">    2538</span>                 :             :             }</span>
<span id="L2539"><span class="lineNum">    2539</span>                 :             : </span>
<span id="L2540"><span class="lineNum">    2540</span>                 :             :             // Perform cheap checks before locking a mutex.</span>
<span id="L2541"><span class="lineNum">    2541</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             else if (!dnsseed &amp;&amp; !use_seednodes) {</span></span>
<span id="L2542"><span class="lineNum">    2542</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 LOCK(m_added_nodes_mutex);</span></span>
<span id="L2543"><span class="lineNum">    2543</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (m_added_node_params.empty()) {</span></span>
<span id="L2544"><span class="lineNum">    2544</span>                 :<span class="tlaUNC">           0 :                     add_fixed_seeds_now = true;</span></span>
<span id="L2545"><span class="lineNum">    2545</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     LogPrintf(&quot;Adding fixed seeds as -dnsseed=0 (or IPv4/IPv6 connections are disabled via -onlynet) and neither -addnode nor -seednode are provided\n&quot;);</span></span>
<span id="L2546"><span class="lineNum">    2546</span>                 :             :                 }</span>
<span id="L2547"><span class="lineNum">    2547</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L2548"><span class="lineNum">    2548</span>                 :             : </span>
<span id="L2549"><span class="lineNum">    2549</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (add_fixed_seeds_now) {</span></span>
<span id="L2550"><span class="lineNum">    2550</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 std::vector&lt;CAddress&gt; seed_addrs{ConvertSeeds(m_params.FixedSeeds())};</span></span>
<span id="L2551"><span class="lineNum">    2551</span>                 :             :                 // We will not make outgoing connections to peers that are unreachable</span>
<span id="L2552"><span class="lineNum">    2552</span>                 :             :                 // (e.g. because of -onlynet configuration).</span>
<span id="L2553"><span class="lineNum">    2553</span>                 :             :                 // Therefore, we do not add them to addrman in the first place.</span>
<span id="L2554"><span class="lineNum">    2554</span>                 :             :                 // In case previously unreachable networks become reachable</span>
<span id="L2555"><span class="lineNum">    2555</span>                 :             :                 // (e.g. in case of -onlynet changes by the user), fixed seeds will</span>
<span id="L2556"><span class="lineNum">    2556</span>                 :             :                 // be loaded only for networks for which we have no addresses.</span>
<span id="L2557"><span class="lineNum">    2557</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 seed_addrs.erase(std::remove_if(seed_addrs.begin(), seed_addrs.end(),</span></span>
<span id="L2558"><span class="lineNum">    2558</span>                 :<span class="tlaUNC">           0 :                                                 [&amp;fixed_seed_networks](const CAddress&amp; addr) { return fixed_seed_networks.count(addr.GetNetwork()) == 0; }),</span></span>
<span id="L2559"><span class="lineNum">    2559</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                  seed_addrs.end());</span></span>
<span id="L2560"><span class="lineNum">    2560</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 CNetAddr local;</span></span>
<span id="L2561"><span class="lineNum">    2561</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 local.SetInternal(&quot;fixedseeds&quot;);</span></span>
<span id="L2562"><span class="lineNum">    2562</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 addrman.Add(seed_addrs, local);</span></span>
<span id="L2563"><span class="lineNum">    2563</span>                 :<span class="tlaUNC">           0 :                 add_fixed_seeds = false;</span></span>
<span id="L2564"><span class="lineNum">    2564</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 LogPrintf(&quot;Added %d fixed seeds from reachable networks.\n&quot;, seed_addrs.size());</span></span>
<span id="L2565"><span class="lineNum">    2565</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L2566"><span class="lineNum">    2566</span>                 :             :         }</span>
<span id="L2567"><span class="lineNum">    2567</span>                 :             : </span>
<span id="L2568"><span class="lineNum">    2568</span>                 :             :         //</span>
<span id="L2569"><span class="lineNum">    2569</span>                 :             :         // Choose an address to connect to based on most recently seen</span>
<span id="L2570"><span class="lineNum">    2570</span>                 :             :         //</span>
<span id="L2571"><span class="lineNum">    2571</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         CAddress addrConnect;</span></span>
<span id="L2572"><span class="lineNum">    2572</span>                 :             : </span>
<span id="L2573"><span class="lineNum">    2573</span>                 :             :         // Only connect out to one peer per ipv4/ipv6 network group (/16 for IPv4).</span>
<span id="L2574"><span class="lineNum">    2574</span>                 :<span class="tlaUNC">           0 :         int nOutboundFullRelay = 0;</span></span>
<span id="L2575"><span class="lineNum">    2575</span>                 :<span class="tlaUNC">           0 :         int nOutboundBlockRelay = 0;</span></span>
<span id="L2576"><span class="lineNum">    2576</span>                 :<span class="tlaUNC">           0 :         int outbound_privacy_network_peers = 0;</span></span>
<span id="L2577"><span class="lineNum">    2577</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         std::set&lt;std::vector&lt;unsigned char&gt;&gt; outbound_ipv46_peer_netgroups;</span></span>
<span id="L2578"><span class="lineNum">    2578</span>                 :             : </span>
<span id="L2579"><span class="lineNum">    2579</span>                 :<span class="tlaUNC">           0 :         {</span></span>
<span id="L2580"><span class="lineNum">    2580</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LOCK(m_nodes_mutex);</span></span>
<span id="L2581"><span class="lineNum">    2581</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (const CNode* pnode : m_nodes) {</span></span>
<span id="L2582"><span class="lineNum">    2582</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (pnode-&gt;IsFullOutboundConn()) nOutboundFullRelay++;</span></span>
<span id="L2583"><span class="lineNum">    2583</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (pnode-&gt;IsBlockOnlyConn()) nOutboundBlockRelay++;</span></span>
<span id="L2584"><span class="lineNum">    2584</span>                 :             : </span>
<span id="L2585"><span class="lineNum">    2585</span>                 :             :                 // Make sure our persistent outbound slots to ipv4/ipv6 peers belong to different netgroups.</span>
<span id="L2586"><span class="lineNum">    2586</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 switch (pnode-&gt;m_conn_type) {</span></span>
<span id="L2587"><span class="lineNum">    2587</span>                 :             :                     // We currently don't take inbound connections into account. Since they are</span>
<span id="L2588"><span class="lineNum">    2588</span>                 :             :                     // free to make, an attacker could make them to prevent us from connecting to</span>
<span id="L2589"><span class="lineNum">    2589</span>                 :             :                     // certain peers.</span>
<span id="L2590"><span class="lineNum">    2590</span>                 :             :                     case ConnectionType::INBOUND:</span>
<span id="L2591"><span class="lineNum">    2591</span>                 :             :                     // Short-lived outbound connections should not affect how we select outbound</span>
<span id="L2592"><span class="lineNum">    2592</span>                 :             :                     // peers from addrman.</span>
<span id="L2593"><span class="lineNum">    2593</span>                 :             :                     case ConnectionType::ADDR_FETCH:</span>
<span id="L2594"><span class="lineNum">    2594</span>                 :             :                     case ConnectionType::FEELER:</span>
<span id="L2595"><span class="lineNum">    2595</span>                 :             :                         break;</span>
<span id="L2596"><span class="lineNum">    2596</span>                 :<span class="tlaUNC">           0 :                     case ConnectionType::MANUAL:</span></span>
<span id="L2597"><span class="lineNum">    2597</span>                 :<span class="tlaUNC">           0 :                     case ConnectionType::OUTBOUND_FULL_RELAY:</span></span>
<span id="L2598"><span class="lineNum">    2598</span>                 :<span class="tlaUNC">           0 :                     case ConnectionType::BLOCK_RELAY:</span></span>
<span id="L2599"><span class="lineNum">    2599</span>                 :<span class="tlaUNC">           0 :                         const CAddress address{pnode-&gt;addr};</span></span>
<span id="L2600"><span class="lineNum">    2600</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                         if (address.IsTor() || address.IsI2P() || address.IsCJDNS()) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2601"><span class="lineNum">    2601</span>                 :             :                             // Since our addrman-groups for these networks are</span>
<span id="L2602"><span class="lineNum">    2602</span>                 :             :                             // random, without relation to the route we</span>
<span id="L2603"><span class="lineNum">    2603</span>                 :             :                             // take to connect to these peers or to the</span>
<span id="L2604"><span class="lineNum">    2604</span>                 :             :                             // difficulty in obtaining addresses with diverse</span>
<span id="L2605"><span class="lineNum">    2605</span>                 :             :                             // groups, we don't worry about diversity with</span>
<span id="L2606"><span class="lineNum">    2606</span>                 :             :                             // respect to our addrman groups when connecting to</span>
<span id="L2607"><span class="lineNum">    2607</span>                 :             :                             // these networks.</span>
<span id="L2608"><span class="lineNum">    2608</span>                 :<span class="tlaUNC">           0 :                             ++outbound_privacy_network_peers;</span></span>
<span id="L2609"><span class="lineNum">    2609</span>                 :             :                         } else {</span>
<span id="L2610"><span class="lineNum">    2610</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                             outbound_ipv46_peer_netgroups.insert(m_netgroupman.GetGroup(address));</span></span>
<span id="L2611"><span class="lineNum">    2611</span>                 :             :                         }</span>
<span id="L2612"><span class="lineNum">    2612</span>                 :             :                 } // no default case, so the compiler can warn about missing cases</span>
<span id="L2613"><span class="lineNum">    2613</span>                 :             :             }</span>
<span id="L2614"><span class="lineNum">    2614</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L2615"><span class="lineNum">    2615</span>                 :             : </span>
<span id="L2616"><span class="lineNum">    2616</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!seed_nodes.empty() &amp;&amp; nOutboundFullRelay &lt; SEED_OUTBOUND_CONNECTION_THRESHOLD) {</span></span>
<span id="L2617"><span class="lineNum">    2617</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (NodeClock::now() &gt; seed_node_timer + ADD_NEXT_SEEDNODE) {</span></span>
<span id="L2618"><span class="lineNum">    2618</span>                 :<span class="tlaUNC">           0 :                 seed_node_timer = NodeClock::now();</span></span>
<span id="L2619"><span class="lineNum">    2619</span>                 :<span class="tlaUNC">           0 :                 add_addr_fetch = true;</span></span>
<span id="L2620"><span class="lineNum">    2620</span>                 :             :             }</span>
<span id="L2621"><span class="lineNum">    2621</span>                 :             :         }</span>
<span id="L2622"><span class="lineNum">    2622</span>                 :             : </span>
<span id="L2623"><span class="lineNum">    2623</span>                 :<span class="tlaUNC">           0 :         ConnectionType conn_type = ConnectionType::OUTBOUND_FULL_RELAY;</span></span>
<span id="L2624"><span class="lineNum">    2624</span>                 :<span class="tlaUNC">           0 :         auto now = GetTime&lt;std::chrono::microseconds&gt;();</span></span>
<span id="L2625"><span class="lineNum">    2625</span>                 :<span class="tlaUNC">           0 :         bool anchor = false;</span></span>
<span id="L2626"><span class="lineNum">    2626</span>                 :<span class="tlaUNC">           0 :         bool fFeeler = false;</span></span>
<span id="L2627"><span class="lineNum">    2627</span>                 :<span class="tlaUNC">           0 :         std::optional&lt;Network&gt; preferred_net;</span></span>
<span id="L2628"><span class="lineNum">    2628</span>                 :             : </span>
<span id="L2629"><span class="lineNum">    2629</span>                 :             :         // Determine what type of connection to open. Opening</span>
<span id="L2630"><span class="lineNum">    2630</span>                 :             :         // BLOCK_RELAY connections to addresses from anchors.dat gets the highest</span>
<span id="L2631"><span class="lineNum">    2631</span>                 :             :         // priority. Then we open OUTBOUND_FULL_RELAY priority until we</span>
<span id="L2632"><span class="lineNum">    2632</span>                 :             :         // meet our full-relay capacity. Then we open BLOCK_RELAY connection</span>
<span id="L2633"><span class="lineNum">    2633</span>                 :             :         // until we hit our block-relay-only peer limit.</span>
<span id="L2634"><span class="lineNum">    2634</span>                 :             :         // GetTryNewOutboundPeer() gets set when a stale tip is detected, so we</span>
<span id="L2635"><span class="lineNum">    2635</span>                 :             :         // try opening an additional OUTBOUND_FULL_RELAY connection. If none of</span>
<span id="L2636"><span class="lineNum">    2636</span>                 :             :         // these conditions are met, check to see if it's time to try an extra</span>
<span id="L2637"><span class="lineNum">    2637</span>                 :             :         // block-relay-only peer (to confirm our tip is current, see below) or the next_feeler</span>
<span id="L2638"><span class="lineNum">    2638</span>                 :             :         // timer to decide if we should open a FEELER.</span>
<span id="L2639"><span class="lineNum">    2639</span>                 :             : </span>
<span id="L2640"><span class="lineNum">    2640</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!m_anchors.empty() &amp;&amp; (nOutboundBlockRelay &lt; m_max_outbound_block_relay)) {</span></span>
<span id="L2641"><span class="lineNum">    2641</span>                 :             :             conn_type = ConnectionType::BLOCK_RELAY;</span>
<span id="L2642"><span class="lineNum">    2642</span>                 :             :             anchor = true;</span>
<span id="L2643"><span class="lineNum">    2643</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (nOutboundFullRelay &lt; m_max_outbound_full_relay) {</span></span>
<span id="L2644"><span class="lineNum">    2644</span>                 :             :             // OUTBOUND_FULL_RELAY</span>
<span id="L2645"><span class="lineNum">    2645</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (nOutboundBlockRelay &lt; m_max_outbound_block_relay) {</span></span>
<span id="L2646"><span class="lineNum">    2646</span>                 :             :             conn_type = ConnectionType::BLOCK_RELAY;</span>
<span id="L2647"><span class="lineNum">    2647</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (GetTryNewOutboundPeer()) {</span></span>
<span id="L2648"><span class="lineNum">    2648</span>                 :             :             // OUTBOUND_FULL_RELAY</span>
<span id="L2649"><span class="lineNum">    2649</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (now &gt; next_extra_block_relay &amp;&amp; m_start_extra_block_relay_peers) {</span></span>
<span id="L2650"><span class="lineNum">    2650</span>                 :             :             // Periodically connect to a peer (using regular outbound selection</span>
<span id="L2651"><span class="lineNum">    2651</span>                 :             :             // methodology from addrman) and stay connected long enough to sync</span>
<span id="L2652"><span class="lineNum">    2652</span>                 :             :             // headers, but not much else.</span>
<span id="L2653"><span class="lineNum">    2653</span>                 :             :             //</span>
<span id="L2654"><span class="lineNum">    2654</span>                 :             :             // Then disconnect the peer, if we haven't learned anything new.</span>
<span id="L2655"><span class="lineNum">    2655</span>                 :             :             //</span>
<span id="L2656"><span class="lineNum">    2656</span>                 :             :             // The idea is to make eclipse attacks very difficult to pull off,</span>
<span id="L2657"><span class="lineNum">    2657</span>                 :             :             // because every few minutes we're finding a new peer to learn headers</span>
<span id="L2658"><span class="lineNum">    2658</span>                 :             :             // from.</span>
<span id="L2659"><span class="lineNum">    2659</span>                 :             :             //</span>
<span id="L2660"><span class="lineNum">    2660</span>                 :             :             // This is similar to the logic for trying extra outbound (full-relay)</span>
<span id="L2661"><span class="lineNum">    2661</span>                 :             :             // peers, except:</span>
<span id="L2662"><span class="lineNum">    2662</span>                 :             :             // - we do this all the time on an exponential timer, rather than just when</span>
<span id="L2663"><span class="lineNum">    2663</span>                 :             :             //   our tip is stale</span>
<span id="L2664"><span class="lineNum">    2664</span>                 :             :             // - we potentially disconnect our next-youngest block-relay-only peer, if our</span>
<span id="L2665"><span class="lineNum">    2665</span>                 :             :             //   newest block-relay-only peer delivers a block more recently.</span>
<span id="L2666"><span class="lineNum">    2666</span>                 :             :             //   See the eviction logic in net_processing.cpp.</span>
<span id="L2667"><span class="lineNum">    2667</span>                 :             :             //</span>
<span id="L2668"><span class="lineNum">    2668</span>                 :             :             // Because we can promote these connections to block-relay-only</span>
<span id="L2669"><span class="lineNum">    2669</span>                 :             :             // connections, they do not get their own ConnectionType enum</span>
<span id="L2670"><span class="lineNum">    2670</span>                 :             :             // (similar to how we deal with extra outbound peers).</span>
<span id="L2671"><span class="lineNum">    2671</span>                 :<span class="tlaUNC">           0 :             next_extra_block_relay = now + rng.rand_exp_duration(EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);</span></span>
<span id="L2672"><span class="lineNum">    2672</span>                 :<span class="tlaUNC">           0 :             conn_type = ConnectionType::BLOCK_RELAY;</span></span>
<span id="L2673"><span class="lineNum">    2673</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (now &gt; next_feeler) {</span></span>
<span id="L2674"><span class="lineNum">    2674</span>                 :<span class="tlaUNC">           0 :             next_feeler = now + rng.rand_exp_duration(FEELER_INTERVAL);</span></span>
<span id="L2675"><span class="lineNum">    2675</span>                 :<span class="tlaUNC">           0 :             conn_type = ConnectionType::FEELER;</span></span>
<span id="L2676"><span class="lineNum">    2676</span>                 :<span class="tlaUNC">           0 :             fFeeler = true;</span></span>
<span id="L2677"><span class="lineNum">    2677</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (nOutboundFullRelay == m_max_outbound_full_relay &amp;&amp;</span></span>
<span id="L2678"><span class="lineNum">    2678</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                    m_max_outbound_full_relay == MAX_OUTBOUND_FULL_RELAY_CONNECTIONS &amp;&amp;</span></span>
<span id="L2679"><span class="lineNum">    2679</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                    now &gt; next_extra_network_peer &amp;&amp;</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2680"><span class="lineNum">    2680</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                    MaybePickPreferredNetwork(preferred_net)) {</span></span>
<span id="L2681"><span class="lineNum">    2681</span>                 :             :             // Full outbound connection management: Attempt to get at least one</span>
<span id="L2682"><span class="lineNum">    2682</span>                 :             :             // outbound peer from each reachable network by making extra connections</span>
<span id="L2683"><span class="lineNum">    2683</span>                 :             :             // and then protecting &quot;only&quot; peers from a network during outbound eviction.</span>
<span id="L2684"><span class="lineNum">    2684</span>                 :             :             // This is not attempted if the user changed -maxconnections to a value</span>
<span id="L2685"><span class="lineNum">    2685</span>                 :             :             // so low that less than MAX_OUTBOUND_FULL_RELAY_CONNECTIONS are made,</span>
<span id="L2686"><span class="lineNum">    2686</span>                 :             :             // to prevent interactions with otherwise protected outbound peers.</span>
<span id="L2687"><span class="lineNum">    2687</span>                 :<span class="tlaUNC">           0 :             next_extra_network_peer = now + rng.rand_exp_duration(EXTRA_NETWORK_PEER_INTERVAL);</span></span>
<span id="L2688"><span class="lineNum">    2688</span>                 :             :         } else {</span>
<span id="L2689"><span class="lineNum">    2689</span>                 :             :             // skip to next iteration of while loop</span>
<span id="L2690"><span class="lineNum">    2690</span>                 :<span class="tlaUNC">           0 :             continue;</span></span>
<span id="L2691"><span class="lineNum">    2691</span>                 :             :         }</span>
<span id="L2692"><span class="lineNum">    2692</span>                 :             : </span>
<span id="L2693"><span class="lineNum">    2693</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         addrman.ResolveCollisions();</span></span>
<span id="L2694"><span class="lineNum">    2694</span>                 :             : </span>
<span id="L2695"><span class="lineNum">    2695</span>                 :<span class="tlaUNC">           0 :         const auto current_time{NodeClock::now()};</span></span>
<span id="L2696"><span class="lineNum">    2696</span>                 :<span class="tlaUNC">           0 :         int nTries = 0;</span></span>
<span id="L2697"><span class="lineNum">    2697</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const auto reachable_nets{g_reachable_nets.All()};</span></span>
<span id="L2698"><span class="lineNum">    2698</span>                 :             : </span>
<span id="L2699"><span class="lineNum">    2699</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         while (!interruptNet)</span></span>
<span id="L2700"><span class="lineNum">    2700</span>                 :             :         {</span>
<span id="L2701"><span class="lineNum">    2701</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (anchor &amp;&amp; !m_anchors.empty()) {</span></span>
<span id="L2702"><span class="lineNum">    2702</span>                 :<span class="tlaUNC">           0 :                 const CAddress addr = m_anchors.back();</span></span>
<span id="L2703"><span class="lineNum">    2703</span>                 :<span class="tlaUNC">           0 :                 m_anchors.pop_back();</span></span>
<span id="L2704"><span class="lineNum">    2704</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 if (!addr.IsValid() || IsLocal(addr) || !g_reachable_nets.Contains(addr) ||</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span><span class="tlaUNC" title="Branch 12 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 13 was not executed"> # </span>]
<span id="L2705"><span class="lineNum">    2705</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                     !m_msgproc-&gt;HasAllDesirableServiceFlags(addr.nServices) ||</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2706"><span class="lineNum">    2706</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     outbound_ipv46_peer_netgroups.count(m_netgroupman.GetGroup(addr))) continue;</span></span>
<span id="L2707"><span class="lineNum">    2707</span>                 :<span class="tlaUNC">           0 :                 addrConnect = addr;</span></span>
<span id="L2708"><span class="lineNum">    2708</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 LogDebug(BCLog::NET, &quot;Trying to make an anchor connection to %s\n&quot;, addrConnect.ToStringAddrPort());</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L2709"><span class="lineNum">    2709</span>                 :<span class="tlaUNC">           0 :                 break;</span></span>
<span id="L2710"><span class="lineNum">    2710</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L2711"><span class="lineNum">    2711</span>                 :             : </span>
<span id="L2712"><span class="lineNum">    2712</span>                 :             :             // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,</span>
<span id="L2713"><span class="lineNum">    2713</span>                 :             :             // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates</span>
<span id="L2714"><span class="lineNum">    2714</span>                 :             :             // already-connected network ranges, ...) before trying new addrman addresses.</span>
<span id="L2715"><span class="lineNum">    2715</span>                 :<span class="tlaUNC">           0 :             nTries++;</span></span>
<span id="L2716"><span class="lineNum">    2716</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (nTries &gt; 100)</span></span>
<span id="L2717"><span class="lineNum">    2717</span>                 :             :                 break;</span>
<span id="L2718"><span class="lineNum">    2718</span>                 :             : </span>
<span id="L2719"><span class="lineNum">    2719</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             CAddress addr;</span></span>
<span id="L2720"><span class="lineNum">    2720</span>                 :<span class="tlaUNC">           0 :             NodeSeconds addr_last_try{0s};</span></span>
<span id="L2721"><span class="lineNum">    2721</span>                 :             : </span>
<span id="L2722"><span class="lineNum">    2722</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (fFeeler) {</span></span>
<span id="L2723"><span class="lineNum">    2723</span>                 :             :                 // First, try to get a tried table collision address. This returns</span>
<span id="L2724"><span class="lineNum">    2724</span>                 :             :                 // an empty (invalid) address if there are no collisions to try.</span>
<span id="L2725"><span class="lineNum">    2725</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();</span></span>
<span id="L2726"><span class="lineNum">    2726</span>                 :             : </span>
<span id="L2727"><span class="lineNum">    2727</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!addr.IsValid()) {</span></span>
<span id="L2728"><span class="lineNum">    2728</span>                 :             :                     // No tried table collisions. Select a new table address</span>
<span id="L2729"><span class="lineNum">    2729</span>                 :             :                     // for our feeler.</span>
<span id="L2730"><span class="lineNum">    2730</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     std::tie(addr, addr_last_try) = addrman.Select(true, reachable_nets);</span></span>
<span id="L2731"><span class="lineNum">    2731</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 } else if (AlreadyConnectedToAddress(addr)) {</span></span>
<span id="L2732"><span class="lineNum">    2732</span>                 :             :                     // If test-before-evict logic would have us connect to a</span>
<span id="L2733"><span class="lineNum">    2733</span>                 :             :                     // peer that we're already connected to, just mark that</span>
<span id="L2734"><span class="lineNum">    2734</span>                 :             :                     // address as Good(). We won't be able to initiate the</span>
<span id="L2735"><span class="lineNum">    2735</span>                 :             :                     // connection anyway, so this avoids inadvertently evicting</span>
<span id="L2736"><span class="lineNum">    2736</span>                 :             :                     // a currently-connected peer.</span>
<span id="L2737"><span class="lineNum">    2737</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     addrman.Good(addr);</span></span>
<span id="L2738"><span class="lineNum">    2738</span>                 :             :                     // Select a new table address for our feeler instead.</span>
<span id="L2739"><span class="lineNum">    2739</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     std::tie(addr, addr_last_try) = addrman.Select(true, reachable_nets);</span></span>
<span id="L2740"><span class="lineNum">    2740</span>                 :             :                 }</span>
<span id="L2741"><span class="lineNum">    2741</span>                 :             :             } else {</span>
<span id="L2742"><span class="lineNum">    2742</span>                 :             :                 // Not a feeler</span>
<span id="L2743"><span class="lineNum">    2743</span>                 :             :                 // If preferred_net has a value set, pick an extra outbound</span>
<span id="L2744"><span class="lineNum">    2744</span>                 :             :                 // peer from that network. The eviction logic in net_processing</span>
<span id="L2745"><span class="lineNum">    2745</span>                 :             :                 // ensures that a peer from another network will be evicted.</span>
<span id="L2746"><span class="lineNum">    2746</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 std::tie(addr, addr_last_try) = preferred_net.has_value()</span></span>
<span id="L2747"><span class="lineNum">    2747</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                     ? addrman.Select(false, {*preferred_net})</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L2748"><span class="lineNum">    2748</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     : addrman.Select(false, reachable_nets);</span></span>
<span id="L2749"><span class="lineNum">    2749</span>                 :             :             }</span>
<span id="L2750"><span class="lineNum">    2750</span>                 :             : </span>
<span id="L2751"><span class="lineNum">    2751</span>                 :             :             // Require outbound IPv4/IPv6 connections, other than feelers, to be to distinct network groups</span>
<span id="L2752"><span class="lineNum">    2752</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (!fFeeler &amp;&amp; outbound_ipv46_peer_netgroups.count(m_netgroupman.GetGroup(addr))) {</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L2753"><span class="lineNum">    2753</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2754"><span class="lineNum">    2754</span>                 :             :             }</span>
<span id="L2755"><span class="lineNum">    2755</span>                 :             : </span>
<span id="L2756"><span class="lineNum">    2756</span>                 :             :             // if we selected an invalid or local address, restart</span>
<span id="L2757"><span class="lineNum">    2757</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (!addr.IsValid() || IsLocal(addr)) {</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L2758"><span class="lineNum">    2758</span>                 :             :                 break;</span>
<span id="L2759"><span class="lineNum">    2759</span>                 :             :             }</span>
<span id="L2760"><span class="lineNum">    2760</span>                 :             : </span>
<span id="L2761"><span class="lineNum">    2761</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!g_reachable_nets.Contains(addr)) {</span></span>
<span id="L2762"><span class="lineNum">    2762</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2763"><span class="lineNum">    2763</span>                 :             :             }</span>
<span id="L2764"><span class="lineNum">    2764</span>                 :             : </span>
<span id="L2765"><span class="lineNum">    2765</span>                 :             :             // only consider very recently tried nodes after 30 failed attempts</span>
<span id="L2766"><span class="lineNum">    2766</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (current_time - addr_last_try &lt; 10min &amp;&amp; nTries &lt; 30) {</span></span>
<span id="L2767"><span class="lineNum">    2767</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2768"><span class="lineNum">    2768</span>                 :             :             }</span>
<span id="L2769"><span class="lineNum">    2769</span>                 :             : </span>
<span id="L2770"><span class="lineNum">    2770</span>                 :             :             // for non-feelers, require all the services we'll want,</span>
<span id="L2771"><span class="lineNum">    2771</span>                 :             :             // for feelers, only require they be a full node (only because most</span>
<span id="L2772"><span class="lineNum">    2772</span>                 :             :             // SPV clients don't have a good address DB available)</span>
<span id="L2773"><span class="lineNum">    2773</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (!fFeeler &amp;&amp; !m_msgproc-&gt;HasAllDesirableServiceFlags(addr.nServices)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2774"><span class="lineNum">    2774</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2775"><span class="lineNum">    2775</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             } else if (fFeeler &amp;&amp; !MayHaveUsefulAddressDB(addr.nServices)) {</span></span>
<span id="L2776"><span class="lineNum">    2776</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2777"><span class="lineNum">    2777</span>                 :             :             }</span>
<span id="L2778"><span class="lineNum">    2778</span>                 :             : </span>
<span id="L2779"><span class="lineNum">    2779</span>                 :             :             // Do not connect to bad ports, unless 50 invalid addresses have been selected already.</span>
<span id="L2780"><span class="lineNum">    2780</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (nTries &lt; 50 &amp;&amp; (addr.IsIPv4() || addr.IsIPv6()) &amp;&amp; IsBadPort(addr.GetPort())) {</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span>]
<span id="L2781"><span class="lineNum">    2781</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2782"><span class="lineNum">    2782</span>                 :             :             }</span>
<span id="L2783"><span class="lineNum">    2783</span>                 :             : </span>
<span id="L2784"><span class="lineNum">    2784</span>                 :             :             // Do not make automatic outbound connections to addnode peers, to</span>
<span id="L2785"><span class="lineNum">    2785</span>                 :             :             // not use our limited outbound slots for them and to ensure</span>
<span id="L2786"><span class="lineNum">    2786</span>                 :             :             // addnode connections benefit from their intended protections.</span>
<span id="L2787"><span class="lineNum">    2787</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (AddedNodesContain(addr)) {</span></span>
<span id="L2788"><span class="lineNum">    2788</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 LogPrintLevel(BCLog::NET, BCLog::Level::Debug, &quot;Not making automatic %s%s connection to %s peer selected for manual (addnode) connection%s\n&quot;,</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span><span class="tlaUNC" title="Branch 12 was not executed"> # </span><span class="tlaUNC" title="Branch 13 was not executed"> # </span> 
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 14 was not executed"> # </span><span class="tlaUNC" title="Branch 15 was not executed"> # </span><span class="tlaUNC" title="Branch 16 was not executed"> # </span><span class="tlaUNC" title="Branch 17 was not executed"> # </span><span class="tlaUNC" title="Branch 18 was not executed"> # </span> 
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 19 was not executed"> # </span><span class="tlaUNC" title="Branch 20 was not executed"> # </span><span class="tlaUNC" title="Branch 21 was not executed"> # </span><span class="tlaUNC" title="Branch 22 was not executed"> # </span><span class="tlaUNC" title="Branch 23 was not executed"> # </span> 
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 24 was not executed"> # </span><span class="tlaUNC" title="Branch 25 was not executed"> # </span>]
<span id="L2789"><span class="lineNum">    2789</span>                 :             :                               preferred_net.has_value() ? &quot;network-specific &quot; : &quot;&quot;,</span>
<span id="L2790"><span class="lineNum">    2790</span>                 :             :                               ConnectionTypeAsString(conn_type), GetNetworkName(addr.GetNetwork()),</span>
<span id="L2791"><span class="lineNum">    2791</span>                 :             :                               fLogIPs ? strprintf(&quot;: %s&quot;, addr.ToStringAddrPort()) : &quot;&quot;);</span>
<span id="L2792"><span class="lineNum">    2792</span>                 :<span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L2793"><span class="lineNum">    2793</span>                 :             :             }</span>
<span id="L2794"><span class="lineNum">    2794</span>                 :             : </span>
<span id="L2795"><span class="lineNum">    2795</span>                 :<span class="tlaUNC">           0 :             addrConnect = addr;</span></span>
<span id="L2796"><span class="lineNum">    2796</span>                 :             :             break;</span>
<span id="L2797"><span class="lineNum">    2797</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L2798"><span class="lineNum">    2798</span>                 :             : </span>
<span id="L2799"><span class="lineNum">    2799</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (addrConnect.IsValid()) {</span></span>
<span id="L2800"><span class="lineNum">    2800</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (fFeeler) {</span></span>
<span id="L2801"><span class="lineNum">    2801</span>                 :             :                 // Add small amount of random noise before connection to avoid synchronization.</span>
<span id="L2802"><span class="lineNum">    2802</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!interruptNet.sleep_for(rng.rand_uniform_duration&lt;CThreadInterrupt::Clock&gt;(FEELER_SLEEP_WINDOW))) {</span></span>
<span id="L2803"><span class="lineNum">    2803</span>                 :<span class="tlaUNC">           0 :                     return;</span></span>
<span id="L2804"><span class="lineNum">    2804</span>                 :             :                 }</span>
<span id="L2805"><span class="lineNum">    2805</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 LogDebug(BCLog::NET, &quot;Making feeler connection to %s\n&quot;, addrConnect.ToStringAddrPort());</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L2806"><span class="lineNum">    2806</span>                 :             :             }</span>
<span id="L2807"><span class="lineNum">    2807</span>                 :             : </span>
<span id="L2808"><span class="lineNum">    2808</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (preferred_net != std::nullopt) LogDebug(BCLog::NET, &quot;Making network specific connection to %s on %s.\n&quot;, addrConnect.ToStringAddrPort(), GetNetworkName(preferred_net.value()));</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span><span class="tlaUNC" title="Branch 12 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 13 was not executed"> # </span>]
<span id="L2809"><span class="lineNum">    2809</span>                 :             : </span>
<span id="L2810"><span class="lineNum">    2810</span>                 :             :             // Record addrman failure attempts when node has at least 2 persistent outbound connections to peers with</span>
<span id="L2811"><span class="lineNum">    2811</span>                 :             :             // different netgroups in ipv4/ipv6 networks + all peers in Tor/I2P/CJDNS networks.</span>
<span id="L2812"><span class="lineNum">    2812</span>                 :             :             // Don't record addrman failure attempts when node is offline. This can be identified since all local</span>
<span id="L2813"><span class="lineNum">    2813</span>                 :             :             // network connections (if any) belong in the same netgroup, and the size of `outbound_ipv46_peer_netgroups` would only be 1.</span>
<span id="L2814"><span class="lineNum">    2814</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             const bool count_failures{((int)outbound_ipv46_peer_netgroups.size() + outbound_privacy_network_peers) &gt;= std::min(m_max_automatic_connections - 1, 2)};</span></span>
<span id="L2815"><span class="lineNum">    2815</span>                 :             :             // Use BIP324 transport when both us and them have NODE_V2_P2P set.</span>
<span id="L2816"><span class="lineNum">    2816</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             const bool use_v2transport(addrConnect.nServices &amp; GetLocalServices() &amp; NODE_P2P_V2);</span></span>
<span id="L2817"><span class="lineNum">    2817</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             OpenNetworkConnection(addrConnect, count_failures, std::move(grant), /*strDest=*/nullptr, conn_type, use_v2transport);</span></span>
<span id="L2818"><span class="lineNum">    2818</span>                 :             :         }</span>
<span id="L2819"><span class="lineNum">    2819</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2820"><span class="lineNum">    2820</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2821"><span class="lineNum">    2821</span>                 :             : </span>
<span id="L2822"><span class="lineNum">    2822</span>                 :<span class="tlaUNC">           0 : std::vector&lt;CAddress&gt; CConnman::GetCurrentBlockRelayOnlyConns() const</span></span>
<span id="L2823"><span class="lineNum">    2823</span>                 :             : {</span>
<span id="L2824"><span class="lineNum">    2824</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;CAddress&gt; ret;</span></span>
<span id="L2825"><span class="lineNum">    2825</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L2826"><span class="lineNum">    2826</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const CNode* pnode : m_nodes) {</span></span>
<span id="L2827"><span class="lineNum">    2827</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (pnode-&gt;IsBlockOnlyConn()) {</span></span>
<span id="L2828"><span class="lineNum">    2828</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             ret.push_back(pnode-&gt;addr);</span></span>
<span id="L2829"><span class="lineNum">    2829</span>                 :             :         }</span>
<span id="L2830"><span class="lineNum">    2830</span>                 :             :     }</span>
<span id="L2831"><span class="lineNum">    2831</span>                 :             : </span>
<span id="L2832"><span class="lineNum">    2832</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return ret;</span></span>
<span id="L2833"><span class="lineNum">    2833</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L2834"><span class="lineNum">    2834</span>                 :             : </span>
<span id="L2835"><span class="lineNum">    2835</span>                 :<span class="tlaGNC tlaBgGNC">           3 : std::vector&lt;AddedNodeInfo&gt; CConnman::GetAddedNodeInfo(bool include_connected) const</span></span>
<span id="L2836"><span class="lineNum">    2836</span>                 :             : {</span>
<span id="L2837"><span class="lineNum">    2837</span>                 :<span class="tlaGNC">           3 :     std::vector&lt;AddedNodeInfo&gt; ret;</span></span>
<span id="L2838"><span class="lineNum">    2838</span>                 :             : </span>
<span id="L2839"><span class="lineNum">    2839</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           3 :     std::list&lt;AddedNodeParams&gt; lAddresses(0);</span></span>
<span id="L2840"><span class="lineNum">    2840</span>                 :<span class="tlaGNC">           3 :     {</span></span>
<span id="L2841"><span class="lineNum">    2841</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           3 :         LOCK(m_added_nodes_mutex);</span></span>
<span id="L2842"><span class="lineNum">    2842</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           3 :         ret.reserve(m_added_node_params.size());</span></span>
<span id="L2843"><span class="lineNum">    2843</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           3 :         std::copy(m_added_node_params.cbegin(), m_added_node_params.cend(), std::back_inserter(lAddresses));</span></span>
<span id="L2844"><span class="lineNum">    2844</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     }</span></span>
<span id="L2845"><span class="lineNum">    2845</span>                 :             : </span>
<span id="L2846"><span class="lineNum">    2846</span>                 :             : </span>
<span id="L2847"><span class="lineNum">    2847</span>                 :             :     // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService</span>
<span id="L2848"><span class="lineNum">    2848</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC tlaBgGNC">           3 :     std::map&lt;CService, bool&gt; mapConnected;</span></span>
<span id="L2849"><span class="lineNum">    2849</span>                 :<span class="tlaGNC">           3 :     std::map&lt;std::string, std::pair&lt;bool, CService&gt;&gt; mapConnectedByName;</span></span>
<span id="L2850"><span class="lineNum">    2850</span>                 :<span class="tlaGNC">           3 :     {</span></span>
<span id="L2851"><span class="lineNum">    2851</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           3 :         LOCK(m_nodes_mutex);</span></span>
<span id="L2852"><span class="lineNum">    2852</span>         [<span class="tlaGBC" title="Branch 0 was taken 16 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC">          19 :         for (const CNode* pnode : m_nodes) {</span></span>
<span id="L2853"><span class="lineNum">    2853</span>   [<span class="tlaGBC" title="Branch 0 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          16 :             if (pnode-&gt;addr.IsValid()) {</span></span>
<span id="L2854"><span class="lineNum">    2854</span>         [<span class="tlaGBC" title="Branch 0 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          16 :                 mapConnected[pnode-&gt;addr] = pnode-&gt;IsInboundConn();</span></span>
<span id="L2855"><span class="lineNum">    2855</span>                 :             :             }</span>
<span id="L2856"><span class="lineNum">    2856</span>         [<span class="tlaGBC" title="Branch 0 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          16 :             std::string addrName{pnode-&gt;m_addr_name};</span></span>
<span id="L2857"><span class="lineNum">    2857</span>         [<span class="tlaGBC" title="Branch 0 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          16 :             if (!addrName.empty()) {</span></span>
<span id="L2858"><span class="lineNum">    2858</span>         [<span class="tlaGBC" title="Branch 0 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          16 :                 mapConnectedByName[std::move(addrName)] = std::make_pair(pnode-&gt;IsInboundConn(), static_cast&lt;const CService&amp;&gt;(pnode-&gt;addr));</span></span>
<span id="L2859"><span class="lineNum">    2859</span>                 :             :             }</span>
<span id="L2860"><span class="lineNum">    2860</span>                 :<span class="tlaGNC">          16 :         }</span></span>
<span id="L2861"><span class="lineNum">    2861</span>                 :<span class="tlaUNC tlaBgUNC">           0 :     }</span></span>
<span id="L2862"><span class="lineNum">    2862</span>                 :             : </span>
<span id="L2863"><span class="lineNum">    2863</span>         [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 3 times"> + </span>]:<span class="tlaGNC tlaBgGNC">          18 :     for (const auto&amp; addr : lAddresses) {</span></span>
<span id="L2864"><span class="lineNum">    2864</span>   [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          30 :         CService service{MaybeFlipIPv6toCJDNS(LookupNumeric(addr.m_added_node, GetDefaultPort(addr.m_added_node)))};</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L2865"><span class="lineNum">    2865</span>   [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          15 :         AddedNodeInfo addedNode{addr, CService(), false, false};</span></span>
<span id="L2866"><span class="lineNum">    2866</span>   [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          15 :         if (service.IsValid()) {</span></span>
<span id="L2867"><span class="lineNum">    2867</span>                 :             :             // strAddNode is an IP:port</span>
<span id="L2868"><span class="lineNum">    2868</span>         [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          15 :             auto it = mapConnected.find(service);</span></span>
<span id="L2869"><span class="lineNum">    2869</span>         [<span class="tlaGBC" title="Branch 0 was taken 15 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          15 :             if (it != mapConnected.end()) {</span></span>
<span id="L2870"><span class="lineNum">    2870</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 10 times"> + </span>]:<span class="tlaGNC">          15 :                 if (!include_connected) {</span></span>
<span id="L2871"><span class="lineNum">    2871</span>                 :<span class="tlaGNC">           5 :                     continue;</span></span>
<span id="L2872"><span class="lineNum">    2872</span>                 :             :                 }</span>
<span id="L2873"><span class="lineNum">    2873</span>                 :<span class="tlaGNC">          10 :                 addedNode.resolvedAddress = service;</span></span>
<span id="L2874"><span class="lineNum">    2874</span>                 :<span class="tlaGNC">          10 :                 addedNode.fConnected = true;</span></span>
<span id="L2875"><span class="lineNum">    2875</span>                 :<span class="tlaGNC">          10 :                 addedNode.fInbound = it-&gt;second;</span></span>
<span id="L2876"><span class="lineNum">    2876</span>                 :             :             }</span>
<span id="L2877"><span class="lineNum">    2877</span>                 :             :         } else {</span>
<span id="L2878"><span class="lineNum">    2878</span>                 :             :             // strAddNode is a name</span>
<span id="L2879"><span class="lineNum">    2879</span>                 :<span class="tlaUNC tlaBgUNC">           0 :             auto it = mapConnectedByName.find(addr.m_added_node);</span></span>
<span id="L2880"><span class="lineNum">    2880</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (it != mapConnectedByName.end()) {</span></span>
<span id="L2881"><span class="lineNum">    2881</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (!include_connected) {</span></span>
<span id="L2882"><span class="lineNum">    2882</span>                 :<span class="tlaUNC">           0 :                     continue;</span></span>
<span id="L2883"><span class="lineNum">    2883</span>                 :             :                 }</span>
<span id="L2884"><span class="lineNum">    2884</span>                 :<span class="tlaUNC">           0 :                 addedNode.resolvedAddress = it-&gt;second.second;</span></span>
<span id="L2885"><span class="lineNum">    2885</span>                 :<span class="tlaUNC">           0 :                 addedNode.fConnected = true;</span></span>
<span id="L2886"><span class="lineNum">    2886</span>                 :<span class="tlaUNC">           0 :                 addedNode.fInbound = it-&gt;second.first;</span></span>
<span id="L2887"><span class="lineNum">    2887</span>                 :             :             }</span>
<span id="L2888"><span class="lineNum">    2888</span>                 :             :         }</span>
<span id="L2889"><span class="lineNum">    2889</span>         [<span class="tlaGBC" title="Branch 0 was taken 10 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC tlaBgGNC">          10 :         ret.emplace_back(std::move(addedNode));</span></span>
<span id="L2890"><span class="lineNum">    2890</span>                 :<span class="tlaGNC">          15 :     }</span></span>
<span id="L2891"><span class="lineNum">    2891</span>                 :             : </span>
<span id="L2892"><span class="lineNum">    2892</span>                 :<span class="tlaGNC">           3 :     return ret;</span></span>
<span id="L2893"><span class="lineNum">    2893</span>                 :<span class="tlaGNC">           3 : }</span></span>
<span id="L2894"><span class="lineNum">    2894</span>                 :             : </span>
<span id="L2895"><span class="lineNum">    2895</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CConnman::ThreadOpenAddedConnections()</span></span>
<span id="L2896"><span class="lineNum">    2896</span>                 :             : {</span>
<span id="L2897"><span class="lineNum">    2897</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L2898"><span class="lineNum">    2898</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_reconnections_mutex);</span></span>
<span id="L2899"><span class="lineNum">    2899</span>                 :<span class="tlaUNC">           0 :     while (true)</span></span>
<span id="L2900"><span class="lineNum">    2900</span>                 :             :     {</span>
<span id="L2901"><span class="lineNum">    2901</span>                 :<span class="tlaUNC">           0 :         CSemaphoreGrant grant(*semAddnode);</span></span>
<span id="L2902"><span class="lineNum">    2902</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         std::vector&lt;AddedNodeInfo&gt; vInfo = GetAddedNodeInfo(/*include_connected=*/false);</span></span>
<span id="L2903"><span class="lineNum">    2903</span>                 :<span class="tlaUNC">           0 :         bool tried = false;</span></span>
<span id="L2904"><span class="lineNum">    2904</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (const AddedNodeInfo&amp; info : vInfo) {</span></span>
<span id="L2905"><span class="lineNum">    2905</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!grant) {</span></span>
<span id="L2906"><span class="lineNum">    2906</span>                 :             :                 // If we've used up our semaphore and need a new one, let's not wait here since while we are waiting</span>
<span id="L2907"><span class="lineNum">    2907</span>                 :             :                 // the addednodeinfo state might change.</span>
<span id="L2908"><span class="lineNum">    2908</span>                 :             :                 break;</span>
<span id="L2909"><span class="lineNum">    2909</span>                 :             :             }</span>
<span id="L2910"><span class="lineNum">    2910</span>                 :<span class="tlaUNC">           0 :             tried = true;</span></span>
<span id="L2911"><span class="lineNum">    2911</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             CAddress addr(CService(), NODE_NONE);</span></span>
<span id="L2912"><span class="lineNum">    2912</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             OpenNetworkConnection(addr, false, std::move(grant), info.m_params.m_added_node.c_str(), ConnectionType::MANUAL, info.m_params.m_use_v2transport);</span></span>
<span id="L2913"><span class="lineNum">    2913</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!interruptNet.sleep_for(std::chrono::milliseconds(500))) return;</span></span>
<span id="L2914"><span class="lineNum">    2914</span>                 :<span class="tlaUNC">           0 :             grant = CSemaphoreGrant(*semAddnode, /*fTry=*/true);</span></span>
<span id="L2915"><span class="lineNum">    2915</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L2916"><span class="lineNum">    2916</span>                 :             :         // See if any reconnections are desired.</span>
<span id="L2917"><span class="lineNum">    2917</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         PerformReconnections();</span></span>
<span id="L2918"><span class="lineNum">    2918</span>                 :             :         // Retry every 60 seconds if a connection was attempted, otherwise two seconds</span>
<span id="L2919"><span class="lineNum">    2919</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         if (!interruptNet.sleep_for(std::chrono::seconds(tried ? 60 : 2)))</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2920"><span class="lineNum">    2920</span>                 :             :             return;</span>
<span id="L2921"><span class="lineNum">    2921</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2922"><span class="lineNum">    2922</span>                 :             : }</span>
<span id="L2923"><span class="lineNum">    2923</span>                 :             : </span>
<span id="L2924"><span class="lineNum">    2924</span>                 :             : // if successful, this moves the passed grant to the constructed node</span>
<span id="L2925"><span class="lineNum">    2925</span>                 :<span class="tlaUNC">           0 : void CConnman::OpenNetworkConnection(const CAddress&amp; addrConnect, bool fCountFailure, CSemaphoreGrant&amp;&amp; grant_outbound, const char *pszDest, ConnectionType conn_type, bool use_v2transport)</span></span>
<span id="L2926"><span class="lineNum">    2926</span>                 :             : {</span>
<span id="L2927"><span class="lineNum">    2927</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L2928"><span class="lineNum">    2928</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert(conn_type != ConnectionType::INBOUND);</span></span>
<span id="L2929"><span class="lineNum">    2929</span>                 :             : </span>
<span id="L2930"><span class="lineNum">    2930</span>                 :             :     //</span>
<span id="L2931"><span class="lineNum">    2931</span>                 :             :     // Initiate outbound network connection</span>
<span id="L2932"><span class="lineNum">    2932</span>                 :             :     //</span>
<span id="L2933"><span class="lineNum">    2933</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (interruptNet) {</span></span>
<span id="L2934"><span class="lineNum">    2934</span>                 :             :         return;</span>
<span id="L2935"><span class="lineNum">    2935</span>                 :             :     }</span>
<span id="L2936"><span class="lineNum">    2936</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!fNetworkActive) {</span></span>
<span id="L2937"><span class="lineNum">    2937</span>                 :             :         return;</span>
<span id="L2938"><span class="lineNum">    2938</span>                 :             :     }</span>
<span id="L2939"><span class="lineNum">    2939</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!pszDest) {</span></span>
<span id="L2940"><span class="lineNum">    2940</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         bool banned_or_discouraged = m_banman &amp;&amp; (m_banman-&gt;IsDiscouraged(addrConnect) || m_banman-&gt;IsBanned(addrConnect));</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2941"><span class="lineNum">    2941</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         if (IsLocal(addrConnect) || banned_or_discouraged || AlreadyConnectedToAddress(addrConnect)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L2942"><span class="lineNum">    2942</span>                 :<span class="tlaUNC">           0 :             return;</span></span>
<span id="L2943"><span class="lineNum">    2943</span>                 :             :         }</span>
<span id="L2944"><span class="lineNum">    2944</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     } else if (FindNode(std::string(pszDest)))</span></span>
<span id="L2945"><span class="lineNum">    2945</span>                 :             :         return;</span>
<span id="L2946"><span class="lineNum">    2946</span>                 :             : </span>
<span id="L2947"><span class="lineNum">    2947</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type, use_v2transport);</span></span>
<span id="L2948"><span class="lineNum">    2948</span>                 :             : </span>
<span id="L2949"><span class="lineNum">    2949</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!pnode)</span></span>
<span id="L2950"><span class="lineNum">    2950</span>                 :             :         return;</span>
<span id="L2951"><span class="lineNum">    2951</span>                 :<span class="tlaUNC">           0 :     pnode-&gt;grantOutbound = std::move(grant_outbound);</span></span>
<span id="L2952"><span class="lineNum">    2952</span>                 :             : </span>
<span id="L2953"><span class="lineNum">    2953</span>                 :<span class="tlaUNC">           0 :     m_msgproc-&gt;InitializeNode(*pnode, m_local_services);</span></span>
<span id="L2954"><span class="lineNum">    2954</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L2955"><span class="lineNum">    2955</span>                 :<span class="tlaUNC">           0 :         LOCK(m_nodes_mutex);</span></span>
<span id="L2956"><span class="lineNum">    2956</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         m_nodes.push_back(pnode);</span></span>
<span id="L2957"><span class="lineNum">    2957</span>                 :             : </span>
<span id="L2958"><span class="lineNum">    2958</span>                 :             :         // update connection count by network</span>
<span id="L2959"><span class="lineNum">    2959</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (pnode-&gt;IsManualOrFullOutboundConn()) ++m_network_conn_counts[pnode-&gt;addr.GetNetwork()];</span></span>
<span id="L2960"><span class="lineNum">    2960</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L2961"><span class="lineNum">    2961</span>                 :             : }</span>
<span id="L2962"><span class="lineNum">    2962</span>                 :             : </span>
<span id="L2963"><span class="lineNum">    2963</span>                 :             : Mutex NetEventsInterface::g_msgproc_mutex;</span>
<span id="L2964"><span class="lineNum">    2964</span>                 :             : </span>
<span id="L2965"><span class="lineNum">    2965</span>                 :<span class="tlaUNC">           0 : void CConnman::ThreadMessageHandler()</span></span>
<span id="L2966"><span class="lineNum">    2966</span>                 :             : {</span>
<span id="L2967"><span class="lineNum">    2967</span>                 :<span class="tlaUNC">           0 :     LOCK(NetEventsInterface::g_msgproc_mutex);</span></span>
<span id="L2968"><span class="lineNum">    2968</span>                 :             : </span>
<span id="L2969"><span class="lineNum">    2969</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     while (!flagInterruptMsgProc)</span></span>
<span id="L2970"><span class="lineNum">    2970</span>                 :             :     {</span>
<span id="L2971"><span class="lineNum">    2971</span>                 :<span class="tlaUNC">           0 :         bool fMoreWork = false;</span></span>
<span id="L2972"><span class="lineNum">    2972</span>                 :             : </span>
<span id="L2973"><span class="lineNum">    2973</span>                 :<span class="tlaUNC">           0 :         {</span></span>
<span id="L2974"><span class="lineNum">    2974</span>                 :             :             // Randomize the order in which we process messages from/to our peers.</span>
<span id="L2975"><span class="lineNum">    2975</span>                 :             :             // This prevents attacks in which an attacker exploits having multiple</span>
<span id="L2976"><span class="lineNum">    2976</span>                 :             :             // consecutive connections in the m_nodes list.</span>
<span id="L2977"><span class="lineNum">    2977</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             const NodesSnapshot snap{*this, /*shuffle=*/true};</span></span>
<span id="L2978"><span class="lineNum">    2978</span>                 :             : </span>
<span id="L2979"><span class="lineNum">    2979</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (CNode* pnode : snap.Nodes()) {</span></span>
<span id="L2980"><span class="lineNum">    2980</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (pnode-&gt;fDisconnect)</span></span>
<span id="L2981"><span class="lineNum">    2981</span>                 :<span class="tlaUNC">           0 :                     continue;</span></span>
<span id="L2982"><span class="lineNum">    2982</span>                 :             : </span>
<span id="L2983"><span class="lineNum">    2983</span>                 :             :                 // Receive messages</span>
<span id="L2984"><span class="lineNum">    2984</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 bool fMoreNodeWork = m_msgproc-&gt;ProcessMessages(pnode, flagInterruptMsgProc);</span></span>
<span id="L2985"><span class="lineNum">    2985</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 fMoreWork |= (fMoreNodeWork &amp;&amp; !pnode-&gt;fPauseSend);</span></span>
<span id="L2986"><span class="lineNum">    2986</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (flagInterruptMsgProc)</span></span>
<span id="L2987"><span class="lineNum">    2987</span>                 :             :                     return;</span>
<span id="L2988"><span class="lineNum">    2988</span>                 :             :                 // Send messages</span>
<span id="L2989"><span class="lineNum">    2989</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 m_msgproc-&gt;SendMessages(pnode);</span></span>
<span id="L2990"><span class="lineNum">    2990</span>                 :             : </span>
<span id="L2991"><span class="lineNum">    2991</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (flagInterruptMsgProc)</span></span>
<span id="L2992"><span class="lineNum">    2992</span>                 :             :                     return;</span>
<span id="L2993"><span class="lineNum">    2993</span>                 :             :             }</span>
<span id="L2994"><span class="lineNum">    2994</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         }</span></span>
<span id="L2995"><span class="lineNum">    2995</span>                 :             : </span>
<span id="L2996"><span class="lineNum">    2996</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         WAIT_LOCK(mutexMsgProc, lock);</span></span>
<span id="L2997"><span class="lineNum">    2997</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!fMoreWork) {</span></span>
<span id="L2998"><span class="lineNum">    2998</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             condMsgProc.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(100), [this]() EXCLUSIVE_LOCKS_REQUIRED(mutexMsgProc) { return fMsgProcWake; });</span></span>
<span id="L2999"><span class="lineNum">    2999</span>                 :             :         }</span>
<span id="L3000"><span class="lineNum">    3000</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         fMsgProcWake = false;</span></span>
<span id="L3001"><span class="lineNum">    3001</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L3002"><span class="lineNum">    3002</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3003"><span class="lineNum">    3003</span>                 :             : </span>
<span id="L3004"><span class="lineNum">    3004</span>                 :<span class="tlaUNC">           0 : void CConnman::ThreadI2PAcceptIncoming()</span></span>
<span id="L3005"><span class="lineNum">    3005</span>                 :             : {</span>
<span id="L3006"><span class="lineNum">    3006</span>                 :<span class="tlaUNC">           0 :     static constexpr auto err_wait_begin = 1s;</span></span>
<span id="L3007"><span class="lineNum">    3007</span>                 :<span class="tlaUNC">           0 :     static constexpr auto err_wait_cap = 5min;</span></span>
<span id="L3008"><span class="lineNum">    3008</span>                 :<span class="tlaUNC">           0 :     auto err_wait = err_wait_begin;</span></span>
<span id="L3009"><span class="lineNum">    3009</span>                 :             : </span>
<span id="L3010"><span class="lineNum">    3010</span>                 :<span class="tlaUNC">           0 :     bool advertising_listen_addr = false;</span></span>
<span id="L3011"><span class="lineNum">    3011</span>                 :<span class="tlaUNC">           0 :     i2p::Connection conn;</span></span>
<span id="L3012"><span class="lineNum">    3012</span>                 :             : </span>
<span id="L3013"><span class="lineNum">    3013</span>                 :<span class="tlaUNC">           0 :     auto SleepOnFailure = [&amp;]() {</span></span>
<span id="L3014"><span class="lineNum">    3014</span>                 :<span class="tlaUNC">           0 :         interruptNet.sleep_for(err_wait);</span></span>
<span id="L3015"><span class="lineNum">    3015</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (err_wait &lt; err_wait_cap) {</span></span>
<span id="L3016"><span class="lineNum">    3016</span>                 :<span class="tlaUNC">           0 :             err_wait += 1s;</span></span>
<span id="L3017"><span class="lineNum">    3017</span>                 :             :         }</span>
<span id="L3018"><span class="lineNum">    3018</span>                 :<span class="tlaUNC">           0 :     };</span></span>
<span id="L3019"><span class="lineNum">    3019</span>                 :             : </span>
<span id="L3020"><span class="lineNum">    3020</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     while (!interruptNet) {</span></span>
<span id="L3021"><span class="lineNum">    3021</span>                 :             : </span>
<span id="L3022"><span class="lineNum">    3022</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!m_i2p_sam_session-&gt;Listen(conn)) {</span></span>
<span id="L3023"><span class="lineNum">    3023</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (advertising_listen_addr &amp;&amp; conn.me.IsValid()) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3024"><span class="lineNum">    3024</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 RemoveLocal(conn.me);</span></span>
<span id="L3025"><span class="lineNum">    3025</span>                 :             :                 advertising_listen_addr = false;</span>
<span id="L3026"><span class="lineNum">    3026</span>                 :             :             }</span>
<span id="L3027"><span class="lineNum">    3027</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             SleepOnFailure();</span></span>
<span id="L3028"><span class="lineNum">    3028</span>                 :<span class="tlaUNC">           0 :             continue;</span></span>
<span id="L3029"><span class="lineNum">    3029</span>                 :             :         }</span>
<span id="L3030"><span class="lineNum">    3030</span>                 :             : </span>
<span id="L3031"><span class="lineNum">    3031</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!advertising_listen_addr) {</span></span>
<span id="L3032"><span class="lineNum">    3032</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             AddLocal(conn.me, LOCAL_MANUAL);</span></span>
<span id="L3033"><span class="lineNum">    3033</span>                 :             :             advertising_listen_addr = true;</span>
<span id="L3034"><span class="lineNum">    3034</span>                 :             :         }</span>
<span id="L3035"><span class="lineNum">    3035</span>                 :             : </span>
<span id="L3036"><span class="lineNum">    3036</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!m_i2p_sam_session-&gt;Accept(conn)) {</span></span>
<span id="L3037"><span class="lineNum">    3037</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             SleepOnFailure();</span></span>
<span id="L3038"><span class="lineNum">    3038</span>                 :<span class="tlaUNC">           0 :             continue;</span></span>
<span id="L3039"><span class="lineNum">    3039</span>                 :             :         }</span>
<span id="L3040"><span class="lineNum">    3040</span>                 :             : </span>
<span id="L3041"><span class="lineNum">    3041</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,</span></span>
<span id="L3042"><span class="lineNum">    3042</span>                 :<span class="tlaUNC">           0 :                                      CAddress{conn.me, NODE_NONE}, CAddress{conn.peer, NODE_NONE});</span></span>
<span id="L3043"><span class="lineNum">    3043</span>                 :             : </span>
<span id="L3044"><span class="lineNum">    3044</span>                 :<span class="tlaUNC">           0 :         err_wait = err_wait_begin;</span></span>
<span id="L3045"><span class="lineNum">    3045</span>                 :             :     }</span>
<span id="L3046"><span class="lineNum">    3046</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3047"><span class="lineNum">    3047</span>                 :             : </span>
<span id="L3048"><span class="lineNum">    3048</span>                 :<span class="tlaUNC">           0 : bool CConnman::BindListenPort(const CService&amp; addrBind, bilingual_str&amp; strError, NetPermissionFlags permissions)</span></span>
<span id="L3049"><span class="lineNum">    3049</span>                 :             : {</span>
<span id="L3050"><span class="lineNum">    3050</span>                 :<span class="tlaUNC">           0 :     int nOne = 1;</span></span>
<span id="L3051"><span class="lineNum">    3051</span>                 :             : </span>
<span id="L3052"><span class="lineNum">    3052</span>                 :             :     // Create socket for listening for incoming connections</span>
<span id="L3053"><span class="lineNum">    3053</span>                 :<span class="tlaUNC">           0 :     struct sockaddr_storage sockaddr;</span></span>
<span id="L3054"><span class="lineNum">    3054</span>                 :<span class="tlaUNC">           0 :     socklen_t len = sizeof(sockaddr);</span></span>
<span id="L3055"><span class="lineNum">    3055</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!addrBind.GetSockAddr((struct sockaddr*)&amp;sockaddr, &amp;len))</span></span>
<span id="L3056"><span class="lineNum">    3056</span>                 :             :     {</span>
<span id="L3057"><span class="lineNum">    3057</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         strError = strprintf(Untranslated(&quot;Bind address family for %s not supported&quot;), addrBind.ToStringAddrPort());</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3058"><span class="lineNum">    3058</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintLevel(BCLog::NET, BCLog::Level::Error, &quot;%s\n&quot;, strError.original);</span></span>
<span id="L3059"><span class="lineNum">    3059</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3060"><span class="lineNum">    3060</span>                 :             :     }</span>
<span id="L3061"><span class="lineNum">    3061</span>                 :             : </span>
<span id="L3062"><span class="lineNum">    3062</span>                 :<span class="tlaUNC">           0 :     std::unique_ptr&lt;Sock&gt; sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);</span></span>
<span id="L3063"><span class="lineNum">    3063</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!sock) {</span></span>
<span id="L3064"><span class="lineNum">    3064</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         strError = strprintf(Untranslated(&quot;Couldn't open socket for incoming connections (socket returned error %s)&quot;), NetworkErrorString(WSAGetLastError()));</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L3065"><span class="lineNum">    3065</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogPrintLevel(BCLog::NET, BCLog::Level::Error, &quot;%s\n&quot;, strError.original);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3066"><span class="lineNum">    3066</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3067"><span class="lineNum">    3067</span>                 :             :     }</span>
<span id="L3068"><span class="lineNum">    3068</span>                 :             : </span>
<span id="L3069"><span class="lineNum">    3069</span>                 :             :     // Allow binding if the port is still in TIME_WAIT state after</span>
<span id="L3070"><span class="lineNum">    3070</span>                 :             :     // the program was closed and restarted.</span>
<span id="L3071"><span class="lineNum">    3071</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (sock-&gt;SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&amp;nOne, sizeof(int)) == SOCKET_ERROR) {</span></span>
<span id="L3072"><span class="lineNum">    3072</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         strError = strprintf(Untranslated(&quot;Error setting SO_REUSEADDR on socket: %s, continuing anyway&quot;), NetworkErrorString(WSAGetLastError()));</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L3073"><span class="lineNum">    3073</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;%s\n&quot;, strError.original);</span></span>
<span id="L3074"><span class="lineNum">    3074</span>                 :             :     }</span>
<span id="L3075"><span class="lineNum">    3075</span>                 :             : </span>
<span id="L3076"><span class="lineNum">    3076</span>                 :             :     // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option</span>
<span id="L3077"><span class="lineNum">    3077</span>                 :             :     // and enable it by default or not. Try to enable it, if possible.</span>
<span id="L3078"><span class="lineNum">    3078</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (addrBind.IsIPv6()) {</span></span>
<span id="L3079"><span class="lineNum">    3079</span>                 :             : #ifdef IPV6_V6ONLY</span>
<span id="L3080"><span class="lineNum">    3080</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (sock-&gt;SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&amp;nOne, sizeof(int)) == SOCKET_ERROR) {</span></span>
<span id="L3081"><span class="lineNum">    3081</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             strError = strprintf(Untranslated(&quot;Error setting IPV6_V6ONLY on socket: %s, continuing anyway&quot;), NetworkErrorString(WSAGetLastError()));</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L3082"><span class="lineNum">    3082</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogPrintf(&quot;%s\n&quot;, strError.original);</span></span>
<span id="L3083"><span class="lineNum">    3083</span>                 :             :         }</span>
<span id="L3084"><span class="lineNum">    3084</span>                 :             : #endif</span>
<span id="L3085"><span class="lineNum">    3085</span>                 :             : #ifdef WIN32</span>
<span id="L3086"><span class="lineNum">    3086</span>                 :             :         int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;</span>
<span id="L3087"><span class="lineNum">    3087</span>                 :             :         if (sock-&gt;SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&amp;nProtLevel, sizeof(int)) == SOCKET_ERROR) {</span>
<span id="L3088"><span class="lineNum">    3088</span>                 :             :             strError = strprintf(Untranslated(&quot;Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway&quot;), NetworkErrorString(WSAGetLastError()));</span>
<span id="L3089"><span class="lineNum">    3089</span>                 :             :             LogPrintf(&quot;%s\n&quot;, strError.original);</span>
<span id="L3090"><span class="lineNum">    3090</span>                 :             :         }</span>
<span id="L3091"><span class="lineNum">    3091</span>                 :             : #endif</span>
<span id="L3092"><span class="lineNum">    3092</span>                 :             :     }</span>
<span id="L3093"><span class="lineNum">    3093</span>                 :             : </span>
<span id="L3094"><span class="lineNum">    3094</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (sock-&gt;Bind(reinterpret_cast&lt;struct sockaddr*&gt;(&amp;sockaddr), len) == SOCKET_ERROR) {</span></span>
<span id="L3095"><span class="lineNum">    3095</span>                 :<span class="tlaUNC">           0 :         int nErr = WSAGetLastError();</span></span>
<span id="L3096"><span class="lineNum">    3096</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (nErr == WSAEADDRINUSE)</span></span>
<span id="L3097"><span class="lineNum">    3097</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             strError = strprintf(_(&quot;Unable to bind to %s on this computer. %s is probably already running.&quot;), addrBind.ToStringAddrPort(), PACKAGE_NAME);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3098"><span class="lineNum">    3098</span>                 :             :         else</span>
<span id="L3099"><span class="lineNum">    3099</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             strError = strprintf(_(&quot;Unable to bind to %s on this computer (bind returned error %s)&quot;), addrBind.ToStringAddrPort(), NetworkErrorString(nErr));</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L3100"><span class="lineNum">    3100</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogPrintLevel(BCLog::NET, BCLog::Level::Error, &quot;%s\n&quot;, strError.original);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3101"><span class="lineNum">    3101</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3102"><span class="lineNum">    3102</span>                 :             :     }</span>
<span id="L3103"><span class="lineNum">    3103</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     LogPrintf(&quot;Bound to %s\n&quot;, addrBind.ToStringAddrPort());</span></span>
<span id="L3104"><span class="lineNum">    3104</span>                 :             : </span>
<span id="L3105"><span class="lineNum">    3105</span>                 :             :     // Listen for incoming connections</span>
<span id="L3106"><span class="lineNum">    3106</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (sock-&gt;Listen(SOMAXCONN) == SOCKET_ERROR)</span></span>
<span id="L3107"><span class="lineNum">    3107</span>                 :             :     {</span>
<span id="L3108"><span class="lineNum">    3108</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         strError = strprintf(_(&quot;Listening for incoming connections failed (listen returned error %s)&quot;), NetworkErrorString(WSAGetLastError()));</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3109"><span class="lineNum">    3109</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogPrintLevel(BCLog::NET, BCLog::Level::Error, &quot;%s\n&quot;, strError.original);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3110"><span class="lineNum">    3110</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3111"><span class="lineNum">    3111</span>                 :             :     }</span>
<span id="L3112"><span class="lineNum">    3112</span>                 :             : </span>
<span id="L3113"><span class="lineNum">    3113</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     vhListenSocket.emplace_back(std::move(sock), permissions);</span></span>
<span id="L3114"><span class="lineNum">    3114</span>                 :             :     return true;</span>
<span id="L3115"><span class="lineNum">    3115</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3116"><span class="lineNum">    3116</span>                 :             : </span>
<span id="L3117"><span class="lineNum">    3117</span>                 :<span class="tlaUNC">           0 : void Discover()</span></span>
<span id="L3118"><span class="lineNum">    3118</span>                 :             : {</span>
<span id="L3119"><span class="lineNum">    3119</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!fDiscover)</span></span>
<span id="L3120"><span class="lineNum">    3120</span>                 :             :         return;</span>
<span id="L3121"><span class="lineNum">    3121</span>                 :             : </span>
<span id="L3122"><span class="lineNum">    3122</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const CNetAddr &amp;addr: GetLocalAddresses()) {</span></span>
<span id="L3123"><span class="lineNum">    3123</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (AddLocal(addr, LOCAL_IF))</span></span>
<span id="L3124"><span class="lineNum">    3124</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LogPrintf(&quot;%s: %s\n&quot;, __func__, addr.ToStringAddr());</span></span>
<span id="L3125"><span class="lineNum">    3125</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L3126"><span class="lineNum">    3126</span>                 :             : }</span>
<span id="L3127"><span class="lineNum">    3127</span>                 :             : </span>
<span id="L3128"><span class="lineNum">    3128</span>                 :<span class="tlaGNC tlaBgGNC">         170 : void CConnman::SetNetworkActive(bool active)</span></span>
<span id="L3129"><span class="lineNum">    3129</span>                 :             : {</span>
<span id="L3130"><span class="lineNum">    3130</span>                 :<span class="tlaGNC">         170 :     LogPrintf(&quot;%s: %s\n&quot;, __func__, active);</span></span>
<span id="L3131"><span class="lineNum">    3131</span>                 :             : </span>
<span id="L3132"><span class="lineNum">    3132</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         170 :     if (fNetworkActive == active) {</span></span>
<span id="L3133"><span class="lineNum">    3133</span>                 :             :         return;</span>
<span id="L3134"><span class="lineNum">    3134</span>                 :             :     }</span>
<span id="L3135"><span class="lineNum">    3135</span>                 :             : </span>
<span id="L3136"><span class="lineNum">    3136</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     fNetworkActive = active;</span></span>
<span id="L3137"><span class="lineNum">    3137</span>                 :             : </span>
<span id="L3138"><span class="lineNum">    3138</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     if (m_client_interface) {</span></span>
<span id="L3139"><span class="lineNum">    3139</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         m_client_interface-&gt;NotifyNetworkActiveChanged(fNetworkActive);</span></span>
<span id="L3140"><span class="lineNum">    3140</span>                 :             :     }</span>
<span id="L3141"><span class="lineNum">    3141</span>                 :             : }</span>
<span id="L3142"><span class="lineNum">    3142</span>                 :             : </span>
<span id="L3143"><span class="lineNum">    3143</span>                 :<span class="tlaGNC tlaBgGNC">         168 : CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan&amp; addrman_in,</span></span>
<span id="L3144"><span class="lineNum">    3144</span>                 :<span class="tlaGNC">         168 :                    const NetGroupManager&amp; netgroupman, const CChainParams&amp; params, bool network_active)</span></span>
<span id="L3145"><span class="lineNum">    3145</span>                 :<span class="tlaGNC">         168 :     : addrman(addrman_in)</span></span>
<span id="L3146"><span class="lineNum">    3146</span>         [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         168 :     , m_netgroupman{netgroupman}</span></span>
<span id="L3147"><span class="lineNum">    3147</span>                 :<span class="tlaGNC">         168 :     , nSeed0(nSeed0In)</span></span>
<span id="L3148"><span class="lineNum">    3148</span>                 :<span class="tlaGNC">         168 :     , nSeed1(nSeed1In)</span></span>
<span id="L3149"><span class="lineNum">    3149</span>   [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">         168 :     , m_params(params)</span></span>
<span class="lineNum">        </span>    <span class="tlaGBC" title="Branch 4 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L3150"><span class="lineNum">    3150</span>                 :             : {</span>
<span id="L3151"><span class="lineNum">    3151</span>         [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         168 :     SetTryNewOutboundPeer(false);</span></span>
<span id="L3152"><span class="lineNum">    3152</span>                 :             : </span>
<span id="L3153"><span class="lineNum">    3153</span>                 :<span class="tlaGNC">         168 :     Options connOptions;</span></span>
<span id="L3154"><span class="lineNum">    3154</span>         [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         168 :     Init(connOptions);</span></span>
<span id="L3155"><span class="lineNum">    3155</span>         [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         168 :     SetNetworkActive(network_active);</span></span>
<span id="L3156"><span class="lineNum">    3156</span>                 :<span class="tlaGNC">         168 : }</span></span>
<span id="L3157"><span class="lineNum">    3157</span>                 :             : </span>
<span id="L3158"><span class="lineNum">    3158</span>                 :<span class="tlaUNC tlaBgUNC">           0 : NodeId CConnman::GetNewNodeId()</span></span>
<span id="L3159"><span class="lineNum">    3159</span>                 :             : {</span>
<span id="L3160"><span class="lineNum">    3160</span>                 :<span class="tlaUNC">           0 :     return nLastNodeId.fetch_add(1, std::memory_order_relaxed);</span></span>
<span id="L3161"><span class="lineNum">    3161</span>                 :             : }</span>
<span id="L3162"><span class="lineNum">    3162</span>                 :             : </span>
<span id="L3163"><span class="lineNum">    3163</span>                 :<span class="tlaUNC">           0 : uint16_t CConnman::GetDefaultPort(Network net) const</span></span>
<span id="L3164"><span class="lineNum">    3164</span>                 :             : {</span>
<span id="L3165"><span class="lineNum">    3165</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return net == NET_I2P ? I2P_SAM31_PORT : m_params.GetDefaultPort();</span></span>
<span id="L3166"><span class="lineNum">    3166</span>                 :             : }</span>
<span id="L3167"><span class="lineNum">    3167</span>                 :             : </span>
<span id="L3168"><span class="lineNum">    3168</span>                 :<span class="tlaGNC tlaBgGNC">          44 : uint16_t CConnman::GetDefaultPort(const std::string&amp; addr) const</span></span>
<span id="L3169"><span class="lineNum">    3169</span>                 :             : {</span>
<span id="L3170"><span class="lineNum">    3170</span>                 :<span class="tlaGNC">          44 :     CNetAddr a;</span></span>
<span id="L3171"><span class="lineNum">    3171</span>   [<span class="tlaGBC" title="Branch 0 was taken 44 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 44 times"> + </span> :<span class="tlaGNC">          44 :     return a.SetSpecial(addr) ? GetDefaultPort(a.GetNetwork()) : m_params.GetDefaultPort();</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span>]
<span id="L3172"><span class="lineNum">    3172</span>                 :<span class="tlaGNC">          44 : }</span></span>
<span id="L3173"><span class="lineNum">    3173</span>                 :             : </span>
<span id="L3174"><span class="lineNum">    3174</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::Bind(const CService&amp; addr_, unsigned int flags, NetPermissionFlags permissions)</span></span>
<span id="L3175"><span class="lineNum">    3175</span>                 :             : {</span>
<span id="L3176"><span class="lineNum">    3176</span>                 :<span class="tlaUNC">           0 :     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};</span></span>
<span id="L3177"><span class="lineNum">    3177</span>                 :             : </span>
<span id="L3178"><span class="lineNum">    3178</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     bilingual_str strError;</span></span>
<span id="L3179"><span class="lineNum">    3179</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!BindListenPort(addr, strError, permissions)) {</span></span>
<span id="L3180"><span class="lineNum">    3180</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if ((flags &amp; BF_REPORT_ERROR) &amp;&amp; m_client_interface) {</span></span>
<span id="L3181"><span class="lineNum">    3181</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             m_client_interface-&gt;ThreadSafeMessageBox(strError, &quot;&quot;, CClientUIInterface::MSG_ERROR);</span></span>
<span id="L3182"><span class="lineNum">    3182</span>                 :             :         }</span>
<span id="L3183"><span class="lineNum">    3183</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3184"><span class="lineNum">    3184</span>                 :             :     }</span>
<span id="L3185"><span class="lineNum">    3185</span>                 :             : </span>
<span id="L3186"><span class="lineNum">    3186</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     if (addr.IsRoutable() &amp;&amp; fDiscover &amp;&amp; !(flags &amp; BF_DONT_ADVERTISE) &amp;&amp; !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L3187"><span class="lineNum">    3187</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         AddLocal(addr, LOCAL_BIND);</span></span>
<span id="L3188"><span class="lineNum">    3188</span>                 :             :     }</span>
<span id="L3189"><span class="lineNum">    3189</span>                 :             : </span>
<span id="L3190"><span class="lineNum">    3190</span>                 :             :     return true;</span>
<span id="L3191"><span class="lineNum">    3191</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3192"><span class="lineNum">    3192</span>                 :             : </span>
<span id="L3193"><span class="lineNum">    3193</span>                 :<span class="tlaUNC">           0 : bool CConnman::InitBinds(const Options&amp; options)</span></span>
<span id="L3194"><span class="lineNum">    3194</span>                 :             : {</span>
<span id="L3195"><span class="lineNum">    3195</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const auto&amp; addrBind : options.vBinds) {</span></span>
<span id="L3196"><span class="lineNum">    3196</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!Bind(addrBind, BF_REPORT_ERROR, NetPermissionFlags::None)) {</span></span>
<span id="L3197"><span class="lineNum">    3197</span>                 :             :             return false;</span>
<span id="L3198"><span class="lineNum">    3198</span>                 :             :         }</span>
<span id="L3199"><span class="lineNum">    3199</span>                 :             :     }</span>
<span id="L3200"><span class="lineNum">    3200</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const auto&amp; addrBind : options.vWhiteBinds) {</span></span>
<span id="L3201"><span class="lineNum">    3201</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!Bind(addrBind.m_service, BF_REPORT_ERROR, addrBind.m_flags)) {</span></span>
<span id="L3202"><span class="lineNum">    3202</span>                 :             :             return false;</span>
<span id="L3203"><span class="lineNum">    3203</span>                 :             :         }</span>
<span id="L3204"><span class="lineNum">    3204</span>                 :             :     }</span>
<span id="L3205"><span class="lineNum">    3205</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const auto&amp; addr_bind : options.onion_binds) {</span></span>
<span id="L3206"><span class="lineNum">    3206</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!Bind(addr_bind, BF_REPORT_ERROR | BF_DONT_ADVERTISE, NetPermissionFlags::None)) {</span></span>
<span id="L3207"><span class="lineNum">    3207</span>                 :             :             return false;</span>
<span id="L3208"><span class="lineNum">    3208</span>                 :             :         }</span>
<span id="L3209"><span class="lineNum">    3209</span>                 :             :     }</span>
<span id="L3210"><span class="lineNum">    3210</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (options.bind_on_any) {</span></span>
<span id="L3211"><span class="lineNum">    3211</span>                 :             :         // Don't consider errors to bind on IPv6 &quot;::&quot; fatal because the host OS</span>
<span id="L3212"><span class="lineNum">    3212</span>                 :             :         // may not have IPv6 support and the user did not explicitly ask us to</span>
<span id="L3213"><span class="lineNum">    3213</span>                 :             :         // bind on that.</span>
<span id="L3214"><span class="lineNum">    3214</span>                 :<span class="tlaUNC">           0 :         const CService ipv6_any{in6_addr(IN6ADDR_ANY_INIT), GetListenPort()}; // ::</span></span>
<span id="L3215"><span class="lineNum">    3215</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         Bind(ipv6_any, BF_NONE, NetPermissionFlags::None);</span></span>
<span id="L3216"><span class="lineNum">    3216</span>                 :             : </span>
<span id="L3217"><span class="lineNum">    3217</span>                 :<span class="tlaUNC">           0 :         struct in_addr inaddr_any;</span></span>
<span id="L3218"><span class="lineNum">    3218</span>                 :<span class="tlaUNC">           0 :         inaddr_any.s_addr = htonl(INADDR_ANY);</span></span>
<span id="L3219"><span class="lineNum">    3219</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const CService ipv4_any{inaddr_any, GetListenPort()}; // 0.0.0.0</span></span>
<span id="L3220"><span class="lineNum">    3220</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!Bind(ipv4_any, BF_REPORT_ERROR, NetPermissionFlags::None)) {</span></span>
<span id="L3221"><span class="lineNum">    3221</span>                 :<span class="tlaUNC">           0 :             return false;</span></span>
<span id="L3222"><span class="lineNum">    3222</span>                 :             :         }</span>
<span id="L3223"><span class="lineNum">    3223</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L3224"><span class="lineNum">    3224</span>                 :             :     return true;</span>
<span id="L3225"><span class="lineNum">    3225</span>                 :             : }</span>
<span id="L3226"><span class="lineNum">    3226</span>                 :             : </span>
<span id="L3227"><span class="lineNum">    3227</span>                 :<span class="tlaUNC">           0 : bool CConnman::Start(CScheduler&amp; scheduler, const Options&amp; connOptions)</span></span>
<span id="L3228"><span class="lineNum">    3228</span>                 :             : {</span>
<span id="L3229"><span class="lineNum">    3229</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3230"><span class="lineNum">    3230</span>                 :<span class="tlaUNC">           0 :     Init(connOptions);</span></span>
<span id="L3231"><span class="lineNum">    3231</span>                 :             : </span>
<span id="L3232"><span class="lineNum">    3232</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (fListen &amp;&amp; !InitBinds(connOptions)) {</span></span>
<span id="L3233"><span class="lineNum">    3233</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (m_client_interface) {</span></span>
<span id="L3234"><span class="lineNum">    3234</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             m_client_interface-&gt;ThreadSafeMessageBox(</span></span>
<span id="L3235"><span class="lineNum">    3235</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 _(&quot;Failed to listen on any port. Use -listen=0 if you want this.&quot;),</span></span>
<span id="L3236"><span class="lineNum">    3236</span>                 :             :                 &quot;&quot;, CClientUIInterface::MSG_ERROR);</span>
<span id="L3237"><span class="lineNum">    3237</span>                 :             :         }</span>
<span id="L3238"><span class="lineNum">    3238</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3239"><span class="lineNum">    3239</span>                 :             :     }</span>
<span id="L3240"><span class="lineNum">    3240</span>                 :             : </span>
<span id="L3241"><span class="lineNum">    3241</span>                 :<span class="tlaUNC">           0 :     Proxy i2p_sam;</span></span>
<span id="L3242"><span class="lineNum">    3242</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     if (GetProxy(NET_I2P, i2p_sam) &amp;&amp; connOptions.m_i2p_accept_incoming) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3243"><span class="lineNum">    3243</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         m_i2p_sam_session = std::make_unique&lt;i2p::sam::Session&gt;(gArgs.GetDataDirNet() / &quot;i2p_private_key&quot;,</span></span>
<span id="L3244"><span class="lineNum">    3244</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                                                                 i2p_sam, &amp;interruptNet);</span></span>
<span id="L3245"><span class="lineNum">    3245</span>                 :             :     }</span>
<span id="L3246"><span class="lineNum">    3246</span>                 :             : </span>
<span id="L3247"><span class="lineNum">    3247</span>                 :             :     // Randomize the order in which we may query seednode to potentially prevent connecting to the same one every restart (and signal that we have restarted)</span>
<span id="L3248"><span class="lineNum">    3248</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::vector&lt;std::string&gt; seed_nodes = connOptions.vSeedNodes;</span></span>
<span id="L3249"><span class="lineNum">    3249</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (!seed_nodes.empty()) {</span></span>
<span id="L3250"><span class="lineNum">    3250</span>                 :<span class="tlaUNC">           0 :         std::shuffle(seed_nodes.begin(), seed_nodes.end(), FastRandomContext{});</span></span>
<span id="L3251"><span class="lineNum">    3251</span>                 :             :     }</span>
<span id="L3252"><span class="lineNum">    3252</span>                 :             : </span>
<span id="L3253"><span class="lineNum">    3253</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_use_addrman_outgoing) {</span></span>
<span id="L3254"><span class="lineNum">    3254</span>                 :             :         // Load addresses from anchors.dat</span>
<span id="L3255"><span class="lineNum">    3255</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         m_anchors = ReadAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3256"><span class="lineNum">    3256</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (m_anchors.size() &gt; MAX_BLOCK_RELAY_ONLY_ANCHORS) {</span></span>
<span id="L3257"><span class="lineNum">    3257</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);</span></span>
<span id="L3258"><span class="lineNum">    3258</span>                 :             :         }</span>
<span id="L3259"><span class="lineNum">    3259</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;%i block-relay-only anchors will be tried for connections.\n&quot;, m_anchors.size());</span></span>
<span id="L3260"><span class="lineNum">    3260</span>                 :             :     }</span>
<span id="L3261"><span class="lineNum">    3261</span>                 :             : </span>
<span id="L3262"><span class="lineNum">    3262</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_client_interface) {</span></span>
<span id="L3263"><span class="lineNum">    3263</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         m_client_interface-&gt;InitMessage(_(&quot;Starting network threads…&quot;).translated);</span></span>
<span id="L3264"><span class="lineNum">    3264</span>                 :             :     }</span>
<span id="L3265"><span class="lineNum">    3265</span>                 :             : </span>
<span id="L3266"><span class="lineNum">    3266</span>                 :<span class="tlaUNC">           0 :     fAddressesInitialized = true;</span></span>
<span id="L3267"><span class="lineNum">    3267</span>                 :             : </span>
<span id="L3268"><span class="lineNum">    3268</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (semOutbound == nullptr) {</span></span>
<span id="L3269"><span class="lineNum">    3269</span>                 :             :         // initialize semaphore</span>
<span id="L3270"><span class="lineNum">    3270</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         semOutbound = std::make_unique&lt;CSemaphore&gt;(std::min(m_max_automatic_outbound, m_max_automatic_connections));</span></span>
<span id="L3271"><span class="lineNum">    3271</span>                 :             :     }</span>
<span id="L3272"><span class="lineNum">    3272</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (semAddnode == nullptr) {</span></span>
<span id="L3273"><span class="lineNum">    3273</span>                 :             :         // initialize semaphore</span>
<span id="L3274"><span class="lineNum">    3274</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         semAddnode = std::make_unique&lt;CSemaphore&gt;(m_max_addnode);</span></span>
<span id="L3275"><span class="lineNum">    3275</span>                 :             :     }</span>
<span id="L3276"><span class="lineNum">    3276</span>                 :             : </span>
<span id="L3277"><span class="lineNum">    3277</span>                 :             :     //</span>
<span id="L3278"><span class="lineNum">    3278</span>                 :             :     // Start threads</span>
<span id="L3279"><span class="lineNum">    3279</span>                 :             :     //</span>
<span id="L3280"><span class="lineNum">    3280</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert(m_msgproc);</span></span>
<span id="L3281"><span class="lineNum">    3281</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     interruptNet.reset();</span></span>
<span id="L3282"><span class="lineNum">    3282</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     flagInterruptMsgProc = false;</span></span>
<span id="L3283"><span class="lineNum">    3283</span>                 :             : </span>
<span id="L3284"><span class="lineNum">    3284</span>                 :<span class="tlaUNC">           0 :     {</span></span>
<span id="L3285"><span class="lineNum">    3285</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LOCK(mutexMsgProc);</span></span>
<span id="L3286"><span class="lineNum">    3286</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         fMsgProcWake = false;</span></span>
<span id="L3287"><span class="lineNum">    3287</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L3288"><span class="lineNum">    3288</span>                 :             : </span>
<span id="L3289"><span class="lineNum">    3289</span>                 :             :     // Send and receive from sockets, accept connections</span>
<span id="L3290"><span class="lineNum">    3290</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     threadSocketHandler = std::thread(&amp;util::TraceThread, &quot;net&quot;, [this] { ThreadSocketHandler(); });</span></span>
<span id="L3291"><span class="lineNum">    3291</span>                 :             : </span>
<span id="L3292"><span class="lineNum">    3292</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     if (!gArgs.GetBoolArg(&quot;-dnsseed&quot;, DEFAULT_DNSSEED))</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3293"><span class="lineNum">    3293</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         LogPrintf(&quot;DNS seeding disabled\n&quot;);</span></span>
<span id="L3294"><span class="lineNum">    3294</span>                 :             :     else</span>
<span id="L3295"><span class="lineNum">    3295</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         threadDNSAddressSeed = std::thread(&amp;util::TraceThread, &quot;dnsseed&quot;, [this] { ThreadDNSAddressSeed(); });</span></span>
<span id="L3296"><span class="lineNum">    3296</span>                 :             : </span>
<span id="L3297"><span class="lineNum">    3297</span>                 :             :     // Initiate manual connections</span>
<span id="L3298"><span class="lineNum">    3298</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     threadOpenAddedConnections = std::thread(&amp;util::TraceThread, &quot;addcon&quot;, [this] { ThreadOpenAddedConnections(); });</span></span>
<span id="L3299"><span class="lineNum">    3299</span>                 :             : </span>
<span id="L3300"><span class="lineNum">    3300</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (connOptions.m_use_addrman_outgoing &amp;&amp; !connOptions.m_specified_outgoing.empty()) {</span></span>
<span id="L3301"><span class="lineNum">    3301</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (m_client_interface) {</span></span>
<span id="L3302"><span class="lineNum">    3302</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             m_client_interface-&gt;ThreadSafeMessageBox(</span></span>
<span id="L3303"><span class="lineNum">    3303</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 _(&quot;Cannot provide specific connections and have addrman find outgoing connections at the same time.&quot;),</span></span>
<span id="L3304"><span class="lineNum">    3304</span>                 :             :                 &quot;&quot;, CClientUIInterface::MSG_ERROR);</span>
<span id="L3305"><span class="lineNum">    3305</span>                 :             :         }</span>
<span id="L3306"><span class="lineNum">    3306</span>                 :<span class="tlaUNC">           0 :         return false;</span></span>
<span id="L3307"><span class="lineNum">    3307</span>                 :             :     }</span>
<span id="L3308"><span class="lineNum">    3308</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty()) {</span></span>
<span id="L3309"><span class="lineNum">    3309</span>                 :<span class="tlaUNC">           0 :         threadOpenConnections = std::thread(</span></span>
<span id="L3310"><span class="lineNum">    3310</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             &amp;util::TraceThread, &quot;opencon&quot;,</span></span>
<span id="L3311"><span class="lineNum">    3311</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             [this, connect = connOptions.m_specified_outgoing, seed_nodes = std::move(seed_nodes)] { ThreadOpenConnections(connect, seed_nodes); });</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3312"><span class="lineNum">    3312</span>                 :             :     }</span>
<span id="L3313"><span class="lineNum">    3313</span>                 :             : </span>
<span id="L3314"><span class="lineNum">    3314</span>                 :             :     // Process messages</span>
<span id="L3315"><span class="lineNum">    3315</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     threadMessageHandler = std::thread(&amp;util::TraceThread, &quot;msghand&quot;, [this] { ThreadMessageHandler(); });</span></span>
<span id="L3316"><span class="lineNum">    3316</span>                 :             : </span>
<span id="L3317"><span class="lineNum">    3317</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_i2p_sam_session) {</span></span>
<span id="L3318"><span class="lineNum">    3318</span>                 :<span class="tlaUNC">           0 :         threadI2PAcceptIncoming =</span></span>
<span id="L3319"><span class="lineNum">    3319</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             std::thread(&amp;util::TraceThread, &quot;i2paccept&quot;, [this] { ThreadI2PAcceptIncoming(); });</span></span>
<span id="L3320"><span class="lineNum">    3320</span>                 :             :     }</span>
<span id="L3321"><span class="lineNum">    3321</span>                 :             : </span>
<span id="L3322"><span class="lineNum">    3322</span>                 :             :     // Dump network addresses</span>
<span id="L3323"><span class="lineNum">    3323</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     scheduler.scheduleEvery([this] { DumpAddresses(); }, DUMP_PEERS_INTERVAL);</span></span>
<span id="L3324"><span class="lineNum">    3324</span>                 :             : </span>
<span id="L3325"><span class="lineNum">    3325</span>                 :             :     // Run the ASMap Health check once and then schedule it to run every 24h.</span>
<span id="L3326"><span class="lineNum">    3326</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_netgroupman.UsingASMap()) {</span></span>
<span id="L3327"><span class="lineNum">    3327</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         ASMapHealthCheck();</span></span>
<span id="L3328"><span class="lineNum">    3328</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         scheduler.scheduleEvery([this] { ASMapHealthCheck(); }, ASMAP_HEALTH_CHECK_INTERVAL);</span></span>
<span id="L3329"><span class="lineNum">    3329</span>                 :             :     }</span>
<span id="L3330"><span class="lineNum">    3330</span>                 :             : </span>
<span id="L3331"><span class="lineNum">    3331</span>                 :             :     return true;</span>
<span id="L3332"><span class="lineNum">    3332</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3333"><span class="lineNum">    3333</span>                 :             : </span>
<span id="L3334"><span class="lineNum">    3334</span>                 :             : class CNetCleanup</span>
<span id="L3335"><span class="lineNum">    3335</span>                 :             : {</span>
<span id="L3336"><span class="lineNum">    3336</span>                 :             : public:</span>
<span id="L3337"><span class="lineNum">    3337</span>                 :             :     CNetCleanup() = default;</span>
<span id="L3338"><span class="lineNum">    3338</span>                 :             : </span>
<span id="L3339"><span class="lineNum">    3339</span>                 :<span class="tlaGNC tlaBgGNC">         129 :     ~CNetCleanup()</span></span>
<span id="L3340"><span class="lineNum">    3340</span>                 :             :     {</span>
<span id="L3341"><span class="lineNum">    3341</span>                 :             : #ifdef WIN32</span>
<span id="L3342"><span class="lineNum">    3342</span>                 :             :         // Shutdown Windows Sockets</span>
<span id="L3343"><span class="lineNum">    3343</span>                 :             :         WSACleanup();</span>
<span id="L3344"><span class="lineNum">    3344</span>                 :             : #endif</span>
<span id="L3345"><span class="lineNum">    3345</span>                 :<span class="tlaGNC">         129 :     }</span></span>
<span id="L3346"><span class="lineNum">    3346</span>                 :             : };</span>
<span id="L3347"><span class="lineNum">    3347</span>                 :             : static CNetCleanup instance_of_cnetcleanup;</span>
<span id="L3348"><span class="lineNum">    3348</span>                 :             : </span>
<span id="L3349"><span class="lineNum">    3349</span>                 :<span class="tlaGNC">         168 : void CConnman::Interrupt()</span></span>
<span id="L3350"><span class="lineNum">    3350</span>                 :             : {</span>
<span id="L3351"><span class="lineNum">    3351</span>                 :<span class="tlaGNC">         168 :     {</span></span>
<span id="L3352"><span class="lineNum">    3352</span>                 :<span class="tlaGNC">         168 :         LOCK(mutexMsgProc);</span></span>
<span id="L3353"><span class="lineNum">    3353</span>         [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">         168 :         flagInterruptMsgProc = true;</span></span>
<span id="L3354"><span class="lineNum">    3354</span>                 :<span class="tlaGNC">         168 :     }</span></span>
<span id="L3355"><span class="lineNum">    3355</span>                 :<span class="tlaGNC">         168 :     condMsgProc.notify_all();</span></span>
<span id="L3356"><span class="lineNum">    3356</span>                 :             : </span>
<span id="L3357"><span class="lineNum">    3357</span>                 :<span class="tlaGNC">         168 :     interruptNet();</span></span>
<span id="L3358"><span class="lineNum">    3358</span>                 :<span class="tlaGNC">         168 :     g_socks5_interrupt();</span></span>
<span id="L3359"><span class="lineNum">    3359</span>                 :             : </span>
<span id="L3360"><span class="lineNum">    3360</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         168 :     if (semOutbound) {</span></span>
<span id="L3361"><span class="lineNum">    3361</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         for (int i=0; i&lt;m_max_automatic_outbound; i++) {</span></span>
<span id="L3362"><span class="lineNum">    3362</span>                 :<span class="tlaUNC">           0 :             semOutbound-&gt;post();</span></span>
<span id="L3363"><span class="lineNum">    3363</span>                 :             :         }</span>
<span id="L3364"><span class="lineNum">    3364</span>                 :             :     }</span>
<span id="L3365"><span class="lineNum">    3365</span>                 :             : </span>
<span id="L3366"><span class="lineNum">    3366</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     if (semAddnode) {</span></span>
<span id="L3367"><span class="lineNum">    3367</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         for (int i=0; i&lt;m_max_addnode; i++) {</span></span>
<span id="L3368"><span class="lineNum">    3368</span>                 :<span class="tlaUNC">           0 :             semAddnode-&gt;post();</span></span>
<span id="L3369"><span class="lineNum">    3369</span>                 :             :         }</span>
<span id="L3370"><span class="lineNum">    3370</span>                 :             :     }</span>
<span id="L3371"><span class="lineNum">    3371</span>                 :<span class="tlaGNC tlaBgGNC">         168 : }</span></span>
<span id="L3372"><span class="lineNum">    3372</span>                 :             : </span>
<span id="L3373"><span class="lineNum">    3373</span>                 :<span class="tlaGNC">         168 : void CConnman::StopThreads()</span></span>
<span id="L3374"><span class="lineNum">    3374</span>                 :             : {</span>
<span id="L3375"><span class="lineNum">    3375</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         168 :     if (threadI2PAcceptIncoming.joinable()) {</span></span>
<span id="L3376"><span class="lineNum">    3376</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         threadI2PAcceptIncoming.join();</span></span>
<span id="L3377"><span class="lineNum">    3377</span>                 :             :     }</span>
<span id="L3378"><span class="lineNum">    3378</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     if (threadMessageHandler.joinable())</span></span>
<span id="L3379"><span class="lineNum">    3379</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         threadMessageHandler.join();</span></span>
<span id="L3380"><span class="lineNum">    3380</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     if (threadOpenConnections.joinable())</span></span>
<span id="L3381"><span class="lineNum">    3381</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         threadOpenConnections.join();</span></span>
<span id="L3382"><span class="lineNum">    3382</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     if (threadOpenAddedConnections.joinable())</span></span>
<span id="L3383"><span class="lineNum">    3383</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         threadOpenAddedConnections.join();</span></span>
<span id="L3384"><span class="lineNum">    3384</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     if (threadDNSAddressSeed.joinable())</span></span>
<span id="L3385"><span class="lineNum">    3385</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         threadDNSAddressSeed.join();</span></span>
<span id="L3386"><span class="lineNum">    3386</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     if (threadSocketHandler.joinable())</span></span>
<span id="L3387"><span class="lineNum">    3387</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         threadSocketHandler.join();</span></span>
<span id="L3388"><span class="lineNum">    3388</span>                 :<span class="tlaGNC tlaBgGNC">         168 : }</span></span>
<span id="L3389"><span class="lineNum">    3389</span>                 :             : </span>
<span id="L3390"><span class="lineNum">    3390</span>                 :<span class="tlaGNC">         168 : void CConnman::StopNodes()</span></span>
<span id="L3391"><span class="lineNum">    3391</span>                 :             : {</span>
<span id="L3392"><span class="lineNum">    3392</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         168 :     if (fAddressesInitialized) {</span></span>
<span id="L3393"><span class="lineNum">    3393</span>                 :<span class="tlaUNC tlaBgUNC">           0 :         DumpAddresses();</span></span>
<span id="L3394"><span class="lineNum">    3394</span>                 :<span class="tlaUNC">           0 :         fAddressesInitialized = false;</span></span>
<span id="L3395"><span class="lineNum">    3395</span>                 :             : </span>
<span id="L3396"><span class="lineNum">    3396</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (m_use_addrman_outgoing) {</span></span>
<span id="L3397"><span class="lineNum">    3397</span>                 :             :             // Anchor connections are only dumped during clean shutdown.</span>
<span id="L3398"><span class="lineNum">    3398</span>                 :<span class="tlaUNC">           0 :             std::vector&lt;CAddress&gt; anchors_to_dump = GetCurrentBlockRelayOnlyConns();</span></span>
<span id="L3399"><span class="lineNum">    3399</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (anchors_to_dump.size() &gt; MAX_BLOCK_RELAY_ONLY_ANCHORS) {</span></span>
<span id="L3400"><span class="lineNum">    3400</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 anchors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);</span></span>
<span id="L3401"><span class="lineNum">    3401</span>                 :             :             }</span>
<span id="L3402"><span class="lineNum">    3402</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             DumpAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3403"><span class="lineNum">    3403</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L3404"><span class="lineNum">    3404</span>                 :             :     }</span>
<span id="L3405"><span class="lineNum">    3405</span>                 :             : </span>
<span id="L3406"><span class="lineNum">    3406</span>                 :             :     // Delete peer connections.</span>
<span id="L3407"><span class="lineNum">    3407</span>                 :<span class="tlaGNC tlaBgGNC">         168 :     std::vector&lt;CNode*&gt; nodes;</span></span>
<span id="L3408"><span class="lineNum">    3408</span>   [<span class="tlaGBC" title="Branch 0 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 168 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">         336 :     WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));</span></span>
<span id="L3409"><span class="lineNum">    3409</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         168 :     for (CNode* pnode : nodes) {</span></span>
<span id="L3410"><span class="lineNum">    3410</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         pnode-&gt;CloseSocketDisconnect();</span></span>
<span id="L3411"><span class="lineNum">    3411</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         DeleteNode(pnode);</span></span>
<span id="L3412"><span class="lineNum">    3412</span>                 :             :     }</span>
<span id="L3413"><span class="lineNum">    3413</span>                 :             : </span>
<span id="L3414"><span class="lineNum">    3414</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC tlaBgGNC">         168 :     for (CNode* pnode : m_nodes_disconnected) {</span></span>
<span id="L3415"><span class="lineNum">    3415</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         DeleteNode(pnode);</span></span>
<span id="L3416"><span class="lineNum">    3416</span>                 :             :     }</span>
<span id="L3417"><span class="lineNum">    3417</span>                 :<span class="tlaGNC tlaBgGNC">         168 :     m_nodes_disconnected.clear();</span></span>
<span id="L3418"><span class="lineNum">    3418</span>                 :<span class="tlaGNC">         168 :     vhListenSocket.clear();</span></span>
<span id="L3419"><span class="lineNum">    3419</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         168 :     semOutbound.reset();</span></span>
<span id="L3420"><span class="lineNum">    3420</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 168 times"> + </span>]:<span class="tlaGNC">         168 :     semAddnode.reset();</span></span>
<span id="L3421"><span class="lineNum">    3421</span>                 :<span class="tlaGNC">         168 : }</span></span>
<span id="L3422"><span class="lineNum">    3422</span>                 :             : </span>
<span id="L3423"><span class="lineNum">    3423</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CConnman::DeleteNode(CNode* pnode)</span></span>
<span id="L3424"><span class="lineNum">    3424</span>                 :             : {</span>
<span id="L3425"><span class="lineNum">    3425</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert(pnode);</span></span>
<span id="L3426"><span class="lineNum">    3426</span>                 :<span class="tlaUNC">           0 :     m_msgproc-&gt;FinalizeNode(*pnode);</span></span>
<span id="L3427"><span class="lineNum">    3427</span>                 :<span class="tlaUNC">           0 :     delete pnode;</span></span>
<span id="L3428"><span class="lineNum">    3428</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3429"><span class="lineNum">    3429</span>                 :             : </span>
<span id="L3430"><span class="lineNum">    3430</span>                 :<span class="tlaGNC tlaBgGNC">         168 : CConnman::~CConnman()</span></span>
<span id="L3431"><span class="lineNum">    3431</span>                 :             : {</span>
<span id="L3432"><span class="lineNum">    3432</span>                 :<span class="tlaGNC">         168 :     Interrupt();</span></span>
<span id="L3433"><span class="lineNum">    3433</span>                 :<span class="tlaGNC">         168 :     Stop();</span></span>
<span id="L3434"><span class="lineNum">    3434</span>                 :<span class="tlaGNC">         168 : }</span></span>
<span id="L3435"><span class="lineNum">    3435</span>                 :             : </span>
<span id="L3436"><span class="lineNum">    3436</span>                 :<span class="tlaUNC tlaBgUNC">           0 : std::vector&lt;CAddress&gt; CConnman::GetAddresses(size_t max_addresses, size_t max_pct, std::optional&lt;Network&gt; network, const bool filtered) const</span></span>
<span id="L3437"><span class="lineNum">    3437</span>                 :             : {</span>
<span id="L3438"><span class="lineNum">    3438</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;CAddress&gt; addresses = addrman.GetAddr(max_addresses, max_pct, network, filtered);</span></span>
<span id="L3439"><span class="lineNum">    3439</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_banman) {</span></span>
<span id="L3440"><span class="lineNum">    3440</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         addresses.erase(std::remove_if(addresses.begin(), addresses.end(),</span></span>
<span id="L3441"><span class="lineNum">    3441</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         [this](const CAddress&amp; addr){return m_banman-&gt;IsDiscouraged(addr) || m_banman-&gt;IsBanned(addr);}),</span></span>
<span id="L3442"><span class="lineNum">    3442</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         addresses.end());</span></span>
<span id="L3443"><span class="lineNum">    3443</span>                 :             :     }</span>
<span id="L3444"><span class="lineNum">    3444</span>                 :<span class="tlaUNC">           0 :     return addresses;</span></span>
<span id="L3445"><span class="lineNum">    3445</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3446"><span class="lineNum">    3446</span>                 :             : </span>
<span id="L3447"><span class="lineNum">    3447</span>                 :<span class="tlaUNC">           0 : std::vector&lt;CAddress&gt; CConnman::GetAddresses(CNode&amp; requestor, size_t max_addresses, size_t max_pct)</span></span>
<span id="L3448"><span class="lineNum">    3448</span>                 :             : {</span>
<span id="L3449"><span class="lineNum">    3449</span>                 :<span class="tlaUNC">           0 :     auto local_socket_bytes = requestor.addrBind.GetAddrBytes();</span></span>
<span id="L3450"><span class="lineNum">    3450</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)</span></span>
<span id="L3451"><span class="lineNum">    3451</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         .Write(requestor.ConnectedThroughNetwork())</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3452"><span class="lineNum">    3452</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         .Write(local_socket_bytes)</span></span>
<span id="L3453"><span class="lineNum">    3453</span>                 :             :         // For outbound connections, the port of the bound address is randomly</span>
<span id="L3454"><span class="lineNum">    3454</span>                 :             :         // assigned by the OS and would therefore not be useful for seeding.</span>
<span id="L3455"><span class="lineNum">    3455</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         .Write(requestor.IsInboundConn() ? requestor.addrBind.GetPort() : 0)</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3456"><span class="lineNum">    3456</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         .Finalize();</span></span>
<span id="L3457"><span class="lineNum">    3457</span>                 :<span class="tlaUNC">           0 :     const auto current_time = GetTime&lt;std::chrono::microseconds&gt;();</span></span>
<span id="L3458"><span class="lineNum">    3458</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});</span></span>
<span id="L3459"><span class="lineNum">    3459</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     CachedAddrResponse&amp; cache_entry = r.first-&gt;second;</span></span>
<span id="L3460"><span class="lineNum">    3460</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (cache_entry.m_cache_entry_expiration &lt; current_time) { // If emplace() added new one it has expiration 0.</span></span>
<span id="L3461"><span class="lineNum">    3461</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /*network=*/std::nullopt);</span></span>
<span id="L3462"><span class="lineNum">    3462</span>                 :             :         // Choosing a proper cache lifetime is a trade-off between the privacy leak minimization</span>
<span id="L3463"><span class="lineNum">    3463</span>                 :             :         // and the usefulness of ADDR responses to honest users.</span>
<span id="L3464"><span class="lineNum">    3464</span>                 :             :         //</span>
<span id="L3465"><span class="lineNum">    3465</span>                 :             :         // Longer cache lifetime makes it more difficult for an attacker to scrape</span>
<span id="L3466"><span class="lineNum">    3466</span>                 :             :         // enough AddrMan data to maliciously infer something useful.</span>
<span id="L3467"><span class="lineNum">    3467</span>                 :             :         // By the time an attacker scraped enough AddrMan records, most of</span>
<span id="L3468"><span class="lineNum">    3468</span>                 :             :         // the records should be old enough to not leak topology info by</span>
<span id="L3469"><span class="lineNum">    3469</span>                 :             :         // e.g. analyzing real-time changes in timestamps.</span>
<span id="L3470"><span class="lineNum">    3470</span>                 :             :         //</span>
<span id="L3471"><span class="lineNum">    3471</span>                 :             :         // It takes only several hundred requests to scrape everything from an AddrMan containing 100,000 nodes,</span>
<span id="L3472"><span class="lineNum">    3472</span>                 :             :         // so ~24 hours of cache lifetime indeed makes the data less inferable by the time</span>
<span id="L3473"><span class="lineNum">    3473</span>                 :             :         // most of it could be scraped (considering that timestamps are updated via</span>
<span id="L3474"><span class="lineNum">    3474</span>                 :             :         // ADDR self-announcements and when nodes communicate).</span>
<span id="L3475"><span class="lineNum">    3475</span>                 :             :         // We also should be robust to those attacks which may not require scraping *full* victim's AddrMan</span>
<span id="L3476"><span class="lineNum">    3476</span>                 :             :         // (because even several timestamps of the same handful of nodes may leak privacy).</span>
<span id="L3477"><span class="lineNum">    3477</span>                 :             :         //</span>
<span id="L3478"><span class="lineNum">    3478</span>                 :             :         // On the other hand, longer cache lifetime makes ADDR responses</span>
<span id="L3479"><span class="lineNum">    3479</span>                 :             :         // outdated and less useful for an honest requestor, e.g. if most nodes</span>
<span id="L3480"><span class="lineNum">    3480</span>                 :             :         // in the ADDR response are no longer active.</span>
<span id="L3481"><span class="lineNum">    3481</span>                 :             :         //</span>
<span id="L3482"><span class="lineNum">    3482</span>                 :             :         // However, the churn in the network is known to be rather low. Since we consider</span>
<span id="L3483"><span class="lineNum">    3483</span>                 :             :         // nodes to be &quot;terrible&quot; (see IsTerrible()) if the timestamps are older than 30 days,</span>
<span id="L3484"><span class="lineNum">    3484</span>                 :             :         // max. 24 hours of &quot;penalty&quot; due to cache shouldn't make any meaningful difference</span>
<span id="L3485"><span class="lineNum">    3485</span>                 :             :         // in terms of the freshness of the response.</span>
<span id="L3486"><span class="lineNum">    3486</span>                 :<span class="tlaUNC">           0 :         cache_entry.m_cache_entry_expiration = current_time +</span></span>
<span id="L3487"><span class="lineNum">    3487</span>                 :<span class="tlaUNC">           0 :             21h + FastRandomContext().randrange&lt;std::chrono::microseconds&gt;(6h);</span></span>
<span id="L3488"><span class="lineNum">    3488</span>                 :             :     }</span>
<span id="L3489"><span class="lineNum">    3489</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return cache_entry.m_addrs_response_cache;</span></span>
<span id="L3490"><span class="lineNum">    3490</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3491"><span class="lineNum">    3491</span>                 :             : </span>
<span id="L3492"><span class="lineNum">    3492</span>                 :<span class="tlaGNC tlaBgGNC">           7 : bool CConnman::AddNode(const AddedNodeParams&amp; add)</span></span>
<span id="L3493"><span class="lineNum">    3493</span>                 :             : {</span>
<span id="L3494"><span class="lineNum">    3494</span>   [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           7 :     const CService resolved(LookupNumeric(add.m_added_node, GetDefaultPort(add.m_added_node)));</span></span>
<span id="L3495"><span class="lineNum">    3495</span>         [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           7 :     const bool resolved_is_valid{resolved.IsValid()};</span></span>
<span id="L3496"><span class="lineNum">    3496</span>                 :             : </span>
<span id="L3497"><span class="lineNum">    3497</span>         [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           7 :     LOCK(m_added_nodes_mutex);</span></span>
<span id="L3498"><span class="lineNum">    3498</span>         [<span class="tlaGBC" title="Branch 0 was taken 12 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 5 times"> + </span>]:<span class="tlaGNC">          17 :     for (const auto&amp; it : m_added_node_params) {</span></span>
<span id="L3499"><span class="lineNum">    3499</span>   [<span class="tlaGBC" title="Branch 0 was taken 12 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 12 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          36 :         if (add.m_added_node == it.m_added_node || (resolved_is_valid &amp;&amp; resolved == LookupNumeric(it.m_added_node, GetDefaultPort(it.m_added_node)))) return false;</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 12 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 12 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span><span class="tlaGBC" title="Branch 8 was taken 12 times"> + </span> 
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 9 was not taken"> - </span><span class="tlaGBC" title="Branch 10 was taken 12 times"> + </span><span class="tlaUNC" title="Branch 11 was not taken"> - </span><span class="tlaGBC" title="Branch 12 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 13 was taken 10 times"> + </span> 
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 14 was taken 12 times"> + </span><span class="tlaUNC" title="Branch 15 was not taken"> - </span><span class="tlaGBC" title="Branch 16 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 17 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 18 was not taken"> - </span> 
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 19 was not taken"> - </span><span class="tlaUNC" title="Branch 20 was not taken"> - </span><span class="tlaUNC" title="Branch 21 was not taken"> - </span>]
<span id="L3500"><span class="lineNum">    3500</span>                 :             :     }</span>
<span id="L3501"><span class="lineNum">    3501</span>                 :             : </span>
<span id="L3502"><span class="lineNum">    3502</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           5 :     m_added_node_params.push_back(add);</span></span>
<span id="L3503"><span class="lineNum">    3503</span>                 :             :     return true;</span>
<span id="L3504"><span class="lineNum">    3504</span>                 :<span class="tlaGNC">           7 : }</span></span>
<span id="L3505"><span class="lineNum">    3505</span>                 :             : </span>
<span id="L3506"><span class="lineNum">    3506</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::RemoveAddedNode(const std::string&amp; strNode)</span></span>
<span id="L3507"><span class="lineNum">    3507</span>                 :             : {</span>
<span id="L3508"><span class="lineNum">    3508</span>                 :<span class="tlaUNC">           0 :     LOCK(m_added_nodes_mutex);</span></span>
<span id="L3509"><span class="lineNum">    3509</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (auto it = m_added_node_params.begin(); it != m_added_node_params.end(); ++it) {</span></span>
<span id="L3510"><span class="lineNum">    3510</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (strNode == it-&gt;m_added_node) {</span></span>
<span id="L3511"><span class="lineNum">    3511</span>                 :<span class="tlaUNC">           0 :             m_added_node_params.erase(it);</span></span>
<span id="L3512"><span class="lineNum">    3512</span>                 :<span class="tlaUNC">           0 :             return true;</span></span>
<span id="L3513"><span class="lineNum">    3513</span>                 :             :         }</span>
<span id="L3514"><span class="lineNum">    3514</span>                 :             :     }</span>
<span id="L3515"><span class="lineNum">    3515</span>                 :             :     return false;</span>
<span id="L3516"><span class="lineNum">    3516</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3517"><span class="lineNum">    3517</span>                 :             : </span>
<span id="L3518"><span class="lineNum">    3518</span>                 :<span class="tlaGNC tlaBgGNC">           6 : bool CConnman::AddedNodesContain(const CAddress&amp; addr) const</span></span>
<span id="L3519"><span class="lineNum">    3519</span>                 :             : {</span>
<span id="L3520"><span class="lineNum">    3520</span>                 :<span class="tlaGNC">           6 :     AssertLockNotHeld(m_added_nodes_mutex);</span></span>
<span id="L3521"><span class="lineNum">    3521</span>                 :<span class="tlaGNC">           6 :     const std::string addr_str{addr.ToStringAddr()};</span></span>
<span id="L3522"><span class="lineNum">    3522</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :     const std::string addr_port_str{addr.ToStringAddrPort()};</span></span>
<span id="L3523"><span class="lineNum">    3523</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :     LOCK(m_added_nodes_mutex);</span></span>
<span id="L3524"><span class="lineNum">    3524</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :     return (m_added_node_params.size() &lt; 24 // bound the query to a reasonable limit</span></span>
<span id="L3525"><span class="lineNum">    3525</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 3 was taken 5 times"> + </span>]:<span class="tlaGNC">           6 :             &amp;&amp; std::any_of(m_added_node_params.cbegin(), m_added_node_params.cend(),</span></span>
<span id="L3526"><span class="lineNum">    3526</span>   [<span class="tlaGBC" title="Branch 0 was taken 20 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 5 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 15 times"> + </span> :<span class="tlaGNC">          26 :                            [&amp;](const auto&amp; p) { return p.m_added_node == addr_str || p.m_added_node == addr_port_str; }));</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L3527"><span class="lineNum">    3527</span>                 :<span class="tlaGNC">           6 : }</span></span>
<span id="L3528"><span class="lineNum">    3528</span>                 :             : </span>
<span id="L3529"><span class="lineNum">    3529</span>                 :<span class="tlaGNC">           9 : size_t CConnman::GetNodeCount(ConnectionDirection flags) const</span></span>
<span id="L3530"><span class="lineNum">    3530</span>                 :             : {</span>
<span id="L3531"><span class="lineNum">    3531</span>                 :<span class="tlaGNC">           9 :     LOCK(m_nodes_mutex);</span></span>
<span id="L3532"><span class="lineNum">    3532</span>         [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           9 :     if (flags == ConnectionDirection::Both) // Shortcut if we want total</span></span>
<span id="L3533"><span class="lineNum">    3533</span>                 :<span class="tlaGNC">           3 :         return m_nodes.size();</span></span>
<span id="L3534"><span class="lineNum">    3534</span>                 :             : </span>
<span id="L3535"><span class="lineNum">    3535</span>                 :<span class="tlaGNC">           6 :     int nNum = 0;</span></span>
<span id="L3536"><span class="lineNum">    3536</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 6 times"> + </span>]:<span class="tlaGNC">           6 :     for (const auto&amp; pnode : m_nodes) {</span></span>
<span id="L3537"><span class="lineNum">    3537</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         if (flags &amp; (pnode-&gt;IsInboundConn() ? ConnectionDirection::In : ConnectionDirection::Out)) {</span></span>
<span id="L3538"><span class="lineNum">    3538</span>                 :<span class="tlaUNC">           0 :             nNum++;</span></span>
<span id="L3539"><span class="lineNum">    3539</span>                 :             :         }</span>
<span id="L3540"><span class="lineNum">    3540</span>                 :             :     }</span>
<span id="L3541"><span class="lineNum">    3541</span>                 :             : </span>
<span id="L3542"><span class="lineNum">    3542</span>                 :<span class="tlaGNC tlaBgGNC">           6 :     return nNum;</span></span>
<span id="L3543"><span class="lineNum">    3543</span>                 :<span class="tlaGNC">           9 : }</span></span>
<span id="L3544"><span class="lineNum">    3544</span>                 :             : </span>
<span id="L3545"><span class="lineNum">    3545</span>                 :             : </span>
<span id="L3546"><span class="lineNum">    3546</span>                 :<span class="tlaUNC tlaBgUNC">           0 : std::map&lt;CNetAddr, LocalServiceInfo&gt; CConnman::getNetLocalAddresses() const</span></span>
<span id="L3547"><span class="lineNum">    3547</span>                 :             : {</span>
<span id="L3548"><span class="lineNum">    3548</span>                 :<span class="tlaUNC">           0 :     LOCK(g_maplocalhost_mutex);</span></span>
<span id="L3549"><span class="lineNum">    3549</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return mapLocalHost;</span></span>
<span id="L3550"><span class="lineNum">    3550</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3551"><span class="lineNum">    3551</span>                 :             : </span>
<span id="L3552"><span class="lineNum">    3552</span>                 :<span class="tlaGNC tlaBgGNC">           4 : uint32_t CConnman::GetMappedAS(const CNetAddr&amp; addr) const</span></span>
<span id="L3553"><span class="lineNum">    3553</span>                 :             : {</span>
<span id="L3554"><span class="lineNum">    3554</span>                 :<span class="tlaGNC">           4 :     return m_netgroupman.GetMappedAS(addr);</span></span>
<span id="L3555"><span class="lineNum">    3555</span>                 :             : }</span>
<span id="L3556"><span class="lineNum">    3556</span>                 :             : </span>
<span id="L3557"><span class="lineNum">    3557</span>                 :<span class="tlaUNC tlaBgUNC">           0 : void CConnman::GetNodeStats(std::vector&lt;CNodeStats&gt;&amp; vstats) const</span></span>
<span id="L3558"><span class="lineNum">    3558</span>                 :             : {</span>
<span id="L3559"><span class="lineNum">    3559</span>                 :<span class="tlaUNC">           0 :     vstats.clear();</span></span>
<span id="L3560"><span class="lineNum">    3560</span>                 :<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L3561"><span class="lineNum">    3561</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     vstats.reserve(m_nodes.size());</span></span>
<span id="L3562"><span class="lineNum">    3562</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (CNode* pnode : m_nodes) {</span></span>
<span id="L3563"><span class="lineNum">    3563</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         vstats.emplace_back();</span></span>
<span id="L3564"><span class="lineNum">    3564</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         pnode-&gt;CopyStats(vstats.back());</span></span>
<span id="L3565"><span class="lineNum">    3565</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         vstats.back().m_mapped_as = GetMappedAS(pnode-&gt;addr);</span></span>
<span id="L3566"><span class="lineNum">    3566</span>                 :             :     }</span>
<span id="L3567"><span class="lineNum">    3567</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3568"><span class="lineNum">    3568</span>                 :             : </span>
<span id="L3569"><span class="lineNum">    3569</span>                 :<span class="tlaUNC">           0 : bool CConnman::DisconnectNode(const std::string&amp; strNode)</span></span>
<span id="L3570"><span class="lineNum">    3570</span>                 :             : {</span>
<span id="L3571"><span class="lineNum">    3571</span>                 :<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L3572"><span class="lineNum">    3572</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (CNode* pnode = FindNode(strNode)) {</span></span>
<span id="L3573"><span class="lineNum">    3573</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         LogDebug(BCLog::NET, &quot;disconnect by address%s matched peer=%d; disconnecting\n&quot;, (fLogIPs ? strprintf(&quot;=%s&quot;, strNode) : &quot;&quot;), pnode-&gt;GetId());</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>       <span class="tlaUNC" title="Branch 9 was not executed"> # </span><span class="tlaUNC" title="Branch 10 was not executed"> # </span><span class="tlaUNC" title="Branch 11 was not executed"> # </span>]
<span id="L3574"><span class="lineNum">    3574</span>                 :<span class="tlaUNC">           0 :         pnode-&gt;fDisconnect = true;</span></span>
<span id="L3575"><span class="lineNum">    3575</span>                 :<span class="tlaUNC">           0 :         return true;</span></span>
<span id="L3576"><span class="lineNum">    3576</span>                 :             :     }</span>
<span id="L3577"><span class="lineNum">    3577</span>                 :             :     return false;</span>
<span id="L3578"><span class="lineNum">    3578</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3579"><span class="lineNum">    3579</span>                 :             : </span>
<span id="L3580"><span class="lineNum">    3580</span>                 :<span class="tlaGNC tlaBgGNC">          11 : bool CConnman::DisconnectNode(const CSubNet&amp; subnet)</span></span>
<span id="L3581"><span class="lineNum">    3581</span>                 :             : {</span>
<span id="L3582"><span class="lineNum">    3582</span>                 :<span class="tlaGNC">          11 :     bool disconnected = false;</span></span>
<span id="L3583"><span class="lineNum">    3583</span>                 :<span class="tlaGNC">          11 :     LOCK(m_nodes_mutex);</span></span>
<span id="L3584"><span class="lineNum">    3584</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 11 times"> + </span>]:<span class="tlaGNC">          17 :     for (CNode* pnode : m_nodes) {</span></span>
<span id="L3585"><span class="lineNum">    3585</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 3 times"> + </span>]:<span class="tlaGNC">           6 :         if (subnet.Match(pnode-&gt;addr)) {</span></span>
<span id="L3586"><span class="lineNum">    3586</span>   [<span class="tlaGBC" title="Branch 0 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           6 :             LogDebug(BCLog::NET, &quot;disconnect by subnet%s matched peer=%d; disconnecting\n&quot;, (fLogIPs ? strprintf(&quot;=%s&quot;, subnet.ToString()) : &quot;&quot;), pnode-&gt;GetId());</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaGBC" title="Branch 5 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 6 was not taken"> - </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span><span class="tlaUNC" title="Branch 8 was not taken"> - </span> 
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 9 was not taken"> - </span><span class="tlaGBC" title="Branch 10 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 11 was not taken"> - </span><span class="tlaGBC" title="Branch 12 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 13 was not taken"> - </span> 
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 14 was not taken"> - </span><span class="tlaGBC" title="Branch 15 was taken 3 times"> + </span><span class="tlaUNC" title="Branch 16 was not taken"> - </span><span class="tlaUNC" title="Branch 17 was not taken"> - </span>]
<span id="L3587"><span class="lineNum">    3587</span>                 :<span class="tlaGNC">           3 :             pnode-&gt;fDisconnect = true;</span></span>
<span id="L3588"><span class="lineNum">    3588</span>                 :<span class="tlaGNC">           3 :             disconnected = true;</span></span>
<span id="L3589"><span class="lineNum">    3589</span>                 :             :         }</span>
<span id="L3590"><span class="lineNum">    3590</span>                 :             :     }</span>
<span id="L3591"><span class="lineNum">    3591</span>         [<span class="tlaGBC" title="Branch 0 was taken 11 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          11 :     return disconnected;</span></span>
<span id="L3592"><span class="lineNum">    3592</span>                 :<span class="tlaGNC">          11 : }</span></span>
<span id="L3593"><span class="lineNum">    3593</span>                 :             : </span>
<span id="L3594"><span class="lineNum">    3594</span>                 :<span class="tlaGNC">           6 : bool CConnman::DisconnectNode(const CNetAddr&amp; addr)</span></span>
<span id="L3595"><span class="lineNum">    3595</span>                 :             : {</span>
<span id="L3596"><span class="lineNum">    3596</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :     return DisconnectNode(CSubNet(addr));</span></span>
<span id="L3597"><span class="lineNum">    3597</span>                 :             : }</span>
<span id="L3598"><span class="lineNum">    3598</span>                 :             : </span>
<span id="L3599"><span class="lineNum">    3599</span>                 :<span class="tlaUNC tlaBgUNC">           0 : bool CConnman::DisconnectNode(NodeId id)</span></span>
<span id="L3600"><span class="lineNum">    3600</span>                 :             : {</span>
<span id="L3601"><span class="lineNum">    3601</span>                 :<span class="tlaUNC">           0 :     LOCK(m_nodes_mutex);</span></span>
<span id="L3602"><span class="lineNum">    3602</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for(CNode* pnode : m_nodes) {</span></span>
<span id="L3603"><span class="lineNum">    3603</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (id == pnode-&gt;GetId()) {</span></span>
<span id="L3604"><span class="lineNum">    3604</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             LogDebug(BCLog::NET, &quot;disconnect by id peer=%d; disconnecting\n&quot;, pnode-&gt;GetId());</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3605"><span class="lineNum">    3605</span>                 :<span class="tlaUNC">           0 :             pnode-&gt;fDisconnect = true;</span></span>
<span id="L3606"><span class="lineNum">    3606</span>                 :<span class="tlaUNC">           0 :             return true;</span></span>
<span id="L3607"><span class="lineNum">    3607</span>                 :             :         }</span>
<span id="L3608"><span class="lineNum">    3608</span>                 :             :     }</span>
<span id="L3609"><span class="lineNum">    3609</span>                 :             :     return false;</span>
<span id="L3610"><span class="lineNum">    3610</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3611"><span class="lineNum">    3611</span>                 :             : </span>
<span id="L3612"><span class="lineNum">    3612</span>                 :<span class="tlaUNC">           0 : void CConnman::RecordBytesRecv(uint64_t bytes)</span></span>
<span id="L3613"><span class="lineNum">    3613</span>                 :             : {</span>
<span id="L3614"><span class="lineNum">    3614</span>                 :<span class="tlaUNC">           0 :     nTotalBytesRecv += bytes;</span></span>
<span id="L3615"><span class="lineNum">    3615</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3616"><span class="lineNum">    3616</span>                 :             : </span>
<span id="L3617"><span class="lineNum">    3617</span>                 :<span class="tlaUNC">           0 : void CConnman::RecordBytesSent(uint64_t bytes)</span></span>
<span id="L3618"><span class="lineNum">    3618</span>                 :             : {</span>
<span id="L3619"><span class="lineNum">    3619</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3620"><span class="lineNum">    3620</span>                 :<span class="tlaUNC">           0 :     LOCK(m_total_bytes_sent_mutex);</span></span>
<span id="L3621"><span class="lineNum">    3621</span>                 :             : </span>
<span id="L3622"><span class="lineNum">    3622</span>                 :<span class="tlaUNC">           0 :     nTotalBytesSent += bytes;</span></span>
<span id="L3623"><span class="lineNum">    3623</span>                 :             : </span>
<span id="L3624"><span class="lineNum">    3624</span>                 :<span class="tlaUNC">           0 :     const auto now = GetTime&lt;std::chrono::seconds&gt;();</span></span>
<span id="L3625"><span class="lineNum">    3625</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nMaxOutboundCycleStartTime + MAX_UPLOAD_TIMEFRAME &lt; now)</span></span>
<span id="L3626"><span class="lineNum">    3626</span>                 :             :     {</span>
<span id="L3627"><span class="lineNum">    3627</span>                 :             :         // timeframe expired, reset cycle</span>
<span id="L3628"><span class="lineNum">    3628</span>                 :<span class="tlaUNC">           0 :         nMaxOutboundCycleStartTime = now;</span></span>
<span id="L3629"><span class="lineNum">    3629</span>                 :<span class="tlaUNC">           0 :         nMaxOutboundTotalBytesSentInCycle = 0;</span></span>
<span id="L3630"><span class="lineNum">    3630</span>                 :             :     }</span>
<span id="L3631"><span class="lineNum">    3631</span>                 :             : </span>
<span id="L3632"><span class="lineNum">    3632</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     nMaxOutboundTotalBytesSentInCycle += bytes;</span></span>
<span id="L3633"><span class="lineNum">    3633</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3634"><span class="lineNum">    3634</span>                 :             : </span>
<span id="L3635"><span class="lineNum">    3635</span>                 :<span class="tlaUNC">           0 : uint64_t CConnman::GetMaxOutboundTarget() const</span></span>
<span id="L3636"><span class="lineNum">    3636</span>                 :             : {</span>
<span id="L3637"><span class="lineNum">    3637</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3638"><span class="lineNum">    3638</span>                 :<span class="tlaUNC">           0 :     LOCK(m_total_bytes_sent_mutex);</span></span>
<span id="L3639"><span class="lineNum">    3639</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return nMaxOutboundLimit;</span></span>
<span id="L3640"><span class="lineNum">    3640</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3641"><span class="lineNum">    3641</span>                 :             : </span>
<span id="L3642"><span class="lineNum">    3642</span>                 :<span class="tlaUNC">           0 : std::chrono::seconds CConnman::GetMaxOutboundTimeframe() const</span></span>
<span id="L3643"><span class="lineNum">    3643</span>                 :             : {</span>
<span id="L3644"><span class="lineNum">    3644</span>                 :<span class="tlaUNC">           0 :     return MAX_UPLOAD_TIMEFRAME;</span></span>
<span id="L3645"><span class="lineNum">    3645</span>                 :             : }</span>
<span id="L3646"><span class="lineNum">    3646</span>                 :             : </span>
<span id="L3647"><span class="lineNum">    3647</span>                 :<span class="tlaUNC">           0 : std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle() const</span></span>
<span id="L3648"><span class="lineNum">    3648</span>                 :             : {</span>
<span id="L3649"><span class="lineNum">    3649</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3650"><span class="lineNum">    3650</span>                 :<span class="tlaUNC">           0 :     LOCK(m_total_bytes_sent_mutex);</span></span>
<span id="L3651"><span class="lineNum">    3651</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return GetMaxOutboundTimeLeftInCycle_();</span></span>
<span id="L3652"><span class="lineNum">    3652</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3653"><span class="lineNum">    3653</span>                 :             : </span>
<span id="L3654"><span class="lineNum">    3654</span>                 :<span class="tlaUNC">           0 : std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle_() const</span></span>
<span id="L3655"><span class="lineNum">    3655</span>                 :             : {</span>
<span id="L3656"><span class="lineNum">    3656</span>                 :<span class="tlaUNC">           0 :     AssertLockHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3657"><span class="lineNum">    3657</span>                 :             : </span>
<span id="L3658"><span class="lineNum">    3658</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nMaxOutboundLimit == 0)</span></span>
<span id="L3659"><span class="lineNum">    3659</span>                 :<span class="tlaUNC">           0 :         return 0s;</span></span>
<span id="L3660"><span class="lineNum">    3660</span>                 :             : </span>
<span id="L3661"><span class="lineNum">    3661</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nMaxOutboundCycleStartTime.count() == 0)</span></span>
<span id="L3662"><span class="lineNum">    3662</span>                 :<span class="tlaUNC">           0 :         return MAX_UPLOAD_TIMEFRAME;</span></span>
<span id="L3663"><span class="lineNum">    3663</span>                 :             : </span>
<span id="L3664"><span class="lineNum">    3664</span>                 :<span class="tlaUNC">           0 :     const std::chrono::seconds cycleEndTime = nMaxOutboundCycleStartTime + MAX_UPLOAD_TIMEFRAME;</span></span>
<span id="L3665"><span class="lineNum">    3665</span>                 :<span class="tlaUNC">           0 :     const auto now = GetTime&lt;std::chrono::seconds&gt;();</span></span>
<span id="L3666"><span class="lineNum">    3666</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return (cycleEndTime &lt; now) ? 0s : cycleEndTime - now;</span></span>
<span id="L3667"><span class="lineNum">    3667</span>                 :             : }</span>
<span id="L3668"><span class="lineNum">    3668</span>                 :             : </span>
<span id="L3669"><span class="lineNum">    3669</span>                 :<span class="tlaUNC">           0 : bool CConnman::OutboundTargetReached(bool historicalBlockServingLimit) const</span></span>
<span id="L3670"><span class="lineNum">    3670</span>                 :             : {</span>
<span id="L3671"><span class="lineNum">    3671</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3672"><span class="lineNum">    3672</span>                 :<span class="tlaUNC">           0 :     LOCK(m_total_bytes_sent_mutex);</span></span>
<span id="L3673"><span class="lineNum">    3673</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nMaxOutboundLimit == 0)</span></span>
<span id="L3674"><span class="lineNum">    3674</span>                 :             :         return false;</span>
<span id="L3675"><span class="lineNum">    3675</span>                 :             : </span>
<span id="L3676"><span class="lineNum">    3676</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (historicalBlockServingLimit)</span></span>
<span id="L3677"><span class="lineNum">    3677</span>                 :             :     {</span>
<span id="L3678"><span class="lineNum">    3678</span>                 :             :         // keep a large enough buffer to at least relay each block once</span>
<span id="L3679"><span class="lineNum">    3679</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const std::chrono::seconds timeLeftInCycle = GetMaxOutboundTimeLeftInCycle_();</span></span>
<span id="L3680"><span class="lineNum">    3680</span>                 :<span class="tlaUNC">           0 :         const uint64_t buffer = timeLeftInCycle / std::chrono::minutes{10} * MAX_BLOCK_SERIALIZED_SIZE;</span></span>
<span id="L3681"><span class="lineNum">    3681</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (buffer &gt;= nMaxOutboundLimit || nMaxOutboundTotalBytesSentInCycle &gt;= nMaxOutboundLimit - buffer)</span></span>
<span id="L3682"><span class="lineNum">    3682</span>                 :<span class="tlaUNC">           0 :             return true;</span></span>
<span id="L3683"><span class="lineNum">    3683</span>                 :             :     }</span>
<span id="L3684"><span class="lineNum">    3684</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     else if (nMaxOutboundTotalBytesSentInCycle &gt;= nMaxOutboundLimit)</span></span>
<span id="L3685"><span class="lineNum">    3685</span>                 :<span class="tlaUNC">           0 :         return true;</span></span>
<span id="L3686"><span class="lineNum">    3686</span>                 :             : </span>
<span id="L3687"><span class="lineNum">    3687</span>                 :             :     return false;</span>
<span id="L3688"><span class="lineNum">    3688</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3689"><span class="lineNum">    3689</span>                 :             : </span>
<span id="L3690"><span class="lineNum">    3690</span>                 :<span class="tlaUNC">           0 : uint64_t CConnman::GetOutboundTargetBytesLeft() const</span></span>
<span id="L3691"><span class="lineNum">    3691</span>                 :             : {</span>
<span id="L3692"><span class="lineNum">    3692</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3693"><span class="lineNum">    3693</span>                 :<span class="tlaUNC">           0 :     LOCK(m_total_bytes_sent_mutex);</span></span>
<span id="L3694"><span class="lineNum">    3694</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nMaxOutboundLimit == 0)</span></span>
<span id="L3695"><span class="lineNum">    3695</span>                 :             :         return 0;</span>
<span id="L3696"><span class="lineNum">    3696</span>                 :             : </span>
<span id="L3697"><span class="lineNum">    3697</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return (nMaxOutboundTotalBytesSentInCycle &gt;= nMaxOutboundLimit) ? 0 : nMaxOutboundLimit - nMaxOutboundTotalBytesSentInCycle;</span></span>
<span id="L3698"><span class="lineNum">    3698</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3699"><span class="lineNum">    3699</span>                 :             : </span>
<span id="L3700"><span class="lineNum">    3700</span>                 :<span class="tlaUNC">           0 : uint64_t CConnman::GetTotalBytesRecv() const</span></span>
<span id="L3701"><span class="lineNum">    3701</span>                 :             : {</span>
<span id="L3702"><span class="lineNum">    3702</span>                 :<span class="tlaUNC">           0 :     return nTotalBytesRecv;</span></span>
<span id="L3703"><span class="lineNum">    3703</span>                 :             : }</span>
<span id="L3704"><span class="lineNum">    3704</span>                 :             : </span>
<span id="L3705"><span class="lineNum">    3705</span>                 :<span class="tlaUNC">           0 : uint64_t CConnman::GetTotalBytesSent() const</span></span>
<span id="L3706"><span class="lineNum">    3706</span>                 :             : {</span>
<span id="L3707"><span class="lineNum">    3707</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3708"><span class="lineNum">    3708</span>                 :<span class="tlaUNC">           0 :     LOCK(m_total_bytes_sent_mutex);</span></span>
<span id="L3709"><span class="lineNum">    3709</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return nTotalBytesSent;</span></span>
<span id="L3710"><span class="lineNum">    3710</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3711"><span class="lineNum">    3711</span>                 :             : </span>
<span id="L3712"><span class="lineNum">    3712</span>                 :<span class="tlaGNC tlaBgGNC">         336 : ServiceFlags CConnman::GetLocalServices() const</span></span>
<span id="L3713"><span class="lineNum">    3713</span>                 :             : {</span>
<span id="L3714"><span class="lineNum">    3714</span>                 :<span class="tlaGNC">         336 :     return m_local_services;</span></span>
<span id="L3715"><span class="lineNum">    3715</span>                 :             : }</span>
<span id="L3716"><span class="lineNum">    3716</span>                 :             : </span>
<span id="L3717"><span class="lineNum">    3717</span>                 :<span class="tlaGNC">          40 : static std::unique_ptr&lt;Transport&gt; MakeTransport(NodeId id, bool use_v2transport, bool inbound) noexcept</span></span>
<span id="L3718"><span class="lineNum">    3718</span>                 :             : {</span>
<span id="L3719"><span class="lineNum">    3719</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 40 times"> + </span>]:<span class="tlaGNC">          40 :     if (use_v2transport) {</span></span>
<span id="L3720"><span class="lineNum">    3720</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC tlaBgUNC">           0 :         return std::make_unique&lt;V2Transport&gt;(id, /*initiating=*/!inbound);</span></span>
<span id="L3721"><span class="lineNum">    3721</span>                 :             :     } else {</span>
<span id="L3722"><span class="lineNum">    3722</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 40 times"> + </span>]:<span class="tlaGNC tlaBgGNC">          40 :         return std::make_unique&lt;V1Transport&gt;(id);</span></span>
<span id="L3723"><span class="lineNum">    3723</span>                 :             :     }</span>
<span id="L3724"><span class="lineNum">    3724</span>                 :             : }</span>
<span id="L3725"><span class="lineNum">    3725</span>                 :             : </span>
<span id="L3726"><span class="lineNum">    3726</span>                 :<span class="tlaGNC">          40 : CNode::CNode(NodeId idIn,</span></span>
<span id="L3727"><span class="lineNum">    3727</span>                 :             :              std::shared_ptr&lt;Sock&gt; sock,</span>
<span id="L3728"><span class="lineNum">    3728</span>                 :             :              const CAddress&amp; addrIn,</span>
<span id="L3729"><span class="lineNum">    3729</span>                 :             :              uint64_t nKeyedNetGroupIn,</span>
<span id="L3730"><span class="lineNum">    3730</span>                 :             :              uint64_t nLocalHostNonceIn,</span>
<span id="L3731"><span class="lineNum">    3731</span>                 :             :              const CAddress&amp; addrBindIn,</span>
<span id="L3732"><span class="lineNum">    3732</span>                 :             :              const std::string&amp; addrNameIn,</span>
<span id="L3733"><span class="lineNum">    3733</span>                 :             :              ConnectionType conn_type_in,</span>
<span id="L3734"><span class="lineNum">    3734</span>                 :             :              bool inbound_onion,</span>
<span id="L3735"><span class="lineNum">    3735</span>                 :<span class="tlaGNC">          40 :              CNodeOptions&amp;&amp; node_opts)</span></span>
<span id="L3736"><span class="lineNum">    3736</span>                 :<span class="tlaGNC">          40 :     : m_transport{MakeTransport(idIn, node_opts.use_v2transport, conn_type_in == ConnectionType::INBOUND)},</span></span>
<span id="L3737"><span class="lineNum">    3737</span>                 :<span class="tlaGNC">          40 :       m_permission_flags{node_opts.permission_flags},</span></span>
<span id="L3738"><span class="lineNum">    3738</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 40 times"> + </span>]:<span class="tlaGNC">          40 :       m_sock{sock},</span></span>
<span id="L3739"><span class="lineNum">    3739</span>                 :<span class="tlaGNC">          40 :       m_connected{GetTime&lt;std::chrono::seconds&gt;()},</span></span>
<span id="L3740"><span class="lineNum">    3740</span>                 :<span class="tlaGNC">          40 :       addr{addrIn},</span></span>
<span id="L3741"><span class="lineNum">    3741</span>                 :<span class="tlaGNC">          40 :       addrBind{addrBindIn},</span></span>
<span id="L3742"><span class="lineNum">    3742</span>   [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          40 :       m_addr_name{addrNameIn.empty() ? addr.ToStringAddrPort() : addrNameIn},</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not taken"> - </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L3743"><span class="lineNum">    3743</span>         [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          40 :       m_dest(addrNameIn),</span></span>
<span id="L3744"><span class="lineNum">    3744</span>                 :<span class="tlaGNC">          40 :       m_inbound_onion{inbound_onion},</span></span>
<span id="L3745"><span class="lineNum">    3745</span>         [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          40 :       m_prefer_evict{node_opts.prefer_evict},</span></span>
<span id="L3746"><span class="lineNum">    3746</span>                 :<span class="tlaGNC">          40 :       nKeyedNetGroup{nKeyedNetGroupIn},</span></span>
<span id="L3747"><span class="lineNum">    3747</span>         [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          40 :       m_conn_type{conn_type_in},</span></span>
<span id="L3748"><span class="lineNum">    3748</span>                 :<span class="tlaGNC">          40 :       id{idIn},</span></span>
<span id="L3749"><span class="lineNum">    3749</span>                 :<span class="tlaGNC">          40 :       nLocalHostNonce{nLocalHostNonceIn},</span></span>
<span id="L3750"><span class="lineNum">    3750</span>         [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          40 :       m_recv_flood_size{node_opts.recv_flood_size},</span></span>
<span id="L3751"><span class="lineNum">    3751</span>   [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          80 :       m_i2p_sam_session{std::move(node_opts.i2p_sam_session)}</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 5 was taken 39 times"> + </span>]
<span id="L3752"><span class="lineNum">    3752</span>                 :             : {</span>
<span id="L3753"><span class="lineNum">    3753</span>   [<span class="tlaGBC" title="Branch 0 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 1 was taken 39 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 1 time"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          40 :     if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);</span></span>
<span id="L3754"><span class="lineNum">    3754</span>                 :             : </span>
<span id="L3755"><span class="lineNum">    3755</span>         [<span class="tlaGBC" title="Branch 0 was taken 1400 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 40 times"> + </span>]:<span class="tlaGNC">        1440 :     for (const auto&amp; msg : ALL_NET_MESSAGE_TYPES) {</span></span>
<span id="L3756"><span class="lineNum">    3756</span>         [<span class="tlaGBC" title="Branch 0 was taken 1400 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">        1400 :         mapRecvBytesPerMsgType[msg] = 0;</span></span>
<span id="L3757"><span class="lineNum">    3757</span>                 :             :     }</span>
<span id="L3758"><span class="lineNum">    3758</span>         [<span class="tlaGBC" title="Branch 0 was taken 40 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          40 :     mapRecvBytesPerMsgType[NET_MESSAGE_TYPE_OTHER] = 0;</span></span>
<span id="L3759"><span class="lineNum">    3759</span>                 :             : </span>
<span id="L3760"><span class="lineNum">    3760</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 34 times"> + </span>]:<span class="tlaGNC">          40 :     if (fLogIPs) {</span></span>
<span id="L3761"><span class="lineNum">    3761</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           6 :         LogDebug(BCLog::NET, &quot;Added connection to %s peer=%d\n&quot;, m_addr_name, id);</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L3762"><span class="lineNum">    3762</span>                 :             :     } else {</span>
<span id="L3763"><span class="lineNum">    3763</span>   [<span class="tlaGBC" title="Branch 0 was taken 34 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 34 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          34 :         LogDebug(BCLog::NET, &quot;Added connection peer=%d\n&quot;, id);</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 34 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L3764"><span class="lineNum">    3764</span>                 :             :     }</span>
<span id="L3765"><span class="lineNum">    3765</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          40 : }</span></span>
<span id="L3766"><span class="lineNum">    3766</span>                 :             : </span>
<span id="L3767"><span class="lineNum">    3767</span>                 :<span class="tlaGNC">           2 : void CNode::MarkReceivedMsgsForProcessing()</span></span>
<span id="L3768"><span class="lineNum">    3768</span>                 :             : {</span>
<span id="L3769"><span class="lineNum">    3769</span>                 :<span class="tlaGNC">           2 :     AssertLockNotHeld(m_msg_process_queue_mutex);</span></span>
<span id="L3770"><span class="lineNum">    3770</span>                 :             : </span>
<span id="L3771"><span class="lineNum">    3771</span>                 :<span class="tlaGNC">           2 :     size_t nSizeAdded = 0;</span></span>
<span id="L3772"><span class="lineNum">    3772</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           4 :     for (const auto&amp; msg : vRecvMsg) {</span></span>
<span id="L3773"><span class="lineNum">    3773</span>                 :             :         // vRecvMsg contains only completed CNetMessage</span>
<span id="L3774"><span class="lineNum">    3774</span>                 :             :         // the single possible partially deserialized message are held by TransportDeserializer</span>
<span id="L3775"><span class="lineNum">    3775</span>                 :<span class="tlaGNC">           2 :         nSizeAdded += msg.m_raw_message_size;</span></span>
<span id="L3776"><span class="lineNum">    3776</span>                 :             :     }</span>
<span id="L3777"><span class="lineNum">    3777</span>                 :             : </span>
<span id="L3778"><span class="lineNum">    3778</span>                 :<span class="tlaGNC">           2 :     LOCK(m_msg_process_queue_mutex);</span></span>
<span id="L3779"><span class="lineNum">    3779</span>                 :<span class="tlaGNC">           2 :     m_msg_process_queue.splice(m_msg_process_queue.end(), vRecvMsg);</span></span>
<span id="L3780"><span class="lineNum">    3780</span>                 :<span class="tlaGNC">           2 :     m_msg_process_queue_size += nSizeAdded;</span></span>
<span id="L3781"><span class="lineNum">    3781</span>         [<span class="tlaGBC" title="Branch 0 was taken 2 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           2 :     fPauseRecv = m_msg_process_queue_size &gt; m_recv_flood_size;</span></span>
<span id="L3782"><span class="lineNum">    3782</span>                 :<span class="tlaGNC">           2 : }</span></span>
<span id="L3783"><span class="lineNum">    3783</span>                 :             : </span>
<span id="L3784"><span class="lineNum">    3784</span>                 :<span class="tlaGNC">           2 : std::optional&lt;std::pair&lt;CNetMessage, bool&gt;&gt; CNode::PollMessage()</span></span>
<span id="L3785"><span class="lineNum">    3785</span>                 :             : {</span>
<span id="L3786"><span class="lineNum">    3786</span>                 :<span class="tlaGNC">           2 :     LOCK(m_msg_process_queue_mutex);</span></span>
<span id="L3787"><span class="lineNum">    3787</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 2 times"> + </span>]:<span class="tlaGNC">           2 :     if (m_msg_process_queue.empty()) return std::nullopt;</span></span>
<span id="L3788"><span class="lineNum">    3788</span>                 :             : </span>
<span id="L3789"><span class="lineNum">    3789</span>                 :<span class="tlaGNC">           2 :     std::list&lt;CNetMessage&gt; msgs;</span></span>
<span id="L3790"><span class="lineNum">    3790</span>                 :             :     // Just take one message</span>
<span id="L3791"><span class="lineNum">    3791</span>                 :<span class="tlaGNC">           2 :     msgs.splice(msgs.begin(), m_msg_process_queue, m_msg_process_queue.begin());</span></span>
<span id="L3792"><span class="lineNum">    3792</span>                 :<span class="tlaGNC">           2 :     m_msg_process_queue_size -= msgs.front().m_raw_message_size;</span></span>
<span id="L3793"><span class="lineNum">    3793</span>                 :<span class="tlaGNC">           2 :     fPauseRecv = m_msg_process_queue_size &gt; m_recv_flood_size;</span></span>
<span id="L3794"><span class="lineNum">    3794</span>                 :             : </span>
<span id="L3795"><span class="lineNum">    3795</span>                 :<span class="tlaGNC">           4 :     return std::make_pair(std::move(msgs.front()), !m_msg_process_queue.empty());</span></span>
<span id="L3796"><span class="lineNum">    3796</span>                 :<span class="tlaGNC">           2 : }</span></span>
<span id="L3797"><span class="lineNum">    3797</span>                 :             : </span>
<span id="L3798"><span class="lineNum">    3798</span>                 :<span class="tlaGNC">          55 : bool CConnman::NodeFullyConnected(const CNode* pnode)</span></span>
<span id="L3799"><span class="lineNum">    3799</span>                 :             : {</span>
<span id="L3800"><span class="lineNum">    3800</span>   [<span class="tlaGBC" title="Branch 0 was taken 55 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 55 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          55 :     return pnode &amp;&amp; pnode-&gt;fSuccessfullyConnected &amp;&amp; !pnode-&gt;fDisconnect;</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 1 time"> + </span><span class="tlaGBC" title="Branch 5 was taken 54 times"> + </span>]
<span id="L3801"><span class="lineNum">    3801</span>                 :             : }</span>
<span id="L3802"><span class="lineNum">    3802</span>                 :             : </span>
<span id="L3803"><span class="lineNum">    3803</span>                 :<span class="tlaGNC">          22 : void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&amp;&amp; msg)</span></span>
<span id="L3804"><span class="lineNum">    3804</span>                 :             : {</span>
<span id="L3805"><span class="lineNum">    3805</span>                 :<span class="tlaGNC">          22 :     AssertLockNotHeld(m_total_bytes_sent_mutex);</span></span>
<span id="L3806"><span class="lineNum">    3806</span>                 :<span class="tlaGNC">          22 :     size_t nMessageSize = msg.data.size();</span></span>
<span id="L3807"><span class="lineNum">    3807</span>         [<span class="tlaGBC" title="Branch 0 was taken 22 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          22 :     LogDebug(BCLog::NET, &quot;sending %s (%d bytes) peer=%d\n&quot;, msg.m_type, nMessageSize, pnode-&gt;GetId());</span></span>
<span id="L3808"><span class="lineNum">    3808</span>   [<span class="tlaGBC" title="Branch 0 was taken 22 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 10 times"> + </span><span class="tlaGBC" title="Branch 3 was taken 12 times"> + </span>]:<span class="tlaGNC">          22 :     if (gArgs.GetBoolArg(&quot;-capturemessages&quot;, false)) {</span></span>
<span id="L3809"><span class="lineNum">    3809</span>                 :<span class="tlaGNC">          10 :         CaptureMessage(pnode-&gt;addr, msg.m_type, msg.data, /*is_incoming=*/false);</span></span>
<span id="L3810"><span class="lineNum">    3810</span>                 :             :     }</span>
<span id="L3811"><span class="lineNum">    3811</span>                 :             : </span>
<span id="L3812"><span class="lineNum">    3812</span>                 :             :     TRACE6(net, outbound_message,</span>
<span id="L3813"><span class="lineNum">    3813</span>                 :             :         pnode-&gt;GetId(),</span>
<span id="L3814"><span class="lineNum">    3814</span>                 :             :         pnode-&gt;m_addr_name.c_str(),</span>
<span id="L3815"><span class="lineNum">    3815</span>                 :             :         pnode-&gt;ConnectionTypeAsString().c_str(),</span>
<span id="L3816"><span class="lineNum">    3816</span>                 :             :         msg.m_type.c_str(),</span>
<span id="L3817"><span class="lineNum">    3817</span>                 :             :         msg.data.size(),</span>
<span id="L3818"><span class="lineNum">    3818</span>                 :             :         msg.data.data()</span>
<span id="L3819"><span class="lineNum">    3819</span>                 :<span class="tlaGNC">          22 :     );</span></span>
<span id="L3820"><span class="lineNum">    3820</span>                 :             : </span>
<span id="L3821"><span class="lineNum">    3821</span>                 :<span class="tlaGNC">          22 :     size_t nBytesSent = 0;</span></span>
<span id="L3822"><span class="lineNum">    3822</span>                 :<span class="tlaGNC">          22 :     {</span></span>
<span id="L3823"><span class="lineNum">    3823</span>                 :<span class="tlaGNC">          22 :         LOCK(pnode-&gt;cs_vSend);</span></span>
<span id="L3824"><span class="lineNum">    3824</span>                 :             :         // Check if the transport still has unsent bytes, and indicate to it that we're about to</span>
<span id="L3825"><span class="lineNum">    3825</span>                 :             :         // give it a message to send.</span>
<span id="L3826"><span class="lineNum">    3826</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 16 times"> + </span>]:<span class="tlaGNC">          22 :         const auto&amp; [to_send, more, _msg_type] =</span></span>
<span id="L3827"><span class="lineNum">    3827</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 16 times"> + </span>]:<span class="tlaGNC">          22 :             pnode-&gt;m_transport-&gt;GetBytesToSend(/*have_next_message=*/true);</span></span>
<span id="L3828"><span class="lineNum">    3828</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 16 times"> + </span><span class="tlaUNC" title="Branch 2 was not taken"> - </span><span class="tlaGBC" title="Branch 3 was taken 6 times"> + </span>]:<span class="tlaGNC">          22 :         const bool queue_was_empty{to_send.empty() &amp;&amp; pnode-&gt;vSendMsg.empty()};</span></span>
<span id="L3829"><span class="lineNum">    3829</span>                 :             : </span>
<span id="L3830"><span class="lineNum">    3830</span>                 :             :         // Update memory usage of send buffer.</span>
<span id="L3831"><span class="lineNum">    3831</span>                 :<span class="tlaGNC">          22 :         pnode-&gt;m_send_memusage += msg.GetMemoryUsage();</span></span>
<span id="L3832"><span class="lineNum">    3832</span>         [<span class="tlaGBC" title="Branch 0 was taken 22 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          22 :         if (pnode-&gt;m_send_memusage + pnode-&gt;m_transport-&gt;GetSendMemoryUsage() &gt; nSendBufferMaxSize) pnode-&gt;fPauseSend = true;</span></span>
<span id="L3833"><span class="lineNum">    3833</span>                 :             :         // Move message to vSendMsg queue.</span>
<span id="L3834"><span class="lineNum">    3834</span>         [<span class="tlaGBC" title="Branch 0 was taken 22 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          22 :         pnode-&gt;vSendMsg.push_back(std::move(msg));</span></span>
<span id="L3835"><span class="lineNum">    3835</span>                 :             : </span>
<span id="L3836"><span class="lineNum">    3836</span>                 :             :         // If there was nothing to send before, and there is now (predicted by the &quot;more&quot; value</span>
<span id="L3837"><span class="lineNum">    3837</span>                 :             :         // returned by the GetBytesToSend call above), attempt &quot;optimistic write&quot;:</span>
<span id="L3838"><span class="lineNum">    3838</span>                 :             :         // because the poll/select loop may pause for SELECT_TIMEOUT_MILLISECONDS before actually</span>
<span id="L3839"><span class="lineNum">    3839</span>                 :             :         // doing a send, try sending from the calling thread if the queue was empty before.</span>
<span id="L3840"><span class="lineNum">    3840</span>                 :             :         // With a V1Transport, more will always be true here, because adding a message always</span>
<span id="L3841"><span class="lineNum">    3841</span>                 :             :         // results in sendable bytes there, but with V2Transport this is not the case (it may</span>
<span id="L3842"><span class="lineNum">    3842</span>                 :             :         // still be in the handshake).</span>
<span id="L3843"><span class="lineNum">    3843</span>   [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 16 times"> + </span><span class="tlaGBC" title="Branch 2 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          22 :         if (queue_was_empty &amp;&amp; more) {</span></span>
<span id="L3844"><span class="lineNum">    3844</span>         [<span class="tlaGBC" title="Branch 0 was taken 6 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           6 :             std::tie(nBytesSent, std::ignore) = SocketSendData(*pnode);</span></span>
<span id="L3845"><span class="lineNum">    3845</span>                 :             :         }</span>
<span id="L3846"><span class="lineNum">    3846</span>                 :<span class="tlaGNC">          22 :     }</span></span>
<span id="L3847"><span class="lineNum">    3847</span>         [<span class="tlaUNC" title="Branch 0 was not taken"> - </span><span class="tlaGBC" title="Branch 1 was taken 22 times"> + </span>]:<span class="tlaGNC">          22 :     if (nBytesSent) RecordBytesSent(nBytesSent);</span></span>
<span id="L3848"><span class="lineNum">    3848</span>                 :<span class="tlaGNC">          22 : }</span></span>
<span id="L3849"><span class="lineNum">    3849</span>                 :             : </span>
<span id="L3850"><span class="lineNum">    3850</span>                 :<span class="tlaGNC">           7 : bool CConnman::ForNode(NodeId id, std::function&lt;bool(CNode* pnode)&gt; func)</span></span>
<span id="L3851"><span class="lineNum">    3851</span>                 :             : {</span>
<span id="L3852"><span class="lineNum">    3852</span>                 :<span class="tlaGNC">           7 :     CNode* found = nullptr;</span></span>
<span id="L3853"><span class="lineNum">    3853</span>                 :<span class="tlaGNC">           7 :     LOCK(m_nodes_mutex);</span></span>
<span id="L3854"><span class="lineNum">    3854</span>         [<span class="tlaGBC" title="Branch 0 was taken 44 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          44 :     for (auto&amp;&amp; pnode : m_nodes) {</span></span>
<span id="L3855"><span class="lineNum">    3855</span>         [<span class="tlaGBC" title="Branch 0 was taken 37 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 7 times"> + </span>]:<span class="tlaGNC">          44 :         if(pnode-&gt;GetId() == id) {</span></span>
<span id="L3856"><span class="lineNum">    3856</span>                 :             :             found = pnode;</span>
<span id="L3857"><span class="lineNum">    3857</span>                 :             :             break;</span>
<span id="L3858"><span class="lineNum">    3858</span>                 :             :         }</span>
<span id="L3859"><span class="lineNum">    3859</span>                 :             :     }</span>
<span id="L3860"><span class="lineNum">    3860</span>   [<span class="tlaGBC" title="Branch 0 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">           8 :     return found != nullptr &amp;&amp; NodeFullyConnected(found) &amp;&amp; func(found);</span></span>
<span class="lineNum">        </span> <span class="tlaGBC" title="Branch 4 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span><span class="tlaGBC" title="Branch 6 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 7 was not taken"> - </span><span class="tlaGBC" title="Branch 8 was taken 1 time"> + </span> 
<span class="lineNum">        </span>       <span class="tlaGBC" title="Branch 9 was taken 6 times"> + </span><span class="tlaGBC" title="Branch 10 was taken 7 times"> + </span><span class="tlaUNC" title="Branch 11 was not taken"> - </span>]
<span id="L3861"><span class="lineNum">    3861</span>                 :<span class="tlaGNC">           7 : }</span></span>
<span id="L3862"><span class="lineNum">    3862</span>                 :             : </span>
<span id="L3863"><span class="lineNum">    3863</span>                 :<span class="tlaUNC tlaBgUNC">           0 : CSipHasher CConnman::GetDeterministicRandomizer(uint64_t id) const</span></span>
<span id="L3864"><span class="lineNum">    3864</span>                 :             : {</span>
<span id="L3865"><span class="lineNum">    3865</span>                 :<span class="tlaUNC">           0 :     return CSipHasher(nSeed0, nSeed1).Write(id);</span></span>
<span id="L3866"><span class="lineNum">    3866</span>                 :             : }</span>
<span id="L3867"><span class="lineNum">    3867</span>                 :             : </span>
<span id="L3868"><span class="lineNum">    3868</span>                 :<span class="tlaUNC">           0 : uint64_t CConnman::CalculateKeyedNetGroup(const CAddress&amp; address) const</span></span>
<span id="L3869"><span class="lineNum">    3869</span>                 :             : {</span>
<span id="L3870"><span class="lineNum">    3870</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;unsigned char&gt; vchNetGroup(m_netgroupman.GetGroup(address));</span></span>
<span id="L3871"><span class="lineNum">    3871</span>                 :             : </span>
<span id="L3872"><span class="lineNum">    3872</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup).Finalize();</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L3873"><span class="lineNum">    3873</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3874"><span class="lineNum">    3874</span>                 :             : </span>
<span id="L3875"><span class="lineNum">    3875</span>                 :<span class="tlaUNC">           0 : void CConnman::PerformReconnections()</span></span>
<span id="L3876"><span class="lineNum">    3876</span>                 :             : {</span>
<span id="L3877"><span class="lineNum">    3877</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_reconnections_mutex);</span></span>
<span id="L3878"><span class="lineNum">    3878</span>                 :<span class="tlaUNC">           0 :     AssertLockNotHeld(m_unused_i2p_sessions_mutex);</span></span>
<span id="L3879"><span class="lineNum">    3879</span>                 :<span class="tlaUNC">           0 :     while (true) {</span></span>
<span id="L3880"><span class="lineNum">    3880</span>                 :             :         // Move first element of m_reconnections to todo (avoiding an allocation inside the lock).</span>
<span id="L3881"><span class="lineNum">    3881</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         decltype(m_reconnections) todo;</span></span>
<span id="L3882"><span class="lineNum">    3882</span>                 :<span class="tlaUNC">           0 :         {</span></span>
<span id="L3883"><span class="lineNum">    3883</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             LOCK(m_reconnections_mutex);</span></span>
<span id="L3884"><span class="lineNum">    3884</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (m_reconnections.empty()) break;</span></span>
<span id="L3885"><span class="lineNum">    3885</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             todo.splice(todo.end(), m_reconnections, m_reconnections.begin());</span></span>
<span id="L3886"><span class="lineNum">    3886</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L3887"><span class="lineNum">    3887</span>                 :             : </span>
<span id="L3888"><span class="lineNum">    3888</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         auto&amp; item = *todo.begin();</span></span>
<span id="L3889"><span class="lineNum">    3889</span>                 :<span class="tlaUNC">           0 :         OpenNetworkConnection(item.addr_connect,</span></span>
<span id="L3890"><span class="lineNum">    3890</span>                 :             :                               // We only reconnect if the first attempt to connect succeeded at</span>
<span id="L3891"><span class="lineNum">    3891</span>                 :             :                               // connection time, but then failed after the CNode object was</span>
<span id="L3892"><span class="lineNum">    3892</span>                 :             :                               // created. Since we already know connecting is possible, do not</span>
<span id="L3893"><span class="lineNum">    3893</span>                 :             :                               // count failure to reconnect.</span>
<span id="L3894"><span class="lineNum">    3894</span>                 :             :                               /*fCountFailure=*/false,</span>
<span id="L3895"><span class="lineNum">    3895</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                               std::move(item.grant),</span></span>
<span id="L3896"><span class="lineNum">    3896</span>                 :<span class="tlaUNC">           0 :                               item.destination.empty() ? nullptr : item.destination.c_str(),</span></span>
<span id="L3897"><span class="lineNum">    3897</span>                 :             :                               item.conn_type,</span>
<span id="L3898"><span class="lineNum">    3898</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                               item.use_v2transport);</span></span>
<span id="L3899"><span class="lineNum">    3899</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L3900"><span class="lineNum">    3900</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3901"><span class="lineNum">    3901</span>                 :             : </span>
<span id="L3902"><span class="lineNum">    3902</span>                 :<span class="tlaUNC">           0 : void CConnman::ASMapHealthCheck()</span></span>
<span id="L3903"><span class="lineNum">    3903</span>                 :             : {</span>
<span id="L3904"><span class="lineNum">    3904</span>                 :<span class="tlaUNC">           0 :     const std::vector&lt;CAddress&gt; v4_addrs{GetAddresses(/*max_addresses=*/ 0, /*max_pct=*/ 0, Network::NET_IPV4, /*filtered=*/ false)};</span></span>
<span id="L3905"><span class="lineNum">    3905</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     const std::vector&lt;CAddress&gt; v6_addrs{GetAddresses(/*max_addresses=*/ 0, /*max_pct=*/ 0, Network::NET_IPV6, /*filtered=*/ false)};</span></span>
<span id="L3906"><span class="lineNum">    3906</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;CNetAddr&gt; clearnet_addrs;</span></span>
<span id="L3907"><span class="lineNum">    3907</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     clearnet_addrs.reserve(v4_addrs.size() + v6_addrs.size());</span></span>
<span id="L3908"><span class="lineNum">    3908</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::transform(v4_addrs.begin(), v4_addrs.end(), std::back_inserter(clearnet_addrs),</span></span>
<span id="L3909"><span class="lineNum">    3909</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         [](const CAddress&amp; addr) { return static_cast&lt;CNetAddr&gt;(addr); });</span></span>
<span id="L3910"><span class="lineNum">    3910</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::transform(v6_addrs.begin(), v6_addrs.end(), std::back_inserter(clearnet_addrs),</span></span>
<span id="L3911"><span class="lineNum">    3911</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         [](const CAddress&amp; addr) { return static_cast&lt;CNetAddr&gt;(addr); });</span></span>
<span id="L3912"><span class="lineNum">    3912</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     m_netgroupman.ASMapHealthCheck(clearnet_addrs);</span></span>
<span id="L3913"><span class="lineNum">    3913</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L3914"><span class="lineNum">    3914</span>                 :             : </span>
<span id="L3915"><span class="lineNum">    3915</span>                 :             : // Dump binary message to file, with timestamp.</span>
<span id="L3916"><span class="lineNum">    3916</span>                 :<span class="tlaGNC tlaBgGNC">           5 : static void CaptureMessageToFile(const CAddress&amp; addr,</span></span>
<span id="L3917"><span class="lineNum">    3917</span>                 :             :                                  const std::string&amp; msg_type,</span>
<span id="L3918"><span class="lineNum">    3918</span>                 :             :                                  Span&lt;const unsigned char&gt; data,</span>
<span id="L3919"><span class="lineNum">    3919</span>                 :             :                                  bool is_incoming)</span>
<span id="L3920"><span class="lineNum">    3920</span>                 :             : {</span>
<span id="L3921"><span class="lineNum">    3921</span>                 :             :     // Note: This function captures the message at the time of processing,</span>
<span id="L3922"><span class="lineNum">    3922</span>                 :             :     // not at socket receive/send time.</span>
<span id="L3923"><span class="lineNum">    3923</span>                 :             :     // This ensures that the messages are always in order from an application</span>
<span id="L3924"><span class="lineNum">    3924</span>                 :             :     // layer (processing) perspective.</span>
<span id="L3925"><span class="lineNum">    3925</span>                 :<span class="tlaGNC">           5 :     auto now = GetTime&lt;std::chrono::microseconds&gt;();</span></span>
<span id="L3926"><span class="lineNum">    3926</span>                 :             : </span>
<span id="L3927"><span class="lineNum">    3927</span>                 :             :     // Windows folder names cannot include a colon</span>
<span id="L3928"><span class="lineNum">    3928</span>                 :<span class="tlaGNC">           5 :     std::string clean_addr = addr.ToStringAddrPort();</span></span>
<span id="L3929"><span class="lineNum">    3929</span>                 :<span class="tlaGNC">           5 :     std::replace(clean_addr.begin(), clean_addr.end(), ':', '_');</span></span>
<span id="L3930"><span class="lineNum">    3930</span>                 :             : </span>
<span id="L3931"><span class="lineNum">    3931</span>   [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span> :<span class="tlaGNC">          30 :     fs::path base_path = gArgs.GetDataDirNet() / &quot;message_capture&quot; / fs::u8path(clean_addr);</span></span>
<span class="lineNum">        </span>          <span class="tlaGBC" title="Branch 4 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 5 was not taken"> - </span>]
<span id="L3932"><span class="lineNum">    3932</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           5 :     fs::create_directories(base_path);</span></span>
<span id="L3933"><span class="lineNum">    3933</span>                 :             : </span>
<span id="L3934"><span class="lineNum">    3934</span>   [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">          15 :     fs::path path = base_path / (is_incoming ? &quot;msgs_recv.dat&quot; : &quot;msgs_sent.dat&quot;);</span></span>
<span id="L3935"><span class="lineNum">    3935</span>   [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span><span class="tlaGBC" title="Branch 2 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 3 was not taken"> - </span>]:<span class="tlaGNC">           5 :     AutoFile f{fsbridge::fopen(path, &quot;ab&quot;)};</span></span>
<span id="L3936"><span class="lineNum">    3936</span>                 :             : </span>
<span id="L3937"><span class="lineNum">    3937</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           5 :     ser_writedata64(f, now.count());</span></span>
<span id="L3938"><span class="lineNum">    3938</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           5 :     f &lt;&lt; Span{msg_type};</span></span>
<span id="L3939"><span class="lineNum">    3939</span>         [<span class="tlaGBC" title="Branch 0 was taken 18 times"> + </span><span class="tlaGBC" title="Branch 1 was taken 5 times"> + </span>]:<span class="tlaGNC">          23 :     for (auto i = msg_type.length(); i &lt; CMessageHeader::COMMAND_SIZE; ++i) {</span></span>
<span id="L3940"><span class="lineNum">    3940</span>         [<span class="tlaGBC" title="Branch 0 was taken 18 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          36 :         f &lt;&lt; uint8_t{'\0'};</span></span>
<span id="L3941"><span class="lineNum">    3941</span>                 :             :     }</span>
<span id="L3942"><span class="lineNum">    3942</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           5 :     uint32_t size = data.size();</span></span>
<span id="L3943"><span class="lineNum">    3943</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">           5 :     ser_writedata32(f, size);</span></span>
<span id="L3944"><span class="lineNum">    3944</span>         [<span class="tlaGBC" title="Branch 0 was taken 5 times"> + </span><span class="tlaUNC" title="Branch 1 was not taken"> - </span>]:<span class="tlaGNC">          10 :     f &lt;&lt; data;</span></span>
<span id="L3945"><span class="lineNum">    3945</span>                 :<span class="tlaGNC">          15 : }</span></span>
<span id="L3946"><span class="lineNum">    3946</span>                 :             : </span>
<span id="L3947"><span class="lineNum">    3947</span>                 :             : std::function&lt;void(const CAddress&amp; addr,</span>
<span id="L3948"><span class="lineNum">    3948</span>                 :             :                    const std::string&amp; msg_type,</span>
<span id="L3949"><span class="lineNum">    3949</span>                 :             :                    Span&lt;const unsigned char&gt; data,</span>
<span id="L3950"><span class="lineNum">    3950</span>                 :             :                    bool is_incoming)&gt;</span>
<span id="L3951"><span class="lineNum">    3951</span>                 :             :     CaptureMessage = CaptureMessageToFile;</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
